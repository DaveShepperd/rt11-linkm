	.TITLE LINKM PDP11 CROSS LINKER FOR MICROPROCESSORS

DEB$ = 0		;.NE. IF DEBUG MODE
DMP$ = 0		;.NE. IF CRASH DUMP REQUESTED AFTER PASS x
VAX$ = 1		;.NE. IF TO RUN ON VAX SYSTEM
EIS$ = 1		;.NE. IF EIS AVAILABLE

	.SBTTL MACRO DEFINITIONS
	.ENABL LC
	.RADIX 10
	.NLIST BEX,CND

.MACRO GTVNUM
	.ASCII \V6.8\
	.ENDM

	.MCALL .CLOSE,.CSISPC,.DATE,.DSTAT,.ENTER
	.MCALL .EXIT,.FETCH,.GTIM,.GTLIN,.HERR
	.MCALL .LOOKUP,.PRINT,.PURGE,.RCTRLO
	.MCALL .READW,.REOPEN,.SAVES,.SERR,.SETTOP
	.MCALL .SRESET,.TTYIN,.TTYOUT,.WRITW

.MACRO ENTSEC ARG
	.SAVE
	.PSECT ARG
	.ENDM

.MACRO XITSEC
	.RESTORE
	.ENDM

.MACRO MSG MESS,LABL,OPT
	ENTSEC <MSGS,D>
...1	=.
...2	=0
	.IIF NB,<OPT>,...2=OPT
	.IIF NB,<LABL>,LABL:
	.ASCII \MESS\
	.BYTE ...2
	XITSEC
	.PRINT #...1
	.ENDM MSG

.MACRO MSGF MESS,OPT
	.PRINT #$FATAL
	MSG ^\MESS\,,OPT
	.ENDM MSGF

.MACRO MSGW MESS,OPT
	.PRINT #$WARN
	MSG ^\MESS\,,OPT
	.ENDM MSGW

	ENTSEC <MSGS,D>
$FATAL::.ASCII \?LINKM-F-\<128.>
$WARN::	.ASCII \?LINKM-W-\<128.>
	XITSEC

.MACRO RET
	RTS PC
	.ENDM

.MACRO SAVREG
	JSR R5,SAVREG
	.ENDM

.MACRO GENCAL OP,IMM
	.IF NB,<IMM>
	.MACRO OP L
	MOV #L,R0
	CALL OP
	.ENDM
	.IFF
   .MACRO OP L
	.IIF NB,<L>,MOV L,R0
	CALL OP
	.ENDM OP
	.ENDC
	.ENDM GENCAL

	GENCAL SEARCH,I
	GENCAL SCAN,I
	GENCAL SCANC,I
	GENCAL SCANW,I
	GENCAL SCANWC,I
	GENCAL CHSCAN,I
	GENCAL NEXT,I
	GENCAL APPEND,I
	GENCAL ZAP,I
	GENCAL INSERT
	GENCAL DELETE
	GENCAL SETROL


.MACRO TFILE ARG
	.IF NB,<ARG>
	MOV ARG,R0
	.IFF
	CLR R0
	.ENDC
	JMP TFILE
	.ENDM

.IF EQ,EIS$
.MACRO DIV S,D
	.IIF DIF,<S>,<R3>,MOV S,R3
	.IIF DIF,<D>,<R0>,.ERROR D ;ILLEGAL DIV ARG
	CALL DIV
	.ENDM

.MACRO MUL S,D
	.IIF DIF,<S>,<R3>,MOV S,R3
	.IIF DIF,<D>,<R0>,.ERROR D ;ILLEGAL MUL ARG
	CALL MUL
	.ENDM

.MACRO SOB R,A
	DEC R
	BNE A
	.ENDM

.MACRO SXT ARG,?LAB1,?LAB2
	BMI LAB1
	MOV #0,ARG	;CAN'T MESS THE CARRY
	BR LAB2
LAB1:	MOV #-1,ARG
LAB2:
	.ENDM
.ENDC

.macro	xor src,dst
	mov src,-(sp)
	bic dst,(sp)
	bic src,dst
	bis (sp)+,dst
	.endm

.MACRO PRINT ARG,ROOM,COUNT
	.IIF NB,<ARG>,MOV ARG,R0
	.IIF NB,<COUNT>,MOVB COUNT,-(SP)
	.IIF B,<COUNT>,CLR -(SP)
	.IIF NB,<ROOM>,MOVB ROOM,-(SP)
	.IIF B,<ROOM>,CLR -(SP)
	CALL PRINT
	.ENDM
	.PAGE
	.SBTTL Integer MULtilply Immeadiate macro

.MACRO IMULI COUNT,ADDR
	.LIST MEB
T.VAL	=COUNT
	.IF EQ,T.VAL
	CLR ADDR
	.IFF
	.IF LT,T.VAL
T.VAL	=-T.VAL
	NEG ADDR
	.ENDC
T.FLAG	=0
T.MASK	=^O40000
	.REPT 14.
	.IF LE,T.MASK-T.VAL
	.IF NE,T.MASK&T.VAL
	.IF NE,T.MASK-T.VAL
	.IF EQ,T.FLAG
	MOV ADDR,-(SP)
T.FLAG	=1
	.IFF
	.IF NE,T.MASK-1&T.VAL
	ADD (SP),ADDR
	.IFF
	ADD (SP)+,ADDR
T.FLAG	=0
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	ASL ADDR
	.ENDC
T.MASK	=T.MASK/2
	.ENDR
	.IF NE,T.FLAG
	ADD (SP)+,ADDR
	.ENDC
	.ENDC
	.NLIST MEB
	.ENDM IMULI
.if ne,deb$
.if ne,vax$
	.page
; The following is a MACRO to create the required flag word for the
; SNAP dump feature of RT11TASK. The arguments are:
;
;	NUM - number of bytes to dump (0 to 255.)
;	RAD - radix select, can be either 8. or 16.
;	BYT - if 1, then dump bytes otherwise dump words
;	R50 - if 1, then dump words with RAD50 equivalent too.
;	REG - if 1, then dump registers then dump memory
;	IND - if 1, then address is indirect
;	ASC - if 1, then dump only ASCII bytes
;	DAT - if 1,then display date/time on dump
;
; DUMP argument lists consist of word pairs where the first word is the flag
; word and the second is the starting address (or the address of the address) 
; to dump stored position independent (address-.).
; The argument list is terminated with a flag word of 0.
;
; THE EXECUTION OF A SNAP DUMP DOES NOT AFFECT THE CONDITION CODES.

.MACRO SNPFLG NUM=0,RAD=8.,BYT=0,R50=0,REG=0,IND=0,ASC=0,DAT=0
	...1=NUM&255.
	.IIF NE,BYT,	...1=...1+256.
	.IF EQ,RAD-8.
	.IFF
	.IF EQ,RAD-16.
	...1=...1+512.
	.IFF
	.ERROR RAD ;RADIX CAN BE ONLY 8 OR 16
	.ENDC
	.ENDC
	.IIF NE,R50,	...1=...1+1024.
	.IIF NE,REG,	...1=...1+2048.
	.IIF NE,IND,	...1=...1+4096.
	.IIF NE,ASC,	...1=...1+8192.
	.IIF NE,DAT,	...1=...1+16384.
	.WORD ...1
	.ENDM

.MACRO SNPADR ADDRESS
	.WORD <ADDRESS>-.
	.ENDM

.MACRO SNAP ARG
	.WORD ^O30,<ARG>-.
	.ENDM

; Some examples on how to use the SNAP dump:

; STMSG: .ASCII \Symbol Table (first 32 symbols):\
; STMSGS = .-STMSG
; SSYM:  .ASCII \SYMBOL (temporary area)\
; SSYMS = .-SSYM
; SNPARG:
;	SNPFLG NUM=STMSGS,ASC=1,DAT=1
;	SNPADR STMSG
;	SNPFLG NUM=128.,IND=1,R50=1,REG=1
;	SNPADR ROLBAS+SYMROL
;	SNPFLG NUM=SSYMS,ASC=1
;	SNPADR SSYM
;	SNPFLG NUM=8.,R50=1
;	SNPADR SYMBOL
;	.WORD 0			;TERMINATE THE ARGUMENT LIST
;	.
;	.
;	.
;LOOP:	CALL STUFF	;do the program
;	SNAP SNPARG	;do the snap dump.
;	.
;	.
;	BR LOOP
	.page
.endc
.sbttl	debugging macros

	.save
	.psect debug
db.fix:	mov r1,-(sp)		;save r1 (r0 is already on the stack)
	mov 6(sp),r1		;get number to print
	mov 4(sp),6(sp)		;move the return address
	mov 2(sp),4(sp)		;move the saved r0 value
	mov (sp)+,(sp)		;move the saved r1 value
				;stack frame = 	saved r1
				;		saved r0
				;		return from call to "db.xxx"
				; r0 = return to call from fix
				; r1 = number to print
	call (r0)		;call back the caller
	mov (sp)+,r1		;restore regs
	mov (sp)+,r0
	return

db.ocb:	jsr r0,db.fix		;fix the stack, save r0,r1
	clr r0			;get only the lower byte
	bisb r1,r0
	swab r0
	ror r0			;adjust for the 3 bit shifts
	mov r0,-(sp)
	mov #3,r1		;loop counter
	br db.coc		;do common octal stuff

db.ocw:	jsr r0,db.fix		;fix the stack, save some regs
	mov r1,r0		;get the number
	asl r0			;put bit 15 into bit 0 position
	adc r0
	mov r0,-(sp)		;save the number again
	bic #-2,r0		;print the first bit
	bis #'0,r0
	.ttyout
	mov #5,r1		;loop count
db.coc:	asl (sp)		;get the next digit
	adc (sp)
	asl (sp)
	adc (sp)
	asl (sp)
	adc (sp)
	mov (sp),r0
	bic #-8.,r0
	bis #'0,r0
	.ttyout
	sob r1,db.coc
	tst (sp)+		;purge stack
	return			;and return

db.hex:	.ascii \0123456789ABCDEF\

db.hxb:	jsr r0,db.fix		;fix the stack, save r0,r1
	br db.chb		;do common byte output

db.hxw:	jsr r0,db.fix		;fix the stack, save r0,r1
	swab r1			;get the upper byte first
	call db.chb		;print hex byte
	swab r1			;get the lower byte

db.chb:	clr r0			;zap r0
	bisb r1,r0		;get the lower byte
	asr r0			;/16
	asr r0
	asr r0
	asr r0
	call 10$		;print it
	mov r1,r0
	bic #-16.,r0		;zap the upper nibble
10$:	movb db.hex(r0),r0	;get the ascii equivalent
	.ttyout			;and display it
	return
	.restore

.macro	say text,nocrlf
	mov r0,-(sp)
	msg <text>,,nocrlf
	mov (sp)+,r0
	.endm say

.macro octal number,nocrlf
	mov number,-(sp)
	call db.ocw
   .if b,<nocrlf>
	say <>
   .endc
	.endm octal

.macro octalb number,nocrlf
	mov number,-(sp)
	call db.ocb
  .if b,<nocrlf>
	say <>
  .endc
.endm octalb

.macro hex number,nocrlf
	mov number,-(sp)
	call db.hxw
   .if b,<nocrlf>
	say <>
   .endc
.endm hex

.macro hexb number,nocrlf
	mov number,-(sp)
	call db.hxb
    .if b,<nocrlf>
	say <>
    .endc
.endm hexb

.macro	show what
	say <	what=	>,128.
	hex what
	.endm show

.macro	showb what
	say <	what=	>,128.
	hexb what
	.endm showb

.macro kill what
	.macro what a1,a2,a3,a4,a5,a6,a7,a8
	.endm what
	.endm kill

.macro orkin
	kill hex
	kill hexb
	kill octal
	kill octalb
	kill say
	kill show
	kill showb
	kill orkin
	.endm orkin

.macro	orkin2
	orkin
	kill	dump
	kill	orkin2
	.endm	orkin2
.endc	
	.PAGE
	.SBTTL ROLL DEFINITIONS

	.MACRO GENROL NAME,BASE,TOP,SIZE
	ENTSEC ROLBAS
NAME'ROL==.-ROLBAS
	.WORD BASE
	.PSECT ROLTOP
	.WORD TOP
	.PSECT ROLSIZ
	.WORD SIZE*2
	XITSEC
RS.'NAME=SIZE
	.IIF GT, SIZE-MAXXMT,MAXXMT=SIZE
	.ENDM GENROL

	ENTSEC ROLBAS
ROLBAS::
	.PSECT ROLTOP
ROLTOP::
	.PSECT ROLSIZ
ROLSIZ::
	.PSECT IMPLIN
IMPLIN:
	XITSEC
MAXXMT	=0

	GENROL RLD,0,0,3	;RLD ENTRIES
	GENROL CRF,0,0,8	;CROSS REFERENCES
	GENROL SYM,0,0,4	;SYMBOL TABLE
	GENROL SCR,0,0,3	;SECTION CROSS-REF ROLL
	GENROL SEC,0,0,6	;SECTION NAMES
	GENROL MLD,0,0,8	;MULTIPLE DEFINITIONS
	GENROL MOD,0,0,3	;MODULE NAMES
	GENROL IDN,0,0,3	;IDENTS
	GENROL TIM,0,0,4	;CREATION DATES/TIMES
	GENROL FIL,0,0,5	;FILE SPECS
	GENROL DUM,0,0,0	;DUMMY ROLL AT END TO STOP THINGS
	GENROL PST,PSTBAS,PSTTOP,3	;PERMANENT SYMBOLS FOR OPTIONS

	ENTSEC IMPURE
IMPURE::
	XITSEC

	.IDENT /ITEST/
	.PAGE
	.SBTTL DATA DECLARATIONS

CR	=^O15
FF	=^O14
LF	=^O12
ERRBYT	=^O52
ERRCOM	=^O53
RMON	=^O54
ER.WRN	=1
ER.ERR	=2
ER.HER	=4

	ENTSEC IMPURE
SYMBOL::.BLKW MAXXMT		;SYMBOL NAME AND STUFF
TMPSYM:	.BLKW MAXXMT		;TEMPORARY SYMBOL STORAGE
WA:	.BLKW 6			;I/O PROG.REQ. SPACE
SCHAN::	.BLKW
CHAN::	.BLKW
DPAGE:	.BLKW			;DPAGE FOR MAC69
LNKNXT:	.BLKW
FILEN:	.BLKW 4			;SPEC OF CURRENT FILE
CSISPC:	.BLKW 39		;WORK SPACE FOR CSI
BOTTOM:	.BLKW			;FLOATING FREE SPACE POINTER
STLLIM:	.BLKW			;STACK LOWER LIMIT
STGARD:	.BLKW			;STACK GUARD ZONE
STWARN:	.BLKW			;STACK UNDERFLOW'D ONCE
CSLCNT:	.BLKW			;COUNT OF CSI LINES ENTERED
CSEND:	.BLKW

CSBUFF::.BLKW 256		;COMMAND STRING BUFFER
OBUF:	.BLKW 256		;OUTPUT BUFFER
IBUF:	.BLKW 256		;INPUT BUFFER
MBUF:	.BLKW 256		;MAP BUFFER

.LNK::	.BLKW			;.LNK INDIRECT INPUT
SWA::	.BLKW			;NOT USED ANYMORE
SWC::	.BLKW			;CONTINUE ON NEXT LINE
SWL::	.BLKW			;.LDA REQUESTED
SWR::	.BLKW			;X-REF OUTPUT REQUESTED
SWO::	.BLKW			;DISPLAY OUTPUT IN OCTAL
XCRF:	.BLKW			;DISABLE CROSS REFERENCES
XUDF:	.BLKW			;DISABLE UNDEFINED CROSS REFERENCES
XMDF:	.BLKW			;DISABLE MULTIPLE DEFINED REFERENCES
MDFCNT:	.BLKW			;COUNT MULTIPLE DEFINED
CNTQAL:	.BLKW			;COUNT OF X-REF QUALIFIERS
CRFQAL:	.BLKW 26		;X-REF QUALIFIERS
R3SAV:	.BLKW			;REG SAVE AREA
R4SAV:	.BLKW
R5SAV:	.BLKW
SAEOF:	.BLKW

IBP:	.BLKW			;INPUT BUFFER POINTER
IBLOCK:	.BLKW			;INPUT BLOCK POINTER
OBP:	.BLKW			;OUTPUT BUFFER POINTER
OBLOCK:	.BLKW			;OUTPUT BLOCK POINTER
MBP:	.BLKW			;MAP BUFFER POINTER
MBLOCK:	.BLKW			;MAP BLOCK POINTER

RBUFF:	.BLKW 256		;RECORD BUFFER
RBSIZE	=.-RBUFF

OUT::	.BLKW 5			;OUTPUT FILE SPEC
MAP::	.BLKW 5			;MAP FILE SPEC
SYM::	.BLKW 5			;SYMBOL TABLE FILE SPEC
	XITSEC

	ENTSEC PURE
LIM:	.LIMIT
DEXT:	.RAD50 /OBJ/		;INPUT
	.RAD50 /SAV/		;OUTPUT
	.RAD50 /MAP/		;OUTPUT
	.RAD50 /SYM/		;OUTPUT
	XITSEC

	ENTSEC MSGS
VERSION: .ASCII \% Atari LINKM \
	GTVNUM
	.ASCIZ \ %\
	XITSEC
	.PAGE
	.SBTTL ENTRY
	ENTSEC MAIN
START::	JSR R4,INIT		;GO INITIALISE STUFF
	MOV #CSBUFF,R4		;POINT TO COMMAND STRING BUFFER
	CLR R3			;GET FIRST INPUT FROM TERMINAL

	.ENABL LSB
BEGIN::	MOV #CSISPC,R5		;POINT TO CSI SPACE
	.CSISPC R5,#DEXT,R3,R4	;GET FILE SPECS
	BCC 20$			;OK
	MSGF <Illegal command string. - >,128
	.PRINT R3
	BR START

20$:	INC CSLCNT		;COUNT COMMAND LINE
	TSTB SWC+1		;FIRST TIME THROUGH?
	BNE 40$			;NOPE
	MOV #OUT,R0
	MOV R5,R1		;COPY OUTPUT SPECS
	MOV #15,R2		;15 WORDS

30$:	MOV (R1),(R0)+
	CLR (R1)+		;COVER OUR TRACKS
	SOB R2,30$

40$:	TST 30(R5)		;ANY INPUT?
	BNE 50$			;YES. PROCEED
	.PRINT #VERSION		;DISPLAY VERSION NUMBER
	BR START

50$:	MOV (SP)+,R2		;GET SWITCH COUNT
	BEQ STEP1		;NONE
	INC .LNK		;DON'T ALLOW .LNK INPUT IF SWITCH INPUT
	MOV R3,R3SAV		;SAVE SOME REGS
	MOV R4,R4SAV		; (CAN'T USE THE STACK HERE)
	MOV R5,R5SAV
60$:	MOV (SP)+,R1		;GET SWITCH
	MOV #SWTBL,R3		;POINT TO THE SWITCH TABLE
	MOVB R1,R0		;GET A COPY OF THE CHAR (0 THE UPPER BYTE)
70$:	MOV (R3)+,R4		;GET ADDRESS OF ROUTINE OR FLAG
	BEQ 100$		;ISN'T IN THE TABLE
	CMP R0,(R3)+		;MATCH CHAR?
	BNE 70$			;NOPE, KEEP LOOKING	
	ASR R4			;ROUTINE?
	BCS 75$			;YEP
	ASL R4			;FIX THE ADDRESS
	INC (R4)		;SET THE FLAG
	BR 90$

75$:	ASL R4			;FIX THE ADDRESS
	MOV #90$,R5		;SET THE RETURN ADDRESS
	JMP (R4)		;GO TO THE ROUTINE
	
90$:	TST R1			;WAS THERE A VALUE?
	BMI 100$		;YEP, CAN'T HAVE THAT
	DEC R2			;COUNT SWITCH
	BGT 60$			;CONTINUE
	MOV R5SAV,R5		;RESTORE THE REGS
	MOV R4SAV,R4
	MOV R3SAV,R3
	BR STEP1

100$:	MSGF <"/>,128
	.TTYOUT R1		;PRINT SWITCH LETTER
	MSG <" illegal switch>
	BR START

SW$L:	TSTB SWC+1		;FIRST TIME THROUGH?
	BNE 100$		;NOPE. BAD SWITCH THEN
	INC SWL			;YEP. SIGNAL SAME
	CMP OUT+6,#^RSAV	;DEXT = .SAV?
	BNE 200$		;NOPE. LEAVE IT ALONE THEN
	MOV #^RLDA,OUT+6	;CHANGE IT TO .LDA
	BR 200$			;CONTINUE

SW$R:	INC SWR			;SIGNAL XREF WANTED
	TST R1			;ANY VALUE?
	BPL 200$		;NOPE
	DEC SWR			;UNDO THE FLAG PREVIOUSLY SET
	MOV (SP)+,R0		;GET THE VALUE
	MOV CNTQAL,R1		;GET INDEX INTO QUALIFIER ARRAY
	CMP R1,#52		;TOO MANY ALREADY?
	BLO 110$		;NOPE
	MSG <Too many xref qualifiers. Extras ignored>
	BR 200$			;CONTINUE

110$:	MOV R0,CRFQAL(R1)	;SAVE THE QUALIFIER
	TST (R1)+		;ADD 2 TO INDEX
	MOV R1,CNTQAL		;SAVE IT
	BR 200$			;GO BACK

SW$I:	TST R1			;VALUE?
	BPL 200$		;NOPE
	MOV (SP)+,R0		;GET THE VALUE
	MOV #SWITBL,R3		;POINT TO SWITCH I TABLE
120$:	MOV (R3)+,R4		;GET ADDRESS OF FLAG
	BEQ 100$		;ILLEGAL VALUE
	CMP R0,(R3)+		;VALUES MATCH?
	BNE 120$		;NOPE
	INC (R4)		;YEP, SET FLAG
	CLR R1			;FIX IT SO THERE ARE NO ERRORS
200$:	JMP (R5)		;GO BACK
	.DSABL LSB

.MACRO SWT CHAR,ADDR
	.WORD ADDR,''CHAR
	.ENDM

SWTBL:	SWT A,SWA		;DON'T CARE ABOUT THIS ONE
	SWT O,SWO		;OCTAL
	SWT C,SWC		;CONTINUATION
	SWT L,SW$L+1		;/LDA REQ. SPECIAL
	SWT R,SW$R+1		;XREF SPECIAL
	SWT I,SW$I+1		;IGNORE INDICATORS
	.WORD 0			;TERMINATOR

.MACRO SWT CHAR,ADDR
	.WORD ADDR
	.RAD50 \CHAR\
	.ENDM
SWITBL:	SWT U,XUDF		;IGNORE UNDEFINED
	SWT M,XMDF		;IGNORE MULTIPLE DEFINES
	SWT R,XCRF		;IGNORE ALL XREF'S
	.WORD 0			;TERMINATOR
	.ENABL LSB
STEP1:	MOV (R5),R0		;OUTPUT FILES?
	BIS 10(R5),R0
	BIS 20(R5),R0
	BEQ 1$			;NOPE
	MSGF <Too many output files specified.>
	JMP START

1$:	TSTB (R4)+		;SKIP TO END OF COMMAND STRING
	BNE 1$
	CMP R4,#OBUF-2		;CAN'T GET TOO BIG
	BLOS 2$			;OK
	MOV #OBUF-2,R4
2$:	MOVB #CR,-1(R4)		;PUT THE CR,LF BACK IN.
	MOVB #LF,(R4)+
	CLRB (R4)		;AND TERMINATE THE STRING
	MOV R4,CSEND		;KEEP TRACK OF END OF STRING

	CALL OPEN		;GET STATS ON INPUT FILES
	TST .LNK		;.LNK LEGAL?
	BNE 10$			;NOPE
	CMP 30+6(R5),#^RLNK	;.LNK INPUT?
	BNE 10$			;NOPE. NEVER MIND
	CALL READ		;READ 1 BLOCK OF INPUT FILE
	INC SCHAN		;SAY THE REAL READ CHANNEL IS 1 GREATER
	MOV #IBUF,R0		;POINT TO INPUT STRING
	MOV R0,R3		;SAVE IT

3$:	CMPB (R0)+,#CR		;LOOK FOR END OF STRING
	BEQ 4$			;FOUND IT
	CMP R0,#IBUF+512	;RUN OFF THE END?
	BLO 3$			;NOPE
	MSGF <.LNK File too long.>
	JMP START

4$:	CLRB -1(R0)		;ZAP THE END FOR C.S.I.
	CLRB (R0)+		;ZAP THE LF CODE
	MOV R0,LNKNXT		;POINT TO THE NEXT INPUT STRING
	INC .LNK		;CAN'T GET ANYMORE .LNK FILES
11$:	JMP BEGIN		;PROCESS COMMAND STRING

10$:	DECB SWC		;/C?
	BMI PASS0		;NOPE. START LINKING
	INCB SWC+1		;YEP. DISALLOW /A,/L AND ANY MORE OUTPUT FILES
	MOV LNKNXT,R3		;POINT TO NEXT C.S.
	BEQ 11$			;COMING FROM TERMINAL
	MOV R3,R0		;COMING FROM FILE. POINT TO NEXT LINE
	BR 3$			;GO FIX UP THE LINE AND CONTINUE
	.DSABL LSB
	.PAGE
	.SBTTL PASS0  LINK PROCESS CONTROL
GSD	=1
ENDGSD	=2
TXT	=3
RLD	=4
ISD	=5
ENDMOD	=6
LIBHDR	=7
LIBEND	=8

PASS0:	MOV #16,R0		;ASSUME OUTPUT RADIX TO 16
	TST SWO			;T-11 MODE?
	BEQ 10$			;NOPE
	ASR R0
10$:	MOV R0,CRADIX		;OPTIONS INPUT DEFAULT
	MOV R0,OUTRDX		;AND OUTPUT LISTING DEFAULT
	MOV R0,DEFRAD		;AND DEFAULT RADIX
20$:	MOV SEQ,R0		;SEQUENCE CODE
	ADD #2,SEQ		;+2 FOR NEXT TIME
	CLR CHAN		;BE SURE TO START AT BEGINING
	CLR IBP			;WITH AN EMPTY BUFFER
	CALL @DTABL(R0)		;CALL ROUTINE
.IF NE,DMP$
	CMP SEQ,#DMP$*2		;ARE WE TO CRASH DUMP HERE?
	BLO 20$			;NOPE
	MOV ROLBAS+CRFROL,R0	;POINT TO PLACE OF CRF ROLL
	MOV ROLBAS+MLDROL,R1	;POINT TO PLACE OF MULTIPLE DEFINITIONS
	MOV #ROLBAS,R2		;POINT TO ROLL BASE
	HALT			;CRASH DUMP
.IFF
	BR 20$			;CONTINUE
.ENDC

DTABL:	INMAP			;INTIALISE THE MAP FILE
	FILSYM			;FILL SYMBOL TABLE
	SUMFIL			;SUMMARIZE FILE STUFF IN MAP
	OPTIONS			;PROCESS OPTIONS FILE
	RELOCT			;RESOLVE ABSOLUTE VALUES OF SYMBOLS
	PURXRF			;DISCARD THE XREF TABLES
	CREBIN			;CREATE BINARY OUTPUT
	SYMOUT			;Symbol table output
	CLOSUP			;CLOSE UP
	START			;BEGIN AGAIN

	.SBTTL FILSYM SYMBOL TABLE CREATION
FILSYM::CLR VTOP
	MOV #-1,VBOTT
.IIF NE,DEB$,	MSG <Fill symbol table>
P1.GR:	CALL READR		;READ A RECORD
	BNE 1$			;GOT ONE
	RET			;END OF ALL FILES

1$:	MOV #RBUFF,R5		;POINT TO START OF RECORD
	MOV R0,R4		;COUNT OF BYTES IN RECORD
	SUB #2,R4		;-2 FOR TYPE WORD
	CMP (R5),#GSD		;GSD ENTRY?
	BEQ 3$			;YEP
	CALL GETTOP		;LOOK FOR .VCTRS STUFF
	BR P1.GR		;CONTINUE

3$:	TST (R5)+		;SKIP TYPE CODE
GSD0:	MOVB 5(R5),R0
	ASL R0			;MAKE IT A WORD INDEX
	CMP R0,#GSDMAX		;LEGAL TYPE?
	BHIS 10$		;NOPE. ERROR EXIT
	MOV R5,-(SP)		;SAVE POINTER
	MOV #SYMBOL,R3		;POINT TO SYMBOL AREA
	JMP @GSDT(R0)		;GO TO ROUTINE
10$:	JMP BADOBJ

GSDT:	 GSDMOD		;TYPE 0 - MODULE NAME
	 CSECT		;     1 - CSECT DECLARATION
	 GSDTIM		;     2 - INTERNAL SYMBOL
	 GSDNXT		;     3 - XFER ADDRESS
	 GLOBAL		;     4 - GLOBAL SYMBOL REF/DEF
	 PSECT		;     5 - PSECT DECLARATION
	 GSDIDN		;     6 - .IDENT NAME
	 GSDNXT		;     7 - .VIR DECLARATION
GSDMAX	=.-GSDT
	.PAGE
	.SBTTL ASECT/CSECT/BSECT/PSECT HANDLERS

	ENTSEC IMPURE
SECNAM:	.BLKW 2
SECFLG:	.BLKB
SECNUM:	.BLKB
SECOFF:	.BLKW
SECLEN:	.BLKW
SEQ:	.BLKW
	XITSEC

; GSD SYMBOL/PSECT DATA TYPES (FOR MAC65,MAC68,MAC69)
S.FORC	=1			;FORCED OFFSET (OPTIONS FILE INPUT)
S.MDF	=2			;MULTIPLY DEFINED
S.OVR	=4			;OVERLAY
S.DEF	=8			;DEFINITION
S.BSE	=16			;BASE PAGE
S.REL	=32			;RELOCATION
S.M68	=64			;6800 WORD TYPE
S.BYT	=128			;BYTE MODE
;GSD PSECT DATA TYPES (FOR MAC11)
S.ALL	=4			;ALLOCATION, 0 = CONCATINATED, 1 = OVERLAY
S.DATA	=128			;0 = SECTION TO BE WORD ALIGNED

GSDNXT:	MOV (SP)+,R5		;RESTORE R5
	ADD #8,R5		;SKIP TO NEXT ITEM
	SUB #8,R4		;DECREMENT BYTE COUNT
	BGT GSD0		;STILL MORE
	BR P1.GR		;GO GET NEXT RECORD

; FOR THE SECROL, THE FOLLOWING DEFINITIONS APPLY

FLAGS	=4			;OFFSET FROM 'SYMBOL' (R3 IN THESE ROUTINES)
SECT	=5
OFFSET	=6
LENGTH	=8

CSECT:	MOVB #S.REL,R0		;ASSUME RELOCATION AND CONCATINATED
	TST (R5)		;TRUE? (UN-NAMED CSECT)
	BEQ 1$			;YEP.
	CMP (R5),#^R. B		;.BSECT?
	BNE 3$			;NOPE
	BIS #S.BSE,R0		;YES. SIGNAL SAME
	TST 2(R5)		;UNNAMED BSECT?
	BEQ 1$			;YEP, CONCATINATE
	BR 2$			;NOPE, OVERLAYED

3$:	CMP (R5),#^R. A		;.ABS?
	BNE 2$			;NAMED CSECTS ARE OVERLAYED
	CMP 2(R5),#^RBS.
	BNE 2$
	CLR R0			;SAY ITS ABSOLUTE
2$:	BIS #S.OVR,R0		;AND OVERLAYED
1$:	MOVB R0,4(R5)		;RECORD FLAGS.
	.PAGE
	.ENABL LSB
PSECT:	MOVB CHAN,5(R5)		;PUT FILE # INTO TYPE CODE BYTE
	MOV (R5)+,(R3)		;PASS SYMBOL
	MOV (R5)+,2(R3)
	MOV 2(R5),(PC)+
PS.0:	.WORD 0			;KEEP LENGTH OF SECTION
	SCAN SECROL		;LOOK FOR SECTION NAME IN ROLL
	BEQ 2$			;DIDN'T FIND ONE
	MOV (R5),-(SP)
	BIC #^C<S.REL!S.OVR!S.BSE>,(SP)
	MOVB FLAGS(R3),R0
	BIC #^C<S.REL!S.OVR!S.BSE>,R0
	CMP (SP)+,R0		;ATTRIBUTES MATCH?
	BEQ 5$			;YEP
	CALL BADATT		;NOPE, PRINT AN ERROR
	MOVB FLAGS(R3),(R5)	;USE THE FIRST VALUE
5$:	BIT #S.OVR,(R5)		;SECTIONS TO BE OVERLAYED
	BEQ 20$			;NOPE, CONCATINATE THEM
	MOV ROLENT,CURSEC	;KEEP TRACK OF CURRENT SECTION #
	CMP 2(R5),LENGTH(R3)	;KEEP LARGEST
	BLOS 10$		;ALREADY HAVE IT
	MOV 2(R5),LENGTH(R3)	;GET NEW HIGH

1$:	INSERT			;AND STICK IT IN
	BR 10$			;CREF IT AND EXIT

2$:	MOV (R5)+,FLAGS(R3)	;CONCATINATE SECTION, COPY FLAGS
	ADD (R5),LENGTH(R3)
	APPEND SECROL		;PUT SECTION NAME AT END OF ROLL
	MOVB ROLSIZ+SECROL+1,CURSEC	;KEEP TRACK OF CURRENT SECTION NUMBER

10$:	CMP (R3),#^R. A		;. ABS. ?
	BNE 15$			;NOPE
	CMP 2(R3),#^RBS.
	BNE 15$			;NOPE
	TST PS.0		;SIZE = 0?
	BEQ GSDNXT		;YEP, SKIP SECTION
15$:	CALL CRFSEC		;CREF THE SECTION
	BR GSDNXT

20$:	CLR LENGTH(R3)		;ZAP LENGTH IN CASE OF APPEND
	TST (R3)		;UNNAMED CSECT?
	BEQ 2$			;YEP. APPEND IT
	CMP (R3),#^R. B		;UNAMED BSECT?
	BNE 25$			;NOPE
	TST 2(R3)
	BEQ 2$			;YEP, JUST APPEND
25$:	MOV (SP),R5		;RESET R5

30$:	NEXT SECROL		;GET THE NEXT SECTION DEFINITION
	BEQ 40$			;END
	CMP (R3),(R5)		;SAME NAME?
	BNE 40$			;NOPE
	CMP 2(R3),2(R5)
	BEQ 20$			;YEP. GO TO NEXT ONE

40$:	MOV ROLENT,CURSEC	;KEEP CURRENT SECTION #
	CALL FIXSEC		;GO FIX REFERENCES TO THIS SECTION #
	MOV (R5)+,(R3)+		;PASS SYMBOL
	MOV (R5)+,(R3)+
	MOV (R5)+,(R3)+		;+ FLAGS
	CLR (R3)+		;+ OFFSET
	MOV (R5),(R3)		;+ LENGTH
	CLR ROLUPD		;SAY SEARCH FAIL
	BR 1$			;STICK IT IN THE ROLL, CREF, EXIT
	.DSABL LSB

CRFSEC::MOV #SYMBOL,R0		;POINT TO SYMBOL AREA
	MOV CURSEC,(R0)+	;PASS CURRENT SECTION NUMBER
	CLR (R0)+		;FILLER WORD FOR COMPATIBILITY
	CLRB (R0)+		;NO FLAGS
	MOVB CHAN,(R0)		;AND CURRENT CHANNEL
	APPEND SCRROL		;STICK IT AT THE END OF THE CREF ROLL
	RETURN

	ENTSEC MSGS
CNFATT:	.ASCII \?LINKM-W-CNFATT, Conflicting section attributes. PSECT=\
CNFSEC:	.BLKB 40.
	XITSEC

BADATT:	SAVREG			;SAVE ALL THE REGS
	MOV R3,R1		;POINT TO SECTION NAME IN ERROR
	MOV #CNFSEC,R2		;POINT TO MESSAGE SPACE
	CALL SYMTOA		;UNPACK SYMBOL NAME
10$:	CMPB -(R2),#SPACE	;BACKUP OVER SPACES
	BEQ 10$
	INC R2			;SKIP TO NEXT CHAR
	MOVB #^O73,(R2)+	;FOLLOW WITH A ;
	MOVB #SPACE,(R2)+	;AND A SPACE
	MOV #M.FILE,R1		;POINT TO "FILE=" MESSAGE
	CALL MOVBYT		;COPY IT IN
	MOV #FILEN,R0		;POINT TO CURRENT FILE NAME
	CALL CVFN		;PUT IT IN TOO
	MOV SP,TTKEY		;SAY THIS LINE GOES TO TT: TOO
	PRINT #CNFATT		;DISPLAY IT
	RET			;DONE
	.PAGE
BADOBJ:	MSGF <Bad GSD entry type. >,128
	TFILE

GSDTIM:	MOV #TIMROL,R0		;TIME/DATE
	BR IDNMOD

GSDMOD:	MOV #MODROL,R0
	BR IDNMOD

GSDIDN:	MOV #IDNROL,R0
IDNMOD:	MOV CHAN,(R3)+		;RECORD CHANNEL NUMBER
	MOV (R5)+,(R3)+		;COPY NAME/TIME
	MOV (R5)+,(R3)+
	MOV 2(R5),(R3)+		;DATE IF TIMROL ELSE DON'T CARE
	CALL APPEND		;STICK STUFF IN ROLL
	JMP GSDNXT		;CONTINUE



FIXSEC:	MOV ROLBAS+SCRROL,R0	;POINT TO CREF ROLL
41$:	CMP R0,ROLTOP+SCRROL	;AT THE END?
	BHIS 43$		;NOPE
	CMP (R0),CURSEC		;IS ENTRY POINTING TO CURRENT SECTION?
	BLO 42$			;NOPE
	INC (R0)		;YEP, BUMP IT
42$:	ADD #RS.SCR*2,R0	;SKIP TO NEXT ENTRY
	BR 41$

43$:	MOV ROLBAS+SYMROL,R0	;POINT TO SYMBOL ROLL
44$:	CMP R0,ROLTOP+SYMROL
	BHIS 46$		;CONTINUE
	CMPB 5(R0),CURSEC	;SYMBOL POINTING TO THIS SECROL?
	BLO 45$			;NOPE
	INCB 5(R0)
45$:	ADD #RS.SYM*2,R0	;SKIP TO NEXT ENTRY
	BR 44$

46$:	RETURN
	.PAGE
	.SBTTL GLOBAL HANDLER
; THE FOLLOWING DEFINITIONS APPLY TO THE SYMROL
FLAGS	=4
SECT	=5
VALUE	=6

GLOBAL:	MOV (R5)+,(R3)+		;PASS SYMBOL
	MOV (R5)+,(R3)+
	BIC #S.MDF,(R5)		;CAN'T HAVE MDF ON INPUT
	SEARCH SYMROL		;LOOK FOR SYMBOL
	BEQ 25$			;DIDN'T FIND IT
	BIT #S.DEF,(R5)		;DEFINITION COMING UP?
	BEQ 40$			;NOPE. JUST A REFERENCE
	BIT #S.DEF,(R3)		;ALREADY DEFINED?
	BEQ 30$			;NOPE.
	MOV 2(R3),R2		;SAVE CURRENT VALUE FOR LATER TEST
	CMP FILEN+6,#^RSYM	;IS THIS A .SYM FILE?
	BEQ 40$			;YEP, NEVER MIND ABOUT IT THEN
	TST XMDF		;SUPPOSED TO IGNORE MDF'S?
	BNE 15$			;YEP
	SEARCH MLDROL		;LOOK FOR SYMBOL IN MLD ROLL
	CALL FILBIT		;INSTALL FILE # BIT
	BISB #S.MDF,(R5)	;SIGNAL MULTIPLE DEFINITIONS
15$:	BIT #S.REL,(R5)		;RELOCATABLE SYMBOL?
	BNE 20$			;YES, ERROR
	CMP R2,2(R5)		;VALUES MATCH?
	BEQ 22$			;YEP. OK THEN
20$:	BISB #S.MDF,(R3)	;ELSE SIGNAL THAT THIS IS REALLY A M.D.
	INC MDFCNT		;COUNT THAT THERE WERE MDF'S
22$:	TST XMDF		;SUPPOSED TO IGNORE MDF'S?
	BEQ 35$			;NOPE, INSERT AND CREF IT
	BR 40$			;YEP, JUST CREF IT

25$:	BITB #S.DEF,(R5)	;DEFINITION FOLLOWING?
	BEQ 35$			;NOPE, JUST INSERT AND CREF IT

30$:	BISB (R5),(R3)+		;PASS FLAGS
	MOVB CURSEC,(R3)+	;PASS RELATIVE SECTION #
	MOV 2(R5),(R3)		;PASS VALUE
35$:	INSERT			;STUFF IT IN ROLL, FALL THRU TO CREF IT

40$:	CALL CRFSYM		;CREF THE SYMBOL
	JMP GSDNXT

	.ENABL LSB
CRFSYM::
	TST XCRF		;XREF'S ALLOWED?
	BNE 5$			;NOPE, TAKE THE EASY WAY OUT
	CMP SP,STGARD		;AT THE GUARD BAND YET?
	BHIS 10$		;NOPE, OK THEN
	INC STWARN		;SIGNAL STACK ABOUT TO UNDERFLOW
	MSGW <2MNYSYM, Too many symbols to cross reference>
	CALL PURXRF		;ZAP THE XREF ROLL
5$:	RET

10$:	TST STWARN		;OVERFLOW'D YET?
	BNE 5$			;YEP, DON'T XREF THEN
	MOV CNTQAL,R0		;ANY QUALIFIERS?
	BEQ 40$			;NOPE
20$:	SUB #2,R0		;BACKUP 1 SLOT
	BMI 5$			;RAN OFF THE END, DON'T XREF
	MOV CRFQAL(R0),R1	;GET THE QUALIFIER
	CMP SYMBOL,R1		;MATCH?
	BLO 20$			;NOPE, DON'T BOTHER WITH IT
	ADD #^O50*^O50,R1	;UP IT BY 1 RAD50 CHARACTER
	CMP SYMBOL,R1		;MATCH?
	BHIS 20$		;NOPE

40$:	SEARCH CRFROL		;LOOK FOR CREF'D SYMBOL
	BISB (R5),SYMBOL+FLAGS	;PASS DEFINED/MULTIPLE-DEFINED FLAGS
	BIT #S.DEF,(R5)		;ARE WE DEFINING HERE?
	BEQ 50$			;NOPE, LEAVE THE FILE NUMBER ALONE
	BIT #S.MDF,(R5)		;HAS IT PREVIOUSLY BEEN DEFINED?
	BNE 50$			;YEP, LET THE FIRST ONE STAND
	MOVB CHAN,SYMBOL+SECT	;PASS FILE NUMBER
50$:	CALL FILBIT		;INSERT FILE # BIT
	INSERT			;STICK IN THE REFERENCE
	RETURN
	.DSABL LSB
	.PAGE
	.SBTTL RELOCT -Resolve values of globals
	.ENABL LSB

; The following definitions apply to secrol:

FLAGS	=4		;Offsets from SYMBOL
SECT	=5
OFFSET	=6
LENGTH	=8

RELOCT:
.IIF NE,DEB$,MSG <Locate sections and relocate symbols>
	PRINT #SSMRY,#$SSMR,#$SSMR-2	;SECTION SUMMARY
	MOV ROLBAS+SECROL,R5	;POINT TO START OF SECTION ROLL
	MOV LENGTH(R5),R5	;GET SIZE OF .ASECT
	CLR R4			;BSECT'S START AT LOC 0
	CLR ROLUPD		;Start at begining
	CLR ROLENT		;MUST BE 0 FOR CREF TO WORK
	MOV #SYMBOL,R3		;MAKE SURE R3 IS SET UP

10$:	NEXT SECROL		;Get next PSECT
	BNE 15$			;got one
	JMP 130$
15$:	BIT #S.FORC,FLAGS(R3)	;forced to a location?
	BNE 20$			;yep, treat it as though its a ABS section
	BIT #S.REL,FLAGS(R3)	;Relocatable section?
	BNE 70$			;Yes, continue
20$:	MOV #TMPSYM+2,R2	;point to temp space
	CMP 2(R3),(R2)+		;same as last time?
	BNE 30$			;nope
	CMP (R3),-4(R2)		;same?
	BEQ 40$			;yep
30$:	CLR (R2)		;zap the old offset
	BIT #S.FORC,FLAGS(R3)	;forced to a place in mem?
	BEQ 40$			;nope, start at 0 then
	MOV OFFSET(R3),(R2)	;yep, start at the position indicated
	BR 60$			;and accumulate from there
40$:	TST SWO			;/O MODE?
	BEQ 50$			;nope
	BIT #S.DATA,FLAGS(R3)	;data section?
	BNE 50$			;yep
	INC (R2)		;instruction, force it to word boundary
	BIC #1,(R2)
50$:	ADD (R2),OFFSET(R3)	;Position section
60$:	ADD LENGTH(R3),(R2)	;update top address in temp space
	ADC OOV			;+ any overflow
	CMP (R2),HILIMIT	;max out section size
	BLOS 65$		;already got it
	MOV (R2),HILIMIT
65$:	BIT #S.FORC+S.REL,FLAGS(R3) ;forced or relocatable section?
	BEQ 110$		;nope, proceed normally
	TST SWO			;/O mode?
	BNE 68$			;yep, can't have bsect's
	BIT #S.BSE,FLAGS(R3)	;base section?
	BEQ 68$			;nope
	CMP (R2),R4		;else force up the base position
	BLOS 110$
	MOV (R2),R4
	BR 110$

68$:	CMP (R2),R5		;else force up the relocatable position
	BLOS 110$		;already set to a higher value
	MOV (R2),R5		;bump it
	BR 110$

70$:	TST SWO			;/O mode?
	BNE 80$			;yep, can't have bsects
	BIT #S.BSE,FLAGS(R3)	;.BSECT?
	BEQ 80$			;NOPE
	ADD R4,OFFSET(R3)	;position section in memory
	ADD LENGTH(R3),R4	;update load address
	BR 100$			;continue

80$:	TST SWO			;/O mode?
	BEQ 90$			;nope
	BIT #S.DATA,FLAGS(R3)	;data section?
	BNE 90$			;yep
	INC R5			;instruction, force it to word boundary
	BIC #1,R5
90$:	ADD R5,OFFSET(R3)	;Place section in real memory
	ADD LENGTH(R3),R5	;Update top address
100$:	ADC OOV			;keep any overflow
110$:	INSERT			;Update section roll
	MOV R3,R1		;SOURCE
	MOV #TMPSYM,R2		;DEST
	CALL XMIT2		;make a copy of the old SYMBOL
	TST (R3)		;unnamed CSECT/BSECT/PSECT?
	BNE 120$		;nope, print it anyway
	TST LENGTH(R3)		;size=0?
	BEQ 10$			;yep, don't print it
120$:	TST MAP			;output?
	BEQ 10$			;nope, skip the rest of this stuff
	MOV #LB,R2		;point to line buffer
	MOV R3,R1		;point to symbol
	CALL SYMTOA		;unpack symbol
	MOV OFFSET(R1),R0	;get load point
	CALL OUTNUM		;print it
	DEC R2			;back up 1 space
	MOV LENGTH(R1),R0	;get size
	CALL OUTNUM		;Print it
	DEC R2			;back up 1 space
	CALL ATTRIB		;Display section attributes
	MOV ROLENT,(R1)+	;set name
	CLR (R1)
	CALL REFRSS		;do cref on section
	JMP 10$			;continue
	.PAGE
130$:	MOV OOV,TTKEY		;signal any overflow errors to TT: too
	BEQ 150$			;ok
	TST R5			;right on boundary?
	BEQ 140$			;yes, no message required
	PRINT #OOV65K		;WARNING, OUTPUT OVERFLOWED 65K
140$:	MOV #-1,R5		;force top address = FFFF
150$:	CMP R4,R5		;check for bsect bigger than other
	BLOS 160$			;ok
	MOV R4,R5		;else use the bsect size
160$:	CMP R5,HILIMIT		;max out limit
	BLOS 170$
	MOV R5,HILIMIT		;Keep top address
170$:	CLR ROLUPD		;Start search at begining again

; The symbol OFFSET is replaced with the symbol VALUE for the following code

VALUE	=6

180$:	NEXT SYMROL		;Get symbol
	BEQ 190$		;At the end
	MOVB SECT(R3),R0	;Get section # of definition
	BEQ 180$		;Undefined, ignore relocation
	DEC R0			;Make it relative to 0
	IMULI RS.SEC*2,R0	; * size of section roll in bytes
	ADD ROLBAS+SECROL,R0	;Compute address of entry of definition
	ADD OFFSET(R0),VALUE(R3)	;Compute absolute value of symbol
	INSERT			;Update symbol roll
	BR 180$			;Continue

190$:	CALL P2GSS		;Global symbol summary to load map
	CALL P2UDF		;Undefined symbol summary to load map/TT:
	CALL P2MDF		;Multiple definition output to load map/TT:
	RET			;exit pass 2
	.DSABL LSB

	ENTSEC IMPURE
OOV:	.BLKW
	XITSEC

	ENTSEC MSGS
OOV65K:	.ASCIZ \?LINKM-W-Output overflowed 65K bytes.\
	XITSEC

	.SBTTL PURXRF Purge all X-ref rolls
; PURXRF Purges all the rolls defined before SYMROL
;   namely the X-ref rolls which can be discarded after relocation
;    is complete.

PURXRF:	SAVREG			;MAKE SURE NOT TO ZAP THE REGS
	MOV ROLBAS+SYMROL,R5	;POINT TO BOTTOM OF SYMBOL ROLL
	MOV ROLBAS,R4		;POINT TO BOTTOM OF ALL ROLLS
	CLR R0			;START INDEX AT 0
10$:	CMP R0,#SYMROL		;AT THE LIMIT?
	BHIS 20$		;YEP, DONE THEN
	MOV R5,ROLBAS(R0)	;INIT THE ADDRESSES
	MOV R5,ROLTOP(R0)	; WHICH EFFECTIVELY ZAPS THE ROLLS
	CLRB ROLSIZ+1(R0)
	ADD #2,R0		;UP TO NEXT ENTRY
	BR 10$

20$:	MOV R4,R0
	SUB SP,R0		;COMPUTE # OF BYTES TO MOVE
	BEQ 50$			;NUTHIN' TO MOVE
	MOV R5,R1		;START OF SYMROL
	SUB R0,R1		;-SIZE TO MOVE = DESTINATION @
	CLC
	ROR R0			;WORDS TO MOVE
	MOV R1,R2		;VALUE TO SET STACK WHEN DONE (DESTINATION)
	MOV SP,R3		;GET CURRENT STACK POINTER (SOURCE)
30$:	MOV (R3)+,(R1)+		;COPY STACK UP
	SOB R0,30$
	MOV R2,SP		;MOVE THE STACK
50$:	RET			;DONE
	.PAGE
ATTRIB:	MOV R1,-(SP)		;SAVE R1
	CLR R0
	BITB #S.REL,SYMBOL+FLAGS ;TRUE?
	BNE 10$			;YES
	TST (R0)+
10$:	MOV PM.REL(R0),R1	;POINT TO REL,
	CALL MOVBYT		;PASS TEXT
	CLR R0
	BITB #S.OVR,SYMBOL+FLAGS ;TRUE?
	BNE 15$			;YEP
	TST (R0)+
15$:	MOV PM.OVR(R0),R1	;POINT TO OVR,
	CALL MOVBYT		;PASS TEXT
	CLR R0
	TST SWO			;/O?
	BEQ 18$			;NOPE
	CMP (R0)+,(R0)+		;BUMP UP
	BITB #S.DATA,SYMBOL+FLAGS
	BR 19$
18$:	BITB #S.BSE,SYMBOL+FLAGS
19$:	BNE 20$			;BASE
	TST (R0)+
20$:	MOV PM.BSE(R0),R1	;POINT TO BSE,
	CALL MOVBYT		;PASS TEXT
	MOV (SP)+,R1
	RET

	.ENABL LSB
	ENTSEC MSGS
30$:	.ASCIZ \REL\
40$:	.ASCIZ \ABS\
	XITSEC

PM.REL:	.WORD 30$,40$

	ENTSEC MSGS
50$:	.ASCIZ \,OVR\
60$:	.ASCIZ \,CON\
	XITSEC

PM.OVR:	.WORD 50$,60$

	ENTSEC MSGS
70$:	.ASCIZ \,BSE  \
80$:	.ASCIZ \      \
90$:	.ASCIZ \,DAT  \
95$:	.ASCIZ \,INS  \
	XITSEC

PM.BSE:	.WORD 70$,80$,90$,95$
	.DSABL LSB
	.PAGE
	.SBTTL INTMAP - Initialise for load map output
	.ENABL LSB

INMAP:	.GTIM #WA,#LTIME	;Get time of day
	.DATE			;Get current date
	MOV R0,LDATE
	MOV #MAP,R1		;Point to map file spec
	TST (R1)		;Map file requested?
	BNE 6$			;Yes, continue
	RET			;Else just exit

6$:	.FETCH BOTTOM,R1	;GET OUTPUT DEVICE
	BCC 4$			;OK

ILLDVC:	MSGF <Illegal device. >,128
	BR 5$			;ERROR EXIT

4$:	MOV R0,BOTTOM		;UPDATE FREE SPACE POINTER
	ADD #128,R0		;MOVE THE LOWERLIMIT
	MOV R0,STLLIM
	ADD #128,R0
	MOV R0,STGARD
	.CLOSE #1		;CLAIM CHANNEL 1
	.ENTER #WA,#1,R1,8(R1)	;Open output channel 1 for map file
	BCC 1$

OFTO:	MSGF <output file failed to open. >,128
5$:	TFILE R1

1$:	MOV #MBUF,MBP		;SET OUTPUT POINTER
	CMP (R1),#^RTT 		;MAP OUTPUT TT:?
	BNE 3$			;NOPE
	MOV SP,TTMAP		;SIGNAL YES
3$:	MOV #TTIME,R2		;Point to title time area
	MOV #LTIME,R0		;POINT TO 2 WORD TIME CODE
	CALL UNPTIM		;Convert time to ASCII
	MOV #TDATE,R2
	MOV LDATE,R0
	CALL UNPDAT		;Convert date to ASCII
	MOV #OUT,R0
	CALL CVFNLB		;Convert output file name to ASCII
	MOV #57,LINCNT		;60 lines per page (-3 for title lines)
	MOV #LB,R1
	MOV #TIFN,R2		;Point to title region
	CALL MOVBYT		;Put filename into title region
2$:	MOVB #' ,(R2)+		;Blank fill
	CMP R2,#TIFN+14
	BLO 2$
	MOV CSEND,R0		;POINT TO END OF C.S.
	CLRB -2(R0)		;ZAP THE LAST CR,LF'S
	PRINT #CSBUFF,CSLCNT,CSLCNT	;Print command string
	RET			;DONE WITH THIS PHASE
	.DSABL LSB

	ENTSEC IMPURE
LINCNT:	.BLKW 2
HILIMI:	.BLKW
	XITSEC
	.PAGE
SUMFIL:	TST MAP			;ANY MAP?
	BNE 5$			;YEP
	RET			;ELSE DONE WITH THIS TOO

5$:	PRINT #FNSMRY,#$FNSMR,#$FNSMR-2	;PRINT FILE NAME SUMMARY
	MOV #1,R4		;CHANNEL #
	CLR ROLUPD		;START AT BEGINING
	TST SCHAN		;.LNK FILE?
	BEQ 10$			;NOPE
	NEXT FILROL		;YEP. SKIP IT
10$:	MOV #LB,R2		;POINT TO LINE BUFFER
	NEXT FILROL		;GET FILE NAME
	BEQ 60$			;END
	MOV #SYMBOL,R0
	CALL CVFN		;PRINT FILE NAME
	MOV R0,R2		;UPDATE POINTER
20$:	MOVB #' ,(R2)+		;BLANK FILL
	CMP R2,#LB+16
	BLO 20$
	MOV ROLUPD,-(SP)	;SAVE POSITION
	TST SYMBOL+8		;OPTIONS?
	BEQ 30$			;NOPE
	MOV #OPTMSG,R1		;YEP, POINT TO OPTIONS MESSAGE
	CALL MOVBYT		;COPY IT TO LINE BUFFER
	BR 50$			;AND PRINT IT
	
30$:	MOV #SYMBOL,R1		;POINT TO SYMBOL SPACE
	MOV R4,(R1)+		;PASS CHANNEL #
	SCANW MODROL		;LOOK FOR MODULE NAME
	CALL SYMTOA		;UNPACK IT
	SCANW IDNROL		;LOOK FOR .IDENT
	CALL SYMTOA		;UNPACK IT
	CLRB (R2)		;  (IN CASE NO 'TIME' PRESENT.)
	SCANW TIMROL		;LOOK FOR TIME/DATE CODES
	BEQ 50$			;NO DATE/TIME/LANG OR OTHER FLAGS
	MOV 4(R1),R0		;GET DATE CODE
	CALL UNPDAT		;CONVERT TO ASCII
	MOV R0,R2		;UPDATE BUFFER POINTER
	MOVB #' ,(R2)+		;FOLLOW WITH 2 BALNKS
	MOVB #' ,(R2)+
	MOV R1,R0		;POINT TO 2 WORD TIME CODE
	CALL UNPTIM		;CONVERT TO ASCII
	CLRB (R0)		;TERMINATE LINE IN CASE NO LANG AND STUFF
	MOV R0,R2		;UPDATE POSITION
	SCANWC TIMROL		;CONTINUE LOOKING FOR STUFF
	BEQ 50$			;DIDN'T FIND ANY
	MOVB #' ,(R2)+		;FOLLOW WITH 2 BALNKS
	MOVB #' ,(R2)+
	CALL SYMTOA		;DISPLAY LANGUAGE PROCESSOR
	CLRB (R2)		;SET TERMINATOR IN CASE OF NO ERRORS
	MOV #SYMBOL+6,R5	;POINT TO ERROR/WARN COUNT WORD
	TSTB (R5)+		;ANY ERRORS?
	BEQ 40$			;NOPE
	MOV #ERRDET,R1		;ELSE COPY IN ERRORS DETECTED MESSAGE
	CALL MOVBYT
	CLR R1
	BISB -1(R5),R1		;GET ERROR COUNT
	MOV #1,DNCDIG		;ONLY 1 DIGIT REQUIRED
	CALL DNC		;DISPLAY IT IN DECIMAL
	CLRB (R2)		;TERMINATE
40$:	TSTB (R5)		;ANY WARNINGS?
	BEQ 50$			;NOPE
	MOV #WARDET,R1		;ELSE COPY IN WARNINGS DETECTED
	CALL MOVBYT
	CLR R1
	BISB (R5),R1
	CALL DNC		;DISPLAY THE NUMBER OF WARNINGS	IN DECIMAL
	CLRB (R2)		;TERMINATE
50$:	PRINT #LB		;PRINT THE LINE
	MOV (SP)+,ROLUPD	;RESTORE FILE NAME POSITION
	INC R4			;NEXT CHANNEL
	BR 10$			;CONTINUE

60$:	RET			;EXIT

	ENTSEC MSGS
OPTMSG: .ASCIZ \Options file\
ERRDET: .ASCIZ \  Errors detected: \
WARDET: .ASCIZ \  Warnings detected: \
	XITSEC
	.PAGE
	.SBTTL P2GSS - Global symbol summary to load map
P2GSS:	TST MAP			;Any map output?
	BNE 30$			;yep. continue
	RET			;just exit

30$:
	TST XCRF		;CROSS-REF DISABLED?
	BNE 20$			;YEP, DON'T DO IT THEN
	TST SWR			;CROSS-REFERENCE REQUESTED?
	BEQ 20$			;NO.
	TST STWARN		;ANY X-REF?
	BNE 20$			;NOPE, CAN'T DO A /R THEN
	PRINT #GSMRY,#$GSMR,#$GSMR-2	;GLOBAL SYMBOL SUMMARY
	MOV #SYMBOL,R1		;POINT TO SYMBOL AREA
	CLR ROLUPD		;START AT BEGINING

1$:	NEXT SYMROL		;GET SYMBOL
	BEQ 10$			;END
	BIT #S.DEF,FLAGS(R1)	;DEFINED?
	BEQ 1$			;NOPE. SKIP IT
	MOV #LB,R2		;POINT TO START OF BUFFER
	CALL SYMTOA		;PRINT SYMBOL
	MOV VALUE(R1),R0	;GET VALUE
	CALL OUTNUM		;DISPLAY IT
	CALL REFRNC		;DISPLAY REFERENCES
	BR 1$			;CONTINUE

20$:	MOV ROLTOP+SYMROL,R1
	SUB ROLBAS+SYMROL,R1	;COMPUTE SIZE OF ROLL
	BLOS 10$		;EMPTY
	CLR R0
	DIV #RS.SYM*2*8,R0	;COMPUTE TOTAL # OF LINES TO BE PRINTED
	TST R1			;ANY REMAINDER?
	BEQ 27$			;NOPE.
	INC R0			;ROUND UP TO NEXT LINE
27$:	MOV R0,-(SP)		;SAVE TOTAL LINE COUNT
	TST -(SP)		;PUT A HOLE ON STACK
	MOV ROLBAS+SYMROL,-(SP)	;POINT TO ROLL
	PRINT #GSYMS,#$GSMR,#$GSMR-2
	MOV LINCNT+2,R4		;GET LINES FREE ON PAGE

25$:	SUB R4,4(SP)		;TAKE FROM TOTAL
	BPL 21$			;OK
	ADD 4(SP),R4		;USE RESIDUAL LINE COUNT
21$:	MOV R4,R0
	MOV R0,2(SP)		;SAVE PAGE LINE COUNT
	IMULI RS.SYM*2,R4	;BYTES/COLUMN
	.PAGE
22$:	CLR R3			;ITEM COUNTER
	MOV #LB,R2		;BUFFER POINTER
	MOV #8,R5		;COLUMN COUNTER

23$:	MOV (SP),R1		;POINT TO ROLL
	ADD R3,R1		;POINT TO ENTRY
	CMP R1,ROLTOP+SYMROL	;OFF THE END?
	BHIS 24$		;YES. TERMINATE LINE
	CALL SYMTOA		;PRINT SYM
	DEC R2			;BACKUP 1 BYTE
	MOV VALUE(R1),R0
	CALL OUTNUM		;PRINT VALUE
	ADD R4,R3		;POINT TO NEXT COLUMN
	SOB R5,23$		;COUNT AND COUNTINUE

24$:	CLRB (R2)		;CLOSE LINE
	PRINT #LB		;PRINT LINE
	ADD #RS.SYM*2,(SP)	;NEXT LINE
	DEC 2(SP)		;COUNT DOWN
	BGT 22$
	TST 4(SP)		;ANY MORE?
	BLE 26$			;NO
	SUB R4,R3		;ADJUST POINTER
	ADD R3,(SP)		;UPDATE SYMROL POINTER
	MOV LINCNT,R4		;GET NEW COUNT
;	INC R4			;+1
	BR 25$			;CONTINUE

26$:	ADD #6,SP		;PURGE STACK

10$:	MOV #$LL,R1		;POINT TO LOW LIMIT MESSAGE
	MOV #LB,R2		;POINT TO BUFFER
	CALL MOVBYT		;PASS TEXT
	MOV VBOTT,R0		;GET LOW LIMIT
	CMP R0,#-1		;ANY CODE GENERATED?
	BNE 15$			;YES
	CLR R0			;NO, SAY LOW = 0
15$:	CALL OUTNUM
	MOV #$HL,R1		;POINT TO HIGH LIMIT MESSAGE
	CALL MOVBYT		;PASS TEXT
	MOV HILIMI,R0		;GET HIGH LIMIT
	CALL OUTNUM
	CLRB (R2)		;BE SURE TO STOP THE LIST
	PRINT #LB,#3,#3		;PRINT HIGH LIMIT
	RET

	ENTSEC MSGS
$HL:	.ASCIZ \High limit = \
$LL:	.ASCIZ <CR><LF>\Low limit = \
	XITSEC

	.PAGE
REFRSS:	SAVREG
	MOV ROLUPD,-(SP)	;SAVE ROLL POINTER
	MOV ROLENT,-(SP)
	MOV R2,CRF.LIN		;SAVE STARTING BUFFER ADDRESS
	MOV #12,R3		;SET THE NUMBER OF NAMES/LINE
	MOV R3,CRF.IPL		;RECORD ITEMS/LINE COUNT
	CLR R5			;TOTAL COUNTER IN CASE NO REFERENCES
	CLR ROLUPD		;START AT TOP

20$:	SCANC SCRROL		;CONTINUE SCANNING SCRROL
	BEQ 60$			;EMPTY
	MOVB SYMBOL+SECT,R1	;GET CHANNEL NUMBER
	CALL GETFSP		;GET FILE SPECS
	BHIS 20$		;ILLEGAL. IGNORE IT
	ADD #2,R1		; + 2 TO SKIP OVER DEVICE NAME
	CALL SYMTOA		;DISPLAY FILE NAME
	SOB R3,20$		;COUNT AND CONTINUE
	CLRB -2(R2)		;ZAP THE 2 SPACES THAT FOLLOW THE SYMBOL
	CALL PRTCRF		;PRINT CREF LINE
	BR 20$			;CONTINUE

60$:	CLRB (R2)		;TERMINATE IN CASE OF ERROR
	TST R5			;ANYTHING PRINTED?
	BEQ 70$			;NOPE, PRINT LINE ANYWAY
	CMP R3,CRF.IPL		;ANYTHING ON THE LINE?
	BEQ 80$			;NEVER MIND
70$:	MOV CRF.TT,TTKEY	;SET TO PRINT TO TT: IF NECESSARY
	PRINT #LB		;DISPLAY IT

80$:	MOV (SP)+,ROLENT	;RESTORE ROLL CONTROLS
	MOV (SP)+,ROLUPD
	RET

	ENTSEC IMPURE
CRF.TTK: .BLKW			;ENABLE TTY OUTPUT
CRF.LIN: .BLKW			;LINE BUFFER START
CRF.IPL: .BLKW			;ITEMS/LINE REG
	XITSEC
	.PAGE
FLAGS	= 4
SECT	= 5
FILMAP	= 6
.IIF NE,DEB$,.ENABL LSB
REFRNC:	SAVREG
	MOV ROLUPD,-(SP)	;SAVE ROLL POINTER
	MOV ROLENT,-(SP)
	MOV #14,R3		;14 ITEMS PER LINE
	MOV R3,CRF.IPL
	MOV R2,CRF.LIN		;SAVE STARTING BUFFER ADDRESS
	CLR R5			;TOTAL COUNTER IN CASE NO REFERENCES
	SEARCH CRFROL		;LOOK IN CRFROL FOR X-REFERENCES
.IF NE,DEB$
	BNE 1$			;FOUND ONE
	MSG <Empty X-ref ROL>
	BR 60$			;EXIT
1$:
.IFF
	BEQ 60$			;THERE AREN'T ANY.
.ENDC
	MOV #TMPSYM,R2
	MOV #SYMBOL,R1
	CALL XMIT0-<RS.CRF*2>	;COPY SYMBOL NAME AND REF BITS INTO TEMPSYM
	SEARCH MLDROL		;LOOK IN MULTIPLE DEFINITION ROLL TOO
	MOV CRF.LIN,R2		;RESTORE R2
	MOVB TMPSYM+SECT,R1	;GET CHANNEL # THAT DEFINED SYMBOL
	BEQ 10$			;ITS UNDEFINED, DON'T MESS WITH IT
	CALL GFILBIT		;GET FILE BIT
	BISB R1,SYMBOL+FILMAP(R0) ;INSERT THE "DEFINED HERE" BIT

10$:	CLR R4			;MAP INDEX
30$:	TST TMPSYM+FILMAP(R4)	;ANY REFERENCES IN THIS GROUP?
	BEQ 50$			;NOPE, SKIP UP TO NEXT GROUP
	MOV #1,R1		;FLYING BIT MAP
	CLR R0			;POSITION OF BIT
40$:	BIT R1,TMPSYM+FILMAP(R4)	;REFERENCED IN THIS FILE?
	BEQ 45$			;NOPE
	BIT R1,SYMBOL+FILMAP(R4)	;DEFINED IN THIS FILE?
	BEQ 42$			;NOPE
	SEC			;ELSE SIGNAL SAME TO DISREF
42$:	CALL DISREF		;YEP, DISPLAY FILENAME
45$:	INC R0			;BUMP POSITION #
	ASL R1			;MOVE BIT
	BCC 40$			;KEEP LOOKING
50$:	TST (R4)+		;BUMP THE INDEX
	CMP R4,#10		;OVERFLOW?
	BLT 30$			;NOPE, KEEP LOOKING

60$:	CLRB (R2)		;TERMINATE IN CASE OF ERROR
	TST R5			;ANYTHING PRINTED?
	BEQ 70$			;NOPE, PRINT LINE ANYWAY
	CMP R3,CRF.IPL		;ANYTHING ON THE LINE?
	BEQ 80$			;NEVER MIND
70$:	MOV CRF.TT,TTKEY	;SET TO PRINT TO TT: IF NECESSARY
	PRINT #LB		;DISPLAY IT

80$:	MOV (SP)+,ROLENT	;RESTORE ROLL CONTROLS
	MOV (SP)+,ROLUPD
	RET
.IIF NE,DEB$,.DSABL LSB
DISREF:	MOV R0,-(SP)		;SAVE SOME REGS
	MOV R1,-(SP)
	MOV R4,-(SP)
	ROR -(SP)		;SAVE DEFINED FLAG
	ASL R4			;COMPUTE CHANNEL #
	ASL R4
	ASL R4
	ADD R0,R4		
	MOV R4,R1
	INC R1
	CALL GETFSP		;GET FILE SPECS
	BHIS 50$		;ILLEGAL, IGNORE IT
	ADD #2,R1		;+2 TO SKIP OVER FILE NAME
	CALL SYMTOA		;DISPLAY FILE NAME
	TST (SP)		;DEFINED HERE?
	BPL 10$			;NOPE
	MOV R2,R0		;POINT TO CURRENT POSITION
5$:	CMPB -(R0),#' 		;BACK UP TO FIRST NON-BLANK
	BEQ 5$
	MOVB #'#,1(R0)		;MARK SYMBOL AS DEFINED
10$:	DEC R3
	BGT 50$			;OK
	CLRB -2(R2)		;ZAP THE 2 SPACES THAT FOLLOW THE SYMBOL
	CALL PRTCRF		;PRINT CREF LINE
50$:	TST (SP)+		;PURGE DEFINED FLAG
	MOV (SP)+,R4		;RESTORE REGS
	MOV (SP)+,R1
	MOV (SP)+,R0
	RET

PRTCRF:	MOV #LB,R2		;POINT TO LINE BUFFER
	MOV CRF.TT,TTKEY	;SET TO PRINT TO TT: IF NECESSARY
	PRINT R2		;PRINT IT
	INC R5			;COUNT LINE
	MOV CRF.LIN,R0		;STARTING POINT
	SUB R2,R0		;COMPUTE SIZE OF FILL AREA
50$:	MOVB #' ,(R2)+		;CLEAR IT
	SOB R0,50$
	MOV CRF.IPL,R3		;RESET R3
	RET

FILBIT:	MOVB CHAN,R1		;START WITH CURRENT CHANNEL #
	CALL GFILBIT		;GET THE BITS
	BISB R1,SYMBOL+FILMAP(R0)	;INSERT BIT INTO ARRAY
	RET

GFILBIT:DEC R1			;MAKE CHAN # RELATIVE TO 0
	MOV R1,R0		;NEED 2 COPIES
	ASR R1			;GET A BYTE INDEX
	ASR R1
	ASR R1
	BIC #-8,R0		;ISOLATE BIT NUMBER
	INC R0			;+1 SO SOB WORKS
	MOV R1,-(SP)		;SAVE THE BYTE INDEX
	CMP R1,#10		;C=1 IF (SP) =0-9 ELSE C=0
	BIC R1,R1		;ZAP R1 WITHOUT MESSING THE CARRY
5$:	ROL R1			;PUT THE BIT IN THE BYTE
	SOB R0,5$
	BISB (SP)+,R0		;RETURN WITH BIT IN R1 AND INDEX IN R0
	RET
	.PAGE
P2UDF:	CLR ROLUPD		;FIND UNDEFINED GLOBALS
	CLR R5			;ITEM COUNTER
	MOV SP,CRF.TTK		;SIGNAL ALL OUTPUT GOES TO TT: TOO
	MOV #SYMBOL,R1
1$:	NEXT SYMROL		;GET SYMBOL
	BEQ 10$			;END
	BIT #S.DEF,FLAGS(R1)	;DEFINED?
	BNE 1$			;YEP. SKIP IT
	TST R5			;FIRST TIME THRU?
	BNE 2$			;NOPE
	MOV SP,TTKEY		;SIGNAL TO TYPE TOO
	PRINT #UDFGLB,#$UDF,#$UDF-2	;PRINT UNDEF GLOBL MESSAGE
	INCB LERRS		;COUNT ERRORS
2$:	INC R5			;COUNT IT
	TST XUDF		;SUPPOSED TO IGNORE UDF MSGS?
	BNE 10$			;YEP, JUST LOOK THROUGH THE TABLE
	MOV #LB,R2		;POINT TO BUFFER
	CALL SYMTOA		;PRINT SYMBOL
	MOVB #' ,(R2)+		;SEPERATE FIELDS
	MOVB #' ,(R2)+
	CLRB (R2)		;IN CASE OF ERRORS
	CALL REFRNC		;DISPLAY REFERENCES
	BR 1$			;CONTINUE

10$:	CLR CRF.TTK
	RET			;EXIT

SYMTOA:	MOV (R1),R0		;GET FIRST WORD
	CALL R50TOA		;CONVERT TO ASCII
	MOV R0,R2		;UPDATE POINTER
	MOV 2(R1),R0		;GET SECOND WORD
	CALL R50TOA		;CONVERT TO ASCII
	MOV R0,R2		;UPDATE POSITION
	MOVB #' ,(R2)+		;FOLLOW WITH 2 SPACES
	MOVB #' ,(R2)+
	CLRB (R2)		;TERMINATE IN CASE LAST THING ON LINE
	RET			;EXIT


	ENTSEC IMPURE
TTKEY:	.BLKW
TTMAP:	.BLKW
VBOTT:	.BLKW
VTOP:	.BLKW
CURLOC:	.BLKW
CURSEC:	.BLKW
	XITSEC

	.SBTTL P2MDF - Output multiple definition roll
P2MDF:	CLR ROLUPD		;FIND UNDEFINED GLOBALS
	CLR R5			;ITEM COUNTER
	MOV SP,CRF.TTK		;SIGNAL ALL OUTPUT GOES TO TT: TOO
	MOV #SYMBOL,R1
	TST MDFCNT		;ANY ERRORS?
	BEQ 10$			;NOPE
	TST XMDF		;SUPPOSED TO IGNORE MDF'S?
	BNE 3$			;YEP, SKIP RIGHT TO MESSAGE

1$:	NEXT MLDROL		;GET SYMBOL
	BEQ 10$			;END
	BIT #S.MDF,FLAGS(R1)	;REALLY MULTIPLY DEFINED?
	BEQ 1$			;NOPE, SKIP IT
	TST R5			;FIRST TIME THRU?
	BNE 2$			;NOPE
3$:	MOV SP,TTKEY		;SIGNAL TO TYPE TOO
	PRINT #MDFSYM,#$MDF,#$MDF-2	;PRINT/TYPE MULT DEF MESSAGE
	INCB LERRS
2$:	INC R5			;COUNT IT
	TST XMDF		;SUPPOSED TO IGNORE MDF'S?
	BNE 10$			;YEP, WE'RE DONE THEN
	MOV #LB,R2		;POINT TO BUFFER
	CALL SYMTOA		;PRINT SYMBOL
	MOVB #' ,(R2)+		;SEPERATE FIELDS
	MOVB #' ,(R2)+
	CLRB (R2)		;IN CASE OF ERRORS
	CALL REFRNC		;DISPLAY REFERENCES
	BR 1$			;CONTINUE

10$:	CLR CRF.TTK
	RET			;EXIT
	.PAGE
	.SBTTL SYMOUT- Output symbol table
SYMOUT:	MOV #SYM,R1
	TST (R1)		;SYMBOL OUTPUT
	BEQ 90$			;NO
	.FETCH BOTTOM,R1	;GET HANDLER
	BCC 10$
	JMP ILLDVC		;BAD
10$:	MOV R0,BOTTOM		;UPDATE POINTER
	ADD #128,R0
	MOV R0,STLLIM
	ADD #128,R0
	MOV R0,STGARD
	CLR OBLOCK		;MAKE SURE TO START AT BLOCK 0
	.CLOSE #2		;CLAIM A CHANNEL
	.ENTER #WA,#2,R1,8(R1)	;OPEN FILE
	BCC 20$
	JMP OFTO
20$:	MOV SWL,-(SP)		;SAVE LDA OUT FLAG
	MOV SP,SWL		;SIGNAL LDA OUTPUT
	MOV BOTTOM,OBP		;START AT LOW LIMIT
	MOV SP,R0		;GET TOP
	SUB #128,R0		;-STACK SPACE
	SUB OBP,R0		;-BOTTOM @
	BIC #511,R0		;ROUND TO BLOCK BOUNDARY
	MOV R0,OSIZE		;SAVE SIZE IN BYTES
	ADD OBP,R0		;+ BOTTOM @
	MOV R0,TOP		;= TOP LIMIT
	MOV #.ABS.,R1
	MOV #TBLA,R2
	MOV #.ABSIZ/2,R0
30$:	MOV (R1)+,(R2)+
	SOB R0,30$
	MOV #.ABSIZ,TBSIZ
	CALL FLTXT
	MOV ROLTOP+SYMROL,R5	;POINT TO TOP OF SYMBOL ROLL
	MOV ROLBAS+SYMROL,R4	;POINT TO BOTTOM OF SYMBOL ROLL
40$:	MOV #5,R3		;TRY FOR 5 SYMBOLS/BLOCK
	MOV #TB,R2		;POINT TO TEXT BUFFER
50$:	MOV R2,R0		;SAVE STARTING POINT
	MOV (R4)+,(R2)+		;PASS SYMBOL
	MOV (R4)+,(R2)+
	MOV (R4)+,(R2)+		;+ FLAGS
	MOVB #4,-1(R2)		;TYPE 4 = GLOBAL DEFINITION
	MOV (R4)+,(R2)+		;+ VALUE
	BICB #^CS.DEF,-4(R2)	;ZAP ALL BUT DEFINED FLAG
	BNE 60$			;BR IF DEFINED
	MOV R0,R2		;ELSE PUT THE POINTER BACK
	INC R3			;AND DON'T COUNT IT
60$:	CMP R4,R5		;AT THE LIMIT?
	BHIS 70$		;YEP, WE'RE DONE THEN
	SOB R3,50$
70$:	SUB #TB,R2		;ANYTHING THERE?
	BEQ 80$			;NOPE, EMPTY RECORD
	ADD #2,R2		;+2 FOR GSD TYPE
	MOV R2,TBSIZ
	CALL FLTXT
	CMP R4,R5		;ANY MORE?
	BLO 40$			;YEP
80$:	MOV #ENDGSD,TBLA
	MOV #2,TBSIZ
	CALL FLTXT		;ENDGSD
	MOV #ENDMOD,TBLA
	CALL FLTXT		;ENDMOD
	CALL FOUT		;FLUSH
	.CLOSE #2		;FINISH
	MOV (SP)+,SWL		;RESTORE
90$:	RET

	ENTSEC PURE
.ABS.:	.WORD GSD		;GSD TYPE RECORD
LTIME:	.BLKW 2			;TIME
	.WORD 2*256		;ISD TYPE
LDATE:	.BLKW			;DATE
	.RAD50  \LINKM \	;PROGRAM NAME
	.WORD 2*256		;2ND ISD IS PROGRAM NAME
LERRS:	.BLKB			;.NE. IF ERRORS
LWRNS:	.BLKB			;.NE. IF WARNINGS
	.RAD50	\. ABS.\	;. ABS. SECTION
	.BYTE S.M68!S.OVR!S.DEF	;ABS/OVRLAYED AND EXTRA STUFF SO IT MATCHES
	.BYTE 5			;PSECT
	.WORD 0			;LENGTH
.ABSIZ = .-.ABS.
	XITSEC
	.PAGE
	.SBTTL GETTOP CHECK FOR .VCTRS/.FILL DIRECTIVES

FILL	=^O20			;RLD FOR .FILL

GETTOP:
2$:	CMP (R5)+,#TXT		;TXT RECORD?
	BNE 4$			;NOPE. TRY FOR RLD
	TST CURSEC		;.ABS. SECTION?
	BNE 1$			;NOPE. NEVER MIND
	CMP (R5),VBOTT		;LOOK FOR BOTTOM ADDRESS
	BHIS 3$
	MOV (R5),VBOTT
3$:	SUB #4,R0		;TEXT COUNT = RECORD COUNT -2 (TYPE) -2 (L.A.)
	ADD (R5),R0		;COMPUTE TOP ADDRESS
	BCC 8$
	MOV #-1,R0
8$:	CMP R0,VTOP		;AT LIMIT?
	BLOS 1$			;NOPE, CONTINUE
	MOV R0,VTOP		;RECORD NEW LIMIT
1$:	RET

4$:	CMP -2(R5),#RLD		;RLD RECORD?
	BNE 1$			;NOPE

5$:	BIC #-32,(R5)		;ZAP UNUSED BITS
	CMP (R5),#FILL		;.FILL CHAR?
	BNE 9$			;NOPE
	MOV 2(R5),FILLC		;PASS IT
	BR 1$			;CONTINUE

9$:	CMP (R5),#7		;.LCD?
	BNE 1$			;NOPE, NEVER MIND
	MOV (R5)+,CURSEC	;PASS SECTION CODE
	CMP (R5)+,#^R. A	;. ABS.?
	BNE 1$			;NOPE
	CMP (R5)+,#^RBS.
	BNE 1$			;NOPE
	CLR CURSEC		;SIGNAL .ABS. SECTION
	BR 1$			;TEST AND CONTINUE

	.SBTTL	CREBIN OUTPUT CREATION

	ENTSEC IMPURE
FILLC:	.BLKW			;FILL CHARACTER
OSIZE:	.BLKW			;OUTPUT BUFFER SIZE
OPOS:	.BLKW			;RELATIVE C OF BUFFER
TOP:	.BLKW
OBLKS:	.BLKW
	XITSEC
	.ENABL LSB
CREBIN:
.IIF NE,DEB$,MSG <Create binary output>
	CMP VTOP,HILIMI		;.VCTRS/.CKSUM USED?
	BHIS 1$			;YEP
	MOV HILIMI,VTOP		;UPDATE HIGH LIMIT.

1$:	MOV #OUT,R1
	TST (R1)		;OUTPUT WANTED?
	BNE 2$			;YEP
	RET			;NOPE

2$:	.FETCH BOTTOM,R1	;GET DVC
	BCC 3$			;OK
	JMP ILLDVC

3$:	MOV R0,BOTTOM		;UPDATE LO LIMIT
	MOV R0,OBP		;POINT TO BUFFER
	.CLOSE #2		;CLAIM CHANNEL
	CLR R2
	TST SWL			;.LDA?
	BNE 5$			;YEP. GET 1/2 LARGEST EMPTY SPACE
	MOV VTOP,R2		;GET TOP ADDRESS
	INC R2			;WORD BOUNDARY
	ROR R2			;IN WORDS
	ADD #255,R2		;ROUND TO BLOCK BOUNDARY
	CLRB R2
	SWAB R2
5$:	.ENTER #WA,#2,R1,R2	;OPEN FILE
	BCC 4$			;OK
	JMP OFTO		;OUTPUT FAILED TO OPEN

4$:	MOV R0,OBLKS		;SAVE SIZE OF OUTPUT FILE
	MOV SP,R0		;GET TOP ADDR
	CLR R1
	BISB ROLSIZ+SECROL+1,R1
	IMULI RS.RLD*2,R1
	SUB R1,R0
	SUB #400,R0		;ALLOW 200 WORD STACK
	SUB BOTTOM,R0		;COMPUTE BUFFER SIZE
	BIC #511,R0		;ROUND TO BLOCK BOUNDARY
	MOV R0,OSIZE		;KEEP SIZE OF OUTPUT BUFFER IN BYTES
	ADD BOTTOM,R0
	MOV R0,TOP
	ADD #128,R0		;SET THE LOWER LIMIT
	MOV R0,STLLIM
	ADD #128,R0
	MOV R0,STGARD
	TST SWL			;.LDA OUTPUT?
	BNE 8$			;YES. DON'T PRE-FILL
	MOV FILLC,R1		;GET FILL CHARACTER
	MOV OSIZE,R2		;GET OUTPUT BUFFER SIZE
	MOV BOTTOM,R0		;GET BOTTOM ADDRESS
	MOV OBLKS,R3		;GET SIZE OF OUTPUT FILE IN BLOCKS
	SWAB R3			;  COMPUTE SIZE IN WORDS
6$:	MOVB R1,(R0)+		;FILL UP BUFFER
	SOB R2,6$
	MOV OSIZE,R1		;GET OUTPUT BUFFER SIZE IN BYTES
	CLC
	ROR R1			;IN WORDS
10$:	SUB R1,R3		;TAKE FROM TOTAL
	BHIS 9$			;OK
	ADD R3,R1		;ELSE USE RESIDUAL
9$:	.WRITW #WA,#2,BOTTOM,R1,R2
	BCC 7$
	TSTB @#ERRBYT		;ERROR?
	BEQ 8$			;EOF
ERRO:	MSGF <Error writing output. >,128
	TFILE #OUT

7$:	SWAB R0
	ADD R0,R2
	TST R3			;ANYMORE?
	BGT 10$			;YEP. CONTINUE

8$:	CLR TBSIZ		;MAKE SURE TXT BUFFER IS EMPTY
	CLR OBLOCK		;MAKE SURE TO START AT 0
	.DSABL LSB

P50:	ZAP RLDROL		;PURGE RLDROL
P51:	CALL READR		;GET RECORD
	BNE 10$
	CALL FLTXT		;FLUSH OUT TXT BUFF
	TST SWL			;.LDA OUTPUT?
	BEQ 5$			;NOPE
	MOV XFERAD,TBLA		;PASS XFER ADDRESS
	MOV #2,TBSIZ
	CALL FLTXT		;WRITE A EOF RECORD
5$:	CALL FOUT		;FLUSH OUTPUT
	.CLOSE #2		;DONE
	RET

10$:	MOV R0,R4		;KEEP BYTE COUNT OF RECORD
	SUB #2,R4		;-2 FOR TYPE CODE
	MOV #RBUFF,R5		;POINT TO BUFFER
	MOV (R5)+,R0		;GET TYPE CODE
	CMP R0,#RTMAX		;LEGAL?
	BLO P52
JBO:	JMP BADOBJ		;NOPE

P52:	ASL R0
	JMP @RTABL(R0)

RTABL:	.WORD JBO		;0=BAD OBJ
	.WORD R.GSD		;GSD TYPE
	.WORD P51		;ENDGSD (NOP)
	.WORD R.TXT		;TXT RECORD
	.WORD R.RLD		;RLD RECORD
	.WORD P51		;ISD (NOP)
	.WORD P50		;ENDMOD (PURGE RLDROL)
RTMAX=.-RTABL/2
	.PAGE

R.GSD:	MOVB 5(R5),R0		;GET TYPE
	ASL R0
	MOV R5,-(SP)		;SAVE POINTER
	MOV #SYMBOL,R3		;POINT TO ROLL WORK SPACE
	ADD R0,PC		;GO TO ROUTINE
	BR R.GSDN		;MODULE NAME
	BR R.CSCT		;CSECT
	BR R.GSDN		;INTERNAL SYMBOL
	BR R.XFER		;XFER ADDR
	BR R.GSDN		;GLOBL SYMBOL
	BR R.PSCT		;PSECT
	BR R.GSDN		;.IDENT
	BR R.GSDN		;.VIR

R.GSDN:	MOV (SP)+,R5		;RESTORE POINTER
	ADD #8,R5		;BUMP UP
	SUB #8,R4		;COUNT DOWN
	BGT R.GSD
	BR P51			;CONTINUE

R.XFER:	MOV (R5)+,(R3)		;GET SYMBOL
	MOV (R5)+,2(R3)
	CLR ROLUPD		;START AT THE BEGINNING
10$:	SCANC SECROL		;LOOK FOR THE SECTION
	BIT #S.OVR,FLAGS(R3)	;OVERLAYED?
	BNE 20$			;YES. DON'T LOOK ANY FURTHER
	CMPB CHAN,SECT(R3)	;MATCH?
	BNE 10$			;NO GET NEXT ONE

20$:	ADD 2(R5),OFFSET(R3)	;COMPUTE XFER ADDRESS
	MOV OFFSET(R3),XFERAD	;AND KEEP IT FOR LATER
	BR R.GSDN

R.CSCT:
R.PSCT:	MOV (R5)+,(R3)		;PASS SYMBOL
	MOV (R5)+,2(R3)
	CLR ROLUPD
1$:	SCANC SECROL		;GET SECTION STUFF
	BIT #S.OVR,FLAGS(R3)	;OVERLAYED?
	BNE 2$			;YES. DON'T LOOK ANY FURTHER
	CMPB CHAN,SECT(R3)	;MATCH?
	BNE 1$			;NO GET NEXT ONE

2$:	MOV OFFSET(R3),FLAGS(R3);SET VALUE
	APPEND RLDROL		;PUT IT IN RLDROL
	BR R.GSDN

R.TXT:	CALL FLTXT		;FLUSH OUT TXT BUFFER
	MOV R4,TBSIZ		;SAVE BYTE COUNT
	BLE P51
	MOV #TBLA,R1		;POINT TO TXT BUFFER
1$:	MOVB (R5)+,(R1)+	;COPY IT
	SOB R4,1$
	ADD CURLOC,TBLA		;POSITION TXT
	BR P51

	ENTSEC IMPURE
TBSIZ:	.BLKW
TBLA:	.BLKW
TB:	.BLKB 132
BYTMOD:	.BLKW
M68FLG:	.BLKW
XFERAD:	.BLKW 
	XITSEC
	.PAGE
R.RLD:	MOVB (R5)+,R0		;GET TYPE
	CLR R1
	BISB (R5)+,R1		;GET DISLACEMENT
	SUB #4,R1		;ADJUST DISPLACEMENT
	ASL R0
	ROR BYTMOD		;SAVE BYTE MODE FLAG
	MOVB R0,R0		;PROPAGATE M68 FLAG
	MOV R0,M68FLG		;SAVE IT
	BIC #-128,R0		;ZAP UNUSED BIT
	CMP R0,#RLDMAX		;LEGAL?
	BLO 1$
	JMP BADOBJ

1$:	MOV #SYMBOL,R3
	CLR (R3)		;START WITH NO SYMBOL
	CLR 2(R3)
	JMP @RLDTBL(R0)		;BYE

RLDTBL:	.WORD BADOBJ		;(00) BAD
	.WORD RL.IR		;(01) INTERNAL RELOCATION
	.WORD RL.GR		;(02) GLOBAL RELOCATION
	.WORD RL.IDR		;(03) INTERNAL DISPLACED RELOCATION
	.WORD RL.GDR		;(04) GLOBAL DISLACED RELOCATION
	.WORD RL.GAR		;(05) GLOBAL ADDITIVE RELOCATION
	.WORD RL.GAD		;(06) GLOBAL ADDITIVE DISLACED RELOCATION
	.WORD RL.LCD		;(07) LOCATION COUNTER DEFINITION
	.WORD RL.LCM		;(10) LOCATION COUNTER MODIFICATIION
	.WORD RL.LIM		;(11) .LIMIT
	.WORD RL.PSC		;(12) PSECT RELOCATION
	.WORD RL.VCT		;(13) .VCTRS/.CKSUM
	.WORD RL.PDR		;(14) PSECT DISLACED RELOCATION
	.WORD RL.PAR		;(15) PSECT ADDITIVE RELOCATION
	.WORD RL.PAD		;(16) PSECT ADDITIVE DISLACED RELOCATION
	.WORD RL.CMP		;(17) COMPLEX
	.WORD RL.DPG		;(20) .DPAGE directive in MAC69
RLDMAX=.-RLDTBL

RL.IR:	CALL M68MOV		;GET CONSTANT
	ADD CURLOC,R0		;+PSECT BASE
RL.M4:	SUB #4,R4		;COUNT DOWN

RL.RET:	TST BYTMOD		;BYTE MODE?
	BPL 1$			;NO
	MOVB R0,TB(R1)		;YES. PASS BYTE
	CLRB R0
	SWAB R0
	BEQ RL.NOM		;OK
	CMPB R0,DPAGE		;MATCH DPAGE?
	BEQ RL.NOM		;YEP, OK THEN
	INCB R0			;ALL 1'S?
	BEQ RL.NOM		;YEP. OK
	MOV #BRELOC,R2
	MOV TBLA,R0		;LOAD ADDRESS
	ADD R1,R0		;+ DISPLACEMENT OFFSET
	CALL E.SO		;PRINT INFO ABOUT ERROR
	PRINT #BRERR
	INCB LWRNS
	BR RL.NOM
	.PAGE
1$:	TST M68FLG		;6800 MODE?
	BMI 2$			;YES
	SWAB R0			;SWITCH AROUND
2$:	MOVB R0,TB+1(R1)
	SWAB R0
	MOVB R0,TB(R1)

RL.NOM:	TST R4
	BGT R.RLD
	JMP P51

RL.GR:	CALL RL.SYM		;LOOK UP SYMBOL IN GLOBAL TABLE
RL.PR:	SUB #6,R4		;CONT DOWN
	BR RL.RET		;STUFF IT
RL.IDR:	CALL M68MOV		;GET CONSTANT
RL.DSP:	SUB TBLA,R0		;-LOAD ADDRESS
	SUB R1,R0		;-DISLACEMENT
	DEC R0
	TST BYTMOD
	BMI 1$
	DEC R0
1$:	BR RL.M4		;TAKE 4

RL.GDR:	CALL RL.SYM		;GLOBL DSP
RL.PD:	SUB #2,R4
	BR RL.DSP

RL.GAR:	CALL RL.SYM		;GLBL ADD RGL
RL.GA:	CALL M68ADD		;ADD DISPLACMENT
	SUB #8,R4
	BR RL.RET		;DO IMMEDIATE

RL.GAD:	CALL RL.SYM
RL.PDA:	CALL M68ADD		;ADDITIVE
	SUB #4,R4		;COUNT (8-4)
	BR RL.DSP		;DO DISPLACEMENT

	.PAGE
RL.LCD:	CALL RL.RLD
	MOV R0,CURLOC		;NEW LOCATION
	MOV ROLENT,CURSEC	;RECORD CURRENT SECTOR
	DEC CURSEC		;MAKE SECTOR # RELATIVE TO 0
	TST (R5)+		;SKIP OVER CONSTANT
	SUB #8,R4
	BR RL.NOM		;NO MODIFICATION RQD

RL.LCM:	TST (R5)+		;NOP
	SUB #4,R4
	BR RL.NOM

RL.DPG:	MOV (R5)+,DPAGE		;RECORD DPAGE
	SUB #4,R4		;COUNT DOWN
	BR RL.NOM

RL.LIM:	ADD #2,R1		;LOW LIMIT IS ALWAYS 0
	MOV HILIMI,R0		;HI LIMIT
	SUB #2,R4
	BR RL.RET

RL.PSC:	CALL RL.RLD
	BR RL.PR

RL.PDR:	CALL RL.RLD
	BR RL.PD

RL.PAR:	CALL RL.RLD
	BR RL.GA

RL.PAD:	CALL RL.RLD
	BR RL.PDA

RL.VCT:	CALL RL.SYM		;.VCTRS/.CKSUM POSITION POINTER.
	CALL M68ADD		;ADDITIVE
	MOV R0,TBLA
	SUB #8,R4
	BR RL.NOM

RL.SYM:	MOV (R5)+,(R3)+
	MOV (R5)+,(R3)+
	SEARCH SYMROL
	MOV 2(R3),R0
	RET

RL.RLD:	MOV (R5)+,(R3)+
	MOV (R5)+,(R3)+
	SCAN RLDROL
	MOV (R3),R0
	RET
	.PAGE
M68MOV:	MOV (R5)+,R0		;GET CONSTANT
	TST M68FLG		;6800 MODE?
	BPL 1$			;NOPE
	SWAB R0			;SWITCH IT AROUND

1$:	TST BYTMOD		;BYTE?
	BPL 2$			;NOPE
	MOVB R0,R0		;SIGN EXTEND
2$:	RET

M68ADD:	MOV R0,-(SP)		;SAVE R0
	CALL M68MOV		;GET CONSTANT
	ADD (SP)+,R0		;ADDITIVE
	RET

	.SBTTL	COMPLEX RELOCATION

RL.CMP:	MOV R1,DSPSVE		;SAVE DISPLACEMENT
	MOV SP,R2		;SAVE STACK
	sub #2,r4		;count the cplx command and displacement
	ble bcx			;nfg if nothing left
C.NOP:	MOVB (R5)+,R0		;GET CODE BYTE
	DEC R4			;COUNT BYTE
	BLT BCX			;N.F.G.
	ASL R0			;WORD INDEX
	CMP R0,#CPXMAX		;LEGAL?
	BHIS BCX
	MOV CX(R0),-(SP)
	CLR R0
	JMP @(SP)+

BCX:	MSGF <Bad complex string (RLD). File=>,128
	TFILE

CX:	.WORD C.NOP		;0  NO-OP
	.WORD C.ADD		;1  ADDITION
	.WORD C.SUB		;2  SUBTRACTION
	.WORD C.MUL		;3  MULTIPLICATION
	.WORD C.DIV		;4  DIVISION
	.WORD C.AND		;5  AND
	.WORD C.OR		;6  OR
	.WORD C.XOR		;7 EXCLUSIVE OR
	.WORD C.NEG		;10 NEGATE
	.WORD C.COM		;11 COMPLIMENT
	.WORD C.IMM		;12 STORE IMM
	.WORD C.DSP		;13 STORE DISPLACED
	.WORD C.USD		;14 UNSIGNED DIVIDE
	.WORD c.swb		;15 swap bytes
	.WORD C.FGS		;16 GET GLOBAL SYMBOL
	.WORD C.FRV		;17 GET RELOCATABLE VALUE
	.WORD C.CNST		;20 GET CONSTANT
	.word c.HIB		;21 USE HIGH BYTE ONLY
	.word C.LOB		;22 USE LOW BYTE ONLY
	.word C.MOD		;23 MODULO
	.word BCX		;24 Unassigned
	.word C.SHL		;25 SHIFT LEFT
	.word C.SHR		;26 SHIFT RIGHT
CPXMAX=.-CX

C.ADD:	ADD (SP)+,(SP)
C.CONT:	CMP SP,R2		;OK?
	BHIS BCX		;STACK UNDER/OVERFLOW
	br c.nop

C.SUB:	SUB (SP)+,(SP)
	BR C.CONT
C.MUL:
	MOV (SP)+,R0
	MUL (SP)+,R0
	MOV R1,-(SP)
	BR C.CONT
	.PAGE
C.USD:	INC R0			;SIGNAL UNSIGNED DIVIDE
C.DIV:	MOV (SP)+,R3		;DIVISOR
	mov (sp)+,r1		;get dividend
	call c.cdiv		;do common divide stuff
	mov r0,-(sp)		;pass back result
	br c.cont		;and continue

c.cdiv:	ASR R0			;GET SIGNED/UNSIGNED FLAG IN C AND CLR R0
	bit r3,r3		;divisor?
	BNE 10$			;OK
	MOV R2,-(SP)
	MOV DSPSVE,R0
	ADD TBLA,R0
	MOV #ERRLOC,R2
	CALL E.SO		;DISPLAY FAILING ADDRESS
	PRINT #DIVBY0
	INCB LWRNS
	MOV (SP)+,R2
	clr r0			;return 0 quotient
	clr r1			;return 0 remainder
	return			;and return

10$:	BCC 15$			;SIGNED DIVIDE
	BPL 15$			;UNSIGNED, BUT DIVISOR IS +
	CMP R3,r1		;DO UNSIGNED 16 BIT DIVIDE
	BHI 30$			;DIVISOR IS BIGGER THAN DIVIDEND, ANS=0
	sub r3,r1		;compute remainder
	INC R0			;and set quotient of 1
	BR 30$

15$:	bit r1,R1		;GET DIVIDEND
	BCS 20$			;UNSIGNED, LEAVE R0 0
	SXT R0			;ELSE SIGN EXTEND IT
20$:	DIV R3,R0		;DIVIDE <R0,R1>/R3
30$:	return			;r0=quotient/r1=remainder

C.AND:	COM (SP)
	BIC (SP)+,(SP)
	BR C.CONT

C.OR:	BIS (SP)+,(SP)
	BR C.CONT

C.XOR:	MOV (SP)+,R0
	MOV (SP),R1
	BIC R0,(SP)
	BIC R1,R0
	BIS R0,(SP)
	BR C.CONT

C.NEG:	NEG (SP)
	BR C.CONT

C.COM:	COM (SP)
	BR C.CONT

C.IMM:	call c.adj		;fix up buffer, r1 and stack
	JMP RL.RET		;and go patch byte immediate mode

C.DSP:	call c.adj		;fix up buffer, r1 and stack
	ADD #4,R4		;compensate for r.dsp taking 4 from count
	JMP RL.DSP		;and go patch byte PC relative

c.adj:	mov (sp)+,r3		;get the return address
	MOV (SP)+,R0		;get the value to store
	CMP SP,R2		;stack match entry value?
	beq c.ad10		;its ok
	jmp bcx			;else its bad

c.ad10:	tst r4			;any data left in buffer?
	ble 10$			;nope, never mind about move then
	bit #1,r5		;is the pointer even?
	beq 10$			;yep, leave it alone then
	mov r5,r1		;point to our position
	dec r1			;-1
	mov r1,-(sp)		;save the new address
	mov r4,-(sp)		;save the byte count
5$:	movb (r5)+,(r1)+	;backup 1 byte
	sob r4,5$		;until all bytes are moved
	mov (sp)+,r4		;restore count
	mov (sp)+,r5		;restore address
	dec r5			;-1
10$:	MOV DSPSVE,R1		;get the offset into the text buffer
	jmp (r3)		;go back to caller

C.FGS:	MOV #SYMBOL,R3
	MOVB (R5)+,(R3)+
	MOVB (R5)+,(R3)+
	MOVB (R5)+,(R3)+
	MOVB (R5)+,(R3)+
	SEARCH SYMROL
	MOV 2(R3),-(SP)
	SUB #4,R4		;TAKE 4 BYTES FROM TOTAL
	BR jC.CONT

C.CNST:	MOVB (R5)+,-(SP)
	MOVB (R5)+,1(SP)
	SUB #2,R4		;TAKE 2 MORE BYTES FROM TOTAL
	BR jC.CONT

C.FRV:	CLR R0
	BISB (R5)+,R0		;SECTOR #
	MOVB (R5)+,-(SP)	;OFFSET WITHIN SECTOR
	MOVB (R5)+,1(SP)
	IMULI RS.RLD*2,R0
	ADD ROLBAS+RLDROL,R0
	ADD 4(R0),(SP)
	SUB #3,R4		;TAKE 3 MORE BYTES FROM TOTAL
jc.cont: jmp C.CONT
	.page
c.mod:	mov (sp)+,r3		;get divisor
	bpl 10$			;modulus is +, so ok as is
	neg r3			;else fix it
	bpl 10$			;its ok now
	inc r0			;do unsigned divide
10$:	mov (sp)+,r1		;get dividend
	call c.cdiv		;do common divide stuff
	mov r1,-(sp)		;keep only the remainder
	br jc.cont

c.swb:	swab (sp)		;swap bytes
	br jc.cont

c.shr:	mov (pc)+,r1		;prepare for a code crash
	ror (sp)		;  inner loop instruction
	br c.shx		;do common shift code

	.enabl lsb
c.shl:	mov (pc)+,r1		;prepare for the code crash
	rol (sp)		;  inner loop instruction
c.shx:	mov	r1,20$		;crash our code
	mov	(sp)+,r3	;get the shift count
	bgt	10$		;its gotta shift some
	beq	30$		;nuthin to do
	neg	r3		;fix the shift count
	bmi	25$		;its too big, give 'em a 0
	xor	#^O100,20$	;change the ROL/ROR instruction (code crash)
10$:	cmp	r3,#16.		;shifting more than 16 bits?
	bge	25$		;yep, just give 'em a 0
15$:	clc
20$:	rol	(sp)		;shift it
	sob	r3,15$		;until all shifted
	br	30$

25$:	clr	(sp)		;force a 0
30$:	br	jc.cont		;and return
	.dsabl lsb

c.hib:	clrb (sp)		;make a hole
	swab (sp)		;and put the high byte there
	br jc.cont		;continue

c.lob:	clrb 1(sp)		;zap the upper byte
	br jc.cont		;and continue

	.NLIST BEX
	ENTSEC MSGS
DIVBY0:	.ASCII	\?LINKM-W-Divide by 0: \
ERRLOC:	.BLKB 40

BRERR:	.ASCII	\?LINKM-W-Byte relocation error: \
BRELOC:	.BLKB 40
	XITSEC

	ENTSEC IMPURE
DSPSVE:	.BLKW
VIRTL:	.BLKW
	XITSEC
	.PAGE
	.SBTTL E.SO display error address
E.SO:	MOV R4,-(SP)		;SAVE SOME REGS
	MOV R3,-(SP)
	MOV R1,-(SP)
	MOV R0,-(SP)
	MOV #' ,R3		;GET A SPACE CODE FOR LATER
	MOV #SYMBOL,R1		;POINT TO SYMBOL
	MOV R1,R4		;KEEP 2 COPIES OF SYMBOL ADDRESS
	TST (R1)		;ANY SYMBOL?
	BEQ 10$			;NO, NEVER MIND
	MOVB #'",(R2)+		;IDENTIFY SYMBOL IN ERROR
	CALL SYMTOA
5$:	CMPB R3,-(R2)		;FIND LAST NON-SPACE
	BEQ 5$
	INC R2
	MOVB #'",(R2)+		;CLOSE SYMBOL FIELD
	MOVB R3,(R2)+		;FOLLOW WITH A COUPLE SPACES
	MOVB R3,(R2)+

10$:	MOV CURSEC,R0		;GET CURRENT SECTION #
	IMULI RS.RLD*2,R0	; * SECTION SIZE IN BYTES
	ADD ROLBAS+RLDROL,R0	; + ROLL ADDRESS
	MOV (R0)+,(R4)+		;PUT SECTION NAME IN SYMBOL
	MOV (R0)+,(R4)+
	MOV (R0),R4		;KEEP OFFSET
	MOVB #'[,(R2)+		;OPEN SECTION NAME FIELD
	TST (R1)		;UN-NAMED SECTION?
	BNE 12$			;NOPE, DISPLAY NAME
	MOV R4,R0		;PRINT OFFSET INSTEAD OF NAME
	CALL OUTNUM
	BR 15$			;CLEAN UP

12$:	CALL SYMTOA		;DISPLAY NAME

15$:	CMPB R3,-(R2)
	BEQ 15$			;REMOVE EXTRA SPACES
	INC R2
	MOVB #'],(R2)+		;CLOSE NAME FIELD
	MOVB #'+,(R2)+		;FOLLOW WITH A +
	MOV (SP)+,R0		;GET ABSOLUTE ADDRESS
	SUB R4,R0		;MAKE IT RELATIVE TO SECTION BOTTOM
	CALL OUTNUM		;DISPLAT IT
	MOV #M.FILE,R1		;POINT TO "file="
	CALL MOVBYT		;PASS IT
	MOV #FILEN,R0		;POINT TO CURRENT FILE NAME
	CALL CVFN		;DISPLAY IT TOO
	MOV (SP)+,R1		;RESTORE AND EXIT
	MOV (SP)+,R3
	MOV (SP)+,R4
	MOV SP,TTKEY		;SIGNAL STUFF GOES TO TT: TOO
	RET

	ENTSEC MSGS
M.FILE:	.ASCIZ \file=\
	XITSEC
	.PAGE
	.SBTTL	TXT RECORD HANDLER
FLTXT:	MOV TBSIZ,R1		;GET TEXT BUFF SIZE
	BLE 1$			;EMPTY, EXIT
	MOV R2,-(SP)
	MOV #TBLA,R2
	TST SWL			;LDA FILE?
	BNE TXTLDA		;YES
	MOV (R2),R0		;GET LOAD ADDRESS
	SUB VIRTL,R0		;IS LOAD ADDRESS IN BUFFER?
	BLO 6$			;NOPE
	CMP R0,OSIZE
	BLO 2$			;YEP
6$:	CALL FOUT		;FLUSH OUTPUT
	MOV (R2),R0		;GET LOAD ADDRESS
	BIC #511,R0		;ROUND DOWN TO BLOCK
	CALL ROUT		;READ STUFF

2$:	MOV (R2)+,R0		;COMPUTE INDEX INTO BUFFER
	SUB VIRTL,R0
	ADD BOTTOM,R0		;R0 NOW POINTS TO OUTPUT
	DEC R1
	BR 4$

3$:	MOVB (R2)+,(R0)+
4$:	DEC R1
	BLE 5$			;DONE
	CMP R0,TOP		;OFF END OF BUFFER?
	BLO 3$			;NO
	CALL FOUT		;FLUSH OUTPUT
	MOV OSIZE,R0
	ADD VIRTL,R0		;BUMP TO NEXT GROUP
	CALL ROUT		;READ IN A BUNCH
	MOV BOTTOM,R0
	BR 3$			;CONTINUE

5$:	CLR TBSIZ
	MOV (SP)+,R2
1$:	RET

TXTLDA:	ADD #4,R1		;LDA COUNT
	MOV R3,-(SP)		;SAVE R3
	MOV #1,R0		;.LDA RECORD STARTS WITH 1,0
	MOV R0,R3		;INIT THE CHECKSUM
	CALL LDAOUT
	CLR R0
	CALL LDAOUT		;0
	MOV R1,R0
	ADD R0,R3		;CHECKSUM COUNT
	CALL LDAOUT		;LSB OF COUNT
	SWAB R0
	ADD R0,R3		;+ COUNT MSB
	CALL LDAOUT		;MSB OF COUNT
	MOVB (R2)+,R0
	ADD R0,R3
	CALL LDAOUT		;ADDR LSB
	MOVB (R2)+,R0
	ADD R0,R3
	CALL LDAOUT		;ADDR MSB
	SUB #6,R1		;COUNT DOWN
	BLE 1$			;DONE
2$:	MOVB (R2)+,R0		;COPY STUFF
	ADD R0,R3
	CALL LDAOUT
	DEC R1
	BGT 2$

1$:	NEG R3			;COPY CHECKSUM
	MOV R3,R0
	CALL LDAOUT
	MOV (SP)+,R3		;RESTORE
	MOV (SP)+,R2
	RET			;EXIT

LDAOUT:	MOVB R0,@OBP		;WRITE DATA
	INC OBP
	CMP OBP,TOP		;BUFFER FULL?
	BLO 1$			;NO
	CALL FOUT		;FLUSH OUTPUT
1$:	RET

	.ENABL LSB
ROUT:	MOV R0,VIRTL		;INDICATE VIRTUAL ADDRESS OF BUFFER
	ASR R0			;FIGURE BLOCK #
	SWAB R0
	BIC #-128,R0
	MOV R0,OBLOCK		;INDICATE BLOCK
	MOV OSIZE,R0		;GET SIZE
	ROR R0			;IN WORDS
	MOV R0,-(SP)
	.READW #WA,#2,BOTTOM,(SP)+,OBLOCK
	BCC 1$			;OK
	MSGF <Error reading output file. >,128
	TFILE #OUT

1$:	RET
	.DSABL LSB
	.PAGE
FOUT:	MOV R0,-(SP)
	MOV R1,-(SP)
	MOV R2,-(SP)
	TST SWL			;LDA OUTPUT?
	BNE 1$			;YES.
	MOV VIRTL,R1		;GET VIRTUAL ADDRESS OF THIS BLOCK
	MOV VTOP,R2		;GET TOP ADDRESS
	SUB R1,R2		;COMPUTE SIZE IN BYTES
	CMP R2,OSIZE		;BIGGER THAN BUFFER?
	BLOS 2$			;NOPE. USE THE COMPUTED COUNT
	MOV OSIZE,R2		;ELSE USE THE SIZE OF THE BUFFER
2$:	ADD #511,R2		;ROUND UP TO BLOCK BOUNDARY
	ROR R2			;WORD COUNT
	CLRB R2			;WRITE ONLY BLOCK SIZED RECORDS
	ROR R1
	CLRB R1
	SWAB R1
6$:	.WRITW #WA,#2,BOTTOM,R2,R1	;WRITE DATA
	BCC 3$
	JMP ERRO

3$:	SWAB R0
	ADD R0,OBLOCK
7$:	MOV BOTTOM,OBP
	MOV (SP)+,R2
	MOV (SP)+,R1
	MOV (SP)+,R0
	RET

1$:	MOV BOTTOM,R1		;BUFFER @
	MOV OBP,R2		;POINTER
	MOV R2,R0
	SUB R1,R2		;COMPUTE SIZE IN BYTES
	BLOS 7$			;EMPTY
5$:	BIT #511,R2		;ON BLOCK BOUNDARY?
	BEQ 4$			;YEP
	CLRB (R0)+		;ZERO FILL LAST BLOCK
	INC R2
	BR 5$

4$:	ROR R2			;WORD COUNT
	MOV OBLOCK,R1
	BR 6$			;WRITE LAST BLOCK
	.PAGE
	.SBTTL	CLOSUP FINISH UP

CLOSUP:
.IIF NE,DEB$,MSG <Close up the files>
	TST MAP			;ANY MAP OUTPUT?
	BEQ 2$
	CALL MFLUSH
	.CLOSE #1		;DONE
2$:	RETURN
	.PAGE
	.SBTTL	MAP TEXT
	ENTSEC MSGS

	.NLIST BEX
TITLE:	.ASCII <CR>\ATARI LINKM \
	GTVNUM 
	.ASCII \ LOAD MAP   \
TDATE:	.BLKB 9			;CURRENT DATE
	.ASCII \   \
TTIME:	.BLKB 9			;CURRENT TIME
	.BYTE CR,LF
TIFN:	.BLKB 14		;OUTPUT FILE NAME
	.BYTE CR,CR,LF,0

FNSMRY:	.ASCII <CR><LF>\File Summary:\<CR><LF>
	.ASCIZ \    Name	Title	Ident	Creation Date/Time   Langauge statistics\
$FNSMR	=4		;MUST BE ROOM FOR 4 LINES TO PRINT

SSMRY:	.ASCII <CR><LF>\Section Summary:\<CR><LF>
	.ASCIZ \ Name   Addr    Size    Attributes     References (Files):\
$SSMR	=4		;ROOM REQUIREMENTS

GSMRY:	.ASCII <CR><LF>\Global Symbol Summary:\<CR><LF>
	.ASCIZ \ Name	Value    References (Files):\
GSYMS:	.ASCII <CR><LF>\Global Symbol Summary:\<CR><LF>
	.REPT 8
	.ASCII \ Name  Value    \
	.ENDR
	.BYTE 0
$GSMR	=4		;ROOM REQUIREMENTS

MONTBL:	.ASCIZ /JAN/
	.ASCIZ /FEB/
	.ASCIZ /MAR/
	.ASCIZ /APR/
	.ASCIZ /MAY/
	.ASCIZ /JUN/
	.ASCIZ /JUL/
	.ASCIZ /AUG/
	.ASCIZ /SEP/
	.ASCIZ /OCT/
	.ASCIZ /NOV/
	.ASCIZ /DEC/

UDFGLB:	.ASCII <CR><LF>\Undefined GLOBLs:\<CR><LF>
	.ASCIZ \Symbol(s):   References:\
$UDF	=4		;ROOM REQUIREMENTS

MDFSYM:	.ASCII <CR><LF>\Multiply defined GLOBLs:\<CR><LF>
	.ASCIZ \Symbol(S):   References:\
$MDF	=4		;ROOM REQUIREMENTS

	.PSECT IMPURE
LB:	.BLKB 132
	XITSEC
	.PAGE
	.SBTTL OPEN - FILE OPENER
	.ENABL LSB
OPEN:	SAVREG			;SAVE ALL REGISTERS
	CLR R5			;START AT CHAN 0
	MOV #CSISPC+30,R4	;POINT TO FILE SPEC

10$:	MOV #CSISPC,R3		;POIN TO TEMPORARY WORK SPACE
	MOV R3,R2
	MOV R4,R1		;SET UP FOR MOVE
	CALL XMIT4		;COPY FILE NAME
	MOV #DVCTBL+DVTSZE,R1	;POINT TO SEARCH TABLE
	CMP (R4),#^RDK 		;DEFAULT DEVICE?
	BNE 20$			;NOPE. JUST DO LOOKUP
	SUB #DVTSZE,R1		;BACKUP TO ENABLE SEARCH
	CLR (R4)		;ZAP DK: IN CASE OF FNF

20$:	.CLOSE R5		;CLAIM CHANNEL
	.FETCH BOTTOM,R3	;GET HANDLER
	BCC 30$			;OK
	TST (R1)		;SEARCHING?
	BNE 40$			;YEP, PROCEED
	MOV R3,R1
	JMP ILLDVC		;BAD

30$:	MOV R0,BOTTOM		;UPDATE POINTER
	ADD #128,R0
	MOV R0,STLLIM
	ADD #128,R0
	MOV R0,STGARD
	.SERR			;SOFT LANDINGS FOR THE .LOOKUP
	.LOOKUP R2,R5,R3	;TRY TO OPEN FILE FOR INPUT
	ROR -(SP)		;SAVE STATS
	.HERR			;BACK TO HARD LANDINGS
	ROL (SP)+		;STATS?
	BCC 60$			;SUCCESS

40$:	MOV (R1)+,(R3)		;TRY A DIFFERENT DEVICE?
	BNE 20$			;YEP.
	MSGF <File not found. >,128
	TFILE R4		;BAD

60$:	MOV #SYMBOL,R2		;COPY FILE NAME TO SYMBOL SPACE
	MOV R3,R1
	CALL XMIT4
	CLR (R2)		;ASSUME ITS NOT AN Option FILE
	CMP -(R1),#^ROPT	;TRUE?
	BNE 70$			;YEP
	INC (R2)		;ELSE MAKE IT AN OPTION FILE
70$:	APPEND FILROL		;PUT FILE NAME INTO FILE ROLL
	.CLOSE R5		;RE-CLAIM CHANNEL
	ADD #8,R4		;NEXT FILE SPEC
	CMP R4,#CSISPC+30+<6*8>  ;END?
	BHIS 80$		;YEP
	TST (R4)		;ANY FILE?
	BNE 10$			;YEP. LOOK AGAIN
	.PAGE
80$:	CLR CHAN		;ALWAYS START AT BEGINING
	CLR IBP
	RET
	.DSABL LSB

DVCTBL:
.IF EQ,VAX$
	.RAD50 /DK1/
	.RAD50 /DY1/
	.RAD50 /DY0/
.IFF
	.RAD50 /VX0/
	.RAD50 /VX1/
	.RAD50 /VX2/
	.RAD50 /VX3/
	.RAD50 /VX4/
	.RAD50 /VX5/
	.RAD50 /VX6/
	.RAD50 /VX7/
.ENDC
DVTSZE = .-DVCTBL
	.WORD 0

	.SBTTL READ ROUTINE
	.ENABL LSB

READ:	SAVREG			;SAVE ALL
	CLR R5			;GET A 0 FOR LATER
	TST CHAN		;ANYTHING OPEN?
	BNE 30$			;YEP. PROCEED

10$:	CLR DPAGE		;BE SURE TO RESET THE .DPAGE POINTER
	INC CHAN		;OPEN FILE FOR THE FIRST TIME
	MOV CHAN,R1
	CALL GETFSP		;GET FILE SPECS
	BLO 20$			;OK
	DEC CHAN		;BACK UP
	CLR R0			;SAY EOF
	RET			;EOF ON ALL FILES. DONE

20$:	CMP 8(R1),OPTFLG	;IS THIS FILE ONE OF THE ONES WE WANT?
	BNE 10$			;NOPE, SKIP IT
	MOV #FILEN,R2		;POINT TO FILE SPEC SPACE
	MOV R2,R3		;KEEP A POINTER TO FILE NAME
	CALL XMIT4		;KEEP A COPY OF FILE NAME IN CASE OF ERRORS
.IF NE,DEB$
	MOV R3,R0		;POINT TO FILENAME
	CALL CVFNLB
	MSG <Opening file: >,,128
	.PRINT #LB
.ENDC
	.CLOSE R5		;CLAIM CHANNEL 0
	.LOOKUP #WA,R5,R3	;RE-OPEN CHANNEL 0
	CLR IBLOCK		;START READING AT BLOCK 0

30$:	.READW #WA,R5,#IBUF,#256,IBLOCK	;READ A BLOCK INTO IBUF
	BCC 50$			;OK
	TSTB @#ERRBYT		;ERROR?
	BEQ 40$			;NOPE. EOF
	MSGF <Read error on file >,128
	TFILE

40$:	TST SAEOF		;SHOULD WE STOP AT EOF?
	BEQ 10$			;NOPE.
	MSGF <Pre-mature end of file >,128
	TFILE

50$:	INC IBLOCK		;UPDATE BLOCK POINTER
	MOV #1,IBP		;SAY BUFFER IS FULL
	RET			;R0 IS .NE. AT THIS EXIT
	.DSABL LSB


GETFSP:	DEC R1			;RELATIVE TO 0
	ADD SCHAN,R1		;SKIP .LNK FILE IF ANY
	IMULI RS.FIL*2,R1	; * ROLL SIZE IN BYTES
	ADD ROLBAS+FILROL,R1	; + BASE
	CMP R1,ROLTOP+FILROL	;SET CC'S AS TO LEGALITY
	RET			;AND EXIT
	.PAGE
	.SBTTL READR READ A FORMATTED RECORD
	.ENABL LSB

READR::
	SAVREG			;SAVE ALL REGS
	MOV #RBUFF,R5		;POINT TO RECORD BUFFER
	CLR SAEOF		;EOF IS OK WHILE LOOKING FOR SENTINEL
2$:	CALL GETBYT		;GET A BYTE FROM A FILE
	CMPB R0,#1		;LOOK FOR A 1,0 COMBINATION
	BNE 2$			;NOT YET
	MOV R0,R3		;INITIALISE CHECK SUM
	CALL GETBYT
	BNE 2$			;NOT 0
	INC SAEOF		;EOF NOT OK AFTER THIS
	CALL GETBYT
	MOV R0,R1		;BYTE COUNT LSB
	ADD R0,R3		;CHKSUM
	CALL GETBYT
	ADD R0,R3		;CHKSUM
	SWAB R0
	BISB R0,R1		;BYTE COUNT MSB
	SUB #4,R1		;-4 (1,0,BCL,BCH)
	CMP R1,#RBSIZE		;WILL RECORD FIT IN BUFFER?
	BLO 3$			;YEP
	MSGF <Bad object format. Record too long. >,128
6$:	TFILE

3$:	MOV R1,R2		;KEEP BYTE COUNT

4$:	CALL GETBYT
	MOVB R0,(R5)+		;COPY TO RECORD BUFFER
	ADD R0,R3		;CHKSUM
	SOB R2,4$

	CALL GETBYT		;GET CHECKSUM BYTE
	ADD R0,R3		;SHOULD TOTAL 0
	TSTB R3			;DID IT?
	BEQ 5$			;YEP
	MSGF <Check sum error in object record. >,128
	BR 6$

5$:	MOV R1,R0		;PASS BACK BYTE COUNT OF RECORD AND SET CC'S
	RET
	.DSABL LSB
	.PAGE
	.SBTTL GETBYT - GET A BYTE FROM A FILE

GETBYT:	MOV IBP,R0		;GET BUFFER POINTER
	BNE 1$			;NOT EMPTY
2$:	CALL READ		;FILL IT
	BNE GETBYT		;AGAIN
	TST (SP)+		;EOF. RETURN 1 LEVEL DEEPER
	RET

1$:	CMP R0,#512		;TOO BIG?
	BHI 2$			;YEP. GO FILL IT AGAIN

	INC IBP			;BUMP POINTER
	MOVB IBUF-1(R0),R0	;GET BYTE
	BIC #-256,R0		;ZAP UPPER BITS AND SET CC'S
	RET



	.SBTTL INIT - MEMORY INITIALISEER

INIT:	.SRESET			;KICK EVERYTHING OUT
	MOV @#RMON,R0		;POINT TO SYSTEM
	MOV ^O266(R0),R0	;GET LOAD ADDRESS OF USR
	TST -(R0)		;-2
	.SETTOP			;GRAB ALL UP TO USR
	MOV #IMPURE,R1		;POINT TO IMPURE REGION
1$:	CLR (R1)+		;ZAP IT
	CMP R1,#IMPEND
	BLO 1$

	MOV #DUMROL-2,R1	;POINT TO END OF ROLL TABLES
2$:	MOV R0,ROLBAS(R1)	;ZAP ROLL TABLES
	MOV R0,ROLTOP(R1)
	CLRB ROLSIZ+1(R1)
	DEC R1
	DEC R1			;BY 2'S
	BGE 2$

	MOV R0,SP		;SET STACK
	MOV LIM+2,BOTTOM	;SET LO LIMIT
	MOV BOTTOM,R0
	ADD #128,R0
	MOV R0,STLLIM
	ADD #128,R0
	MOV R0,STGARD
	MOVB #CR,TITLE
	MOV #1,XFERAD		;INIT THE USER'S START ADDRESS TO 1
	JMP (R4)		;RETURN.

	.PAGE
	.SBTTL RAD50 to ASCII conversions

TFILE:	TST R0			;Default file name?
	BNE 1$			;No
	MOV #FILEN,R0		;Point to default file spec
1$:	INC STENAB		;Disable stack overflow check
	CALL CVFNLB		;Convert file name to ASCII
	.PRINT #LB		;Send it to terminal
	BISB #ER.HER,@#ERRCOM
	JMP START

CVFNLB:	MOV #LB,R2		;POINT TO LINE BUFFER
CVFN:	SAVREG
	MOV R0,R5		;Point to RAD50 word
	MOV R2,-(SP)		;SAVE STRING START ADDRESS

	MOV (R5)+,R0		;DVC name
	BEQ 1$			;None. Skip it
	CALL R50TOA		;1 word to 3 bytes
	MOV R0,R2		;Save updated string pointer
	MOVB #':,(R2)+		;DVC seperator

1$:	MOV (R5)+,R0
	BEQ 2$			;NO NAME
	CALL R50TOA		;File name
	MOV R0,R2
	MOV (R5)+,R0
	CALL R50TOA
	MOV R0,R2
	CMP (R5),#^ROBJ		;Default .OBJ extension?
	BEQ 2$			;Yep, don't print it then
	MOVB #'.,(R2)+		;extension seperator
	MOV (R5),R0
	CALL R50TOA		;Extension
	MOV R0,R2
2$:	CLRB (R2)		;Terminate string
	MOV (SP)+,R2		;RE-POINT TO BEGINING
	MOV R2,R0

3$:	MOVB (R2)+,(R0)		;Copy data
	BEQ 4$			;End
	CMPB (R0),#' 		;Space?
	BEQ 3$			;Yep, ignore it
	INC R0
	BR 3$			;Continue

4$:	RET			;Done
	.PAGE
...RAD	=10			;Save current radix
	.RADIX 8		;Change it to 8
;
; Convert 1 RAD50 word (in R0) to 3 ASCII bytes starting at (R2).
;
;At entry:
; R0 = R50 word to convert
; (R2) = Position to put the 3 ASCII bytes
; At exit:
; (R0) = R2 + 3

R50TOA:	SAVREG
	MOV R0,R1		;Get symbol
	MOV #50*50,R3		;Set divisor to 50**2
	CALL 10$		;Unpack ASCII byte
	MOV #50,R3		;Set divisor to 50**1
	CALL 10$		;Unpack ASCII byte
	MOV R1,R0		;Set divisor to 50**0
	BR 11$			;Unpack ASCII byte and exit

10$:	CLR R0
	DIV R3,R0

11$:	TST R0			;Space?
	BEQ 23$			;Yes
	CMP R0,#33		;Middle
	BLT 22$			;Alpha
	BEQ 21$			;Dollar
	ADD #22-11,R0		;Dot or dollar
21$:	ADD #11-100,R0		;Dollar
22$:	ADD #100-40,R0		;Alpha
23$:	ADD #40,R0		;Space
	MOVB R0,(R2)+		;Pass byte
	MOV R2,R0		;Pass back address
	RET

	.RADIX ...RAD
	.PAGE
	.SBTTL PRINT routines

PRINT::	INCB 2(SP)		;MUST BE ROOM FOR AT LEAST 1 LINE
	CLRB 3(SP)		;BE SURE UPPER BYTE IS 0
	INC 4(SP)		;LINE COUNT MUST BE AT LEAST 1
	CLRB 5(SP)
	CMP 2(SP),LINCNT+2	;ROOM ON PAGE FOR TEXT?
	BLE 1$			;YEP. GO PRINT IT THEN
	MOV R0,-(SP)		;SAVE POINTER
	MOV #TITLE,R0		;POINT TO TITLE LINES
	MOV TTKEY,-(SP)		;SAVE THIS IN CASE OF TITLE
	CALL 2$			;PRINT THEM
	MOV (SP)+,TTKEY		;RESTORE
	MOV (SP)+,R0		;RESTORE POINTER
	MOV LINCNT,LINCNT+2	;RESET LINE COUNTER
	MOVB #FF,TITLE		;REPLACE BEGINING CHARACTER WITH FF

1$:	SUB 4(SP),LINCNT+2	;TAKE ACTUAL NUMBER OF LINES PASSED
	MOV (SP)+,(SP)		;PURGE PARAMETERS
	MOV (SP)+,(SP)
	TST TTKEY		;IS THIS TO GO TO TT: TOO?
	BEQ 2$			;NOPE.
	TST TTMAP		;IS OUTPUT DVC TT:?
	BNE 2$			;YEP. IT GOES THERE BY DEFAULT THEN
	.PRINT			;SEND IT TO CONSOLE TOO

2$:	TST MAP			;ANY OUTPUT REQUESTED?
	BEQ 4$			;DONE THEN
	MOV R1,-(SP)		;SAVE A REG
	MOV R0,R1		;POINT TO TEXT

3$:	MOVB (R1)+,R0		;GET BYTE
	BMI 6$			;STOP ON -'S
	BEQ 5$			;END
	CALL MOUTB		;PASS BYTE TO OUTPUT
	BR 3$			;CONTINUE

5$:	MOVB #CR,R0		;FOLLOW WITH CR,LF
	CALL MOUTB
	MOVB #LF,R0
	CALL MOUTB
6$:	MOV (SP)+,R1		;RESTORE REG

4$:	CLR TTKEY		;COVER OUR TRACKS
	RET

	.PAGE
	.ENABL LSB
MOUTB:	MOVB R0,@MBP		;PUT BYTE INTO BUFFER
	INC MBP			;BUMP POINTER
	CMP MBP,#MBUF+512	;BUFFER NOW FULL?
	BLO 1$			;NOPE, EXIT
4$:	.WRITW #WA,#1,#MBUF,#256,MBLOCK	;WRITE MAP OUTPUT
	BCC 2$			;OK
	MSGF <Error writing MAP file. >,128
	TFILE #MAP

2$:	INC MBLOCK		;BUMP BLOCK POINTER
	MOV #MBUF,MBP		;RESET POINTER
1$:	RET			;EXIT

MFLUSH:	MOV MBP,#MBUF		;BUFFER EMPTY?
	BEQ 1$			;YEP. NOTHING TO DO
	MOV MBP,R0
3$:	CLRB (R0)+
	CMP R0,#MBUF+512
	BLO 3$
	BR 4$
	.DSABL LSB
	.PAGE
	.SBTTL OUTNUM Unpack number to OCTAL/HEX

OUTNUM::
	MOV #4,DNCDIG		;ASSUME HEX AND MINIMUM # OF DIGITS
	MOV R1,-(SP)		;SAVE R1 AND R3 CUZ DNC ZAPS THEM
	MOV R3,-(SP)
	MOV OUTRDX,R3		;GET THE REQUESTED OUTPUT RADIX
	CMP R3,#16		;IS IT REALLY HEX?
	BEQ 10$			;YEP,
	MOV #6,DNCDIG		;ELSE SELECT OCTAL MINIMUM # OF DIGITS
10$:	MOV R0,R1		;THE NUMBER HAS TO BE IN R1
	CALL DNCF		;DISPLAY THE NUMBER IN REQUESTED RADIX
	MOV #' ,R1
	MOVB R1,(R2)+		;FOLLOW WITH SPACES
	MOVB R1,(R2)+
	MOVB R1,(R2)+
	CMP R3,#16		;HEX OUTPUT?
	BNE 20$			;NOPE, JUST 3 SPACES THEN
	MOVB R1,(R2)+		;ELSE GIVE IT 2 MORE
	MOVB R1,(R2)+
20$:	MOV (SP)+,R3		;RESTORE REGS
	MOV (SP)+,R1
	RET

.IF EQ,EIS$
	.PAGE
	.SBTTL MUL/DIV Routines

MUL:	CLR -(SP)		;MSB of product
	MOV R0,-(SP)		;Multiplier
	CLR R0			;MSB of product
	CLR R1			;LSB of product
	ROR (SP)		;Get bit of multiplier into carry (0 ext)
	BR 4$

1$:	ASR (SP)		;Shift multiplier
4$:	BCS 3$			;Accumulate
	BNE 2$			;Still bits left
	CMP (SP)+,(SP)+		;Purge stack
	RET			;R1=LSB, R0=MSB, R3=0

3$:	ADD R3,R1		;LSB
	ADC R0			;+carry to MSB
	ADD 2(SP),R0		;MSB

2$:	ASL R3			;double multiplicand
	ROL 2(SP)
	BR 1$

DIV:	MOV #16.,-(SP)		;Loop count
1$:	ASL R1			;Work registers *2 (LSB)
	ROL R0			;MSB
	CMP R0,R3		;Big enuf?
	BLO 2$			;NO
	SUB R3,R0		;Take some
	INC R1			;Bump result
2$:	DEC (SP)		;Count
	BNE 1$			;Continue
	MOV R1,(SP)
	MOV R0,R1		;R1 = remainder
	MOV (SP)+,R0		;R0 = quotient
	RET
.ENDC
	.PAGE
	.SBTTL UNPTIM Convert time code to ASCII

;AT ENTRY:
; (R0) = POINTS TO 2 WORD TIME CODE
; (R2) = PLACE TO PUT ASCII STRING
;AT EXIT:
; (R0) = END OF UNPACKED TEXT

UNPTIM:	SAVREG			;SAVE ALL REGS
	MOV 2(R0),R1		;GET LSB
	MOV (R0),R0		;GET MSB
	MOV #60,R3		;RADIX
	CALL DIV60		;GET RID OF TICKS
	CALL DIV60		;GET SECONDS IN R5
	CLR -(SP)		;STOPPER FOR DIGIT DUMPER
	MOV R5,-(SP)		;SAVE SECONDS
	CALL DIV60		;GET MINUTES IN R5
				;  AND HOURS IN R1
	MOV R5,-(SP)		;SAVE MINUTES
	MOV #24,R3		;ASSURE MIDNIGHT ROLLOVER
	CALL DIV60		;GET HOURS IN R5
8$:	MOVB R5,(R2)+		;HOURS/MINUTES/SECONDS
	SWAB R5
	MOVB R5,(R2)+
	MOVB #':,(R2)+		;SEPERATOR
	MOV (SP)+,R5		;NEXT PAIR
	BNE 8$			;CONTINUE
	MOVB #' ,-(R2)		;CLOBBER LAST :
	MOV R2,R0		;PASS BACK UPDATED POINTER
	RET			;DONE

DIV60:	CALL DDIV		;DO DOUBLE PRECISION DIVIDE
1$:	ADD #^O366,R5		;ADD MAGIC NUMBER TO
	TSTB R5			;  REMAINDER IN ASCII
	BPL 1$
	ADD #"00-^O366,R5	;CORRECT THEM
	SWAB R5			;L <=> M
	MOV #60,R3		;SET RADIX FOR NEXT TIME
	RET			;DONE

DDIV:	MOV #31,-(SP)		;BIT COUNTER
	CLR R5			;REMAINDER

1$:	ASL R1			;LSB 'S
	ROL R0			;MSB'S
	ROL R5			;REMAINDER
	CMP R5,R3		;ROOM?
	BLO 2$			;NOPE
	SUB R3,R5		;TAKE IT
	INC R1			;ACCUMULATE QUOTIENT
2$:	DEC (SP)		;COUNT
	BPL 1$			;CONTINUE
	TST (SP)+		;PURGE STACK
	RET			;DONE
	.PAGE
	.SBTTL UNPDAT Convert date code to ASCII

;AT ENTRY:
; (R0) = DATE CODE
; (R2) = POINTS TO PLACE TO PUT ASCII
;AT EXIT:
; (R0) = POINTS TO END OF TEXT

UNPDAT:	SAVREG			;SAVE ALL REGS
	MOV #2,DNCDIG		;OUTPUT AT LEAST 2 DECIMAL DIGITS
	MOV #9,R1		;PREPARE OUTPUT PLACE
	MOV R2,R3
2$:	MOVB #' ,(R3)+		;BLANK FILL AREA
	SOB R1,2$
	MOV R0,R1		;GET DATE
	BNE 1$			;ONE PRESENT. PROCEED
	MOV R3,R0		;PASS BACK POSITION
	RET			;AND EXIT

1$:	MOV R1,-(SP)		;SAVE CODE
	ASL R1			;MOVE DAY BITS AROUND
	ROL R1
	ROL R1
	SWAB R1
	BIC #-32,R1		;NUMBER TO CONVERT
	CALL DNC		;CONVERT TO DECIMAL
	MOVB #'-,(R2)+		;SEPERATOR
	MOV (SP),R1		;RETRIEVE DATE CODE
	SWAB R1			;GET MONTH BITS
	BIC #^O177703,R1
	ADD #MONTBL-4,R1	;POINT TO MONTH STRING
	CALL MOVBYT		;MOVE IN MONTH
	MOVB #'-,(R2)+		;SEPERATOR
	MOV (SP)+,R1		;RETRIEVE DATE CODE
	BIC #-32,R1		;ISOLATE YEAR CODE
	ADD #72,R1		;+ OFFSET
	CALL DNC		;YEAR
	MOV R2,R0		;POSITION
	RET			;DONE

DNCDIG: .WORD 2

DNC::	MOV #10,R3		;RADIX 10
	
DNCF::	MOV R2,-(SP)		;RECORD STARTING POSITION
	CALL 10$		;CONVERT NUMBER
	MOV (SP),R0
	NEG R0		
	ADD R2,R0		;COMPUTE LENGTH OF ANSWER
	MOV DNCDIG,-(SP)
	SUB R0,(SP)		;IS THERE ENOUGH?
	BLE 9$			;YEP
	MOV R2,R1		;RECORD CURRENT POSITION
	ADD (SP),R2		;POSITION TO S/B END
	MOV R2,(SP)		;KEEP A COPY OF THE END POINTER
2$:	MOVB -(R1),-(R2)	;MOVE THE STRING TO THE RIGHT N BYTES
	SOB R0,2$
4$:	MOVB #'0,-(R2)		;PREFIX 0'S
	CMP R2,2(SP)		;ARE WE AT THE BEGINNING?
	BHI 4$			;NOPE, KEEP FILLING
	MOV (SP)+,R2		;RESTORE R2
	TST (SP)+		;PURGE STACK
	RET			;AND EXIT
9$:	CMP (SP)+,(SP)+		;PURGE STACK
	RET			;AND EXIT

10$:	CLR R0			;OTHER RADICES ENTER HERE
	DIV R3,R0		;COMPUTE (R0,R1)/R3
	MOV R1,-(SP)		;SAVE REMAINDER
	MOV R0,R1		;PUT QUOTIENT INTO DIVIDEND
	BEQ 20$			;END
	CALL 10$		;RECURSE
20$:	MOV (SP)+,R1		;RETRIEVE NUMBER
	ADD #'0,R1
	CMP R1,#'9		;A-F?
	BLE 30$			;NOPE
	ADD #'A-<'9+1>,R1	;ADJUST IT
30$:	MOVB R1,(R2)+		;PASS CHAR
	RET			;EXIT
	.PAGE
	.SBTTL ROLL HANDLERS

SETROL::MOV R0,ROLNDX		;KEEP ROLL POINTER
SETROF:	MOV (SP)+,R0		;GET RETURN ADDRESS
	SAVREG			;SAVE ALL THE REGISTERS
	MOV ROLNDX,R5		;GET INDEX
	MOV ROLBAS(R5),R1	;CURRENT BASE
	MOV ROLTOP(R5),R2	;CURRENT TOP
	MOVB ROLSIZ(R5),R3	;ENTRY SIZE (IN BYTES)
	MOV #SYMBOL,R4		;POINT TO WORK REGION
	JMP (R0)		;GO TO PROPER ROUTINE

	ENTSEC IMPURE
ROLNDX:	.BLKW
ROLPNT:	.BLKW
ROLUPD:	.BLKW
ROLENT:	.BLKW
	XITSEC

ZAP::	CALL SETROL		;SET THE REGISTERS
	MOV R1,ROLTOP(R5)	;MAKE TOP = BOTTOM
	CLRB ROLSIZ+1(R5)	;CLEAR ENTRY COUNT
	RET

SEARCH::CALL SETROL		;SET THE REGISTERS
	MOV R3,-(SP)		;SAVE ENTRY SIZE
	SUB R3,R1		;POINT 1 SLOT LOW
	MOV R2,R3		;GET TOP
	SUB R1,R3		;COMPUTE SIZE OF ROLL IN BYTES
	CLR R0			;COMPUTE SEARCH OFFSET
	SEC			;   (R0 IS ALSO A T/F FLAG)

1$:	ROL R0			;SHIFT BIT
	BIC R0,R3		;CLEAR CORRESPONDING BIT
	BNE 1$			;NOT LAST ONE
	MOV (SP),R3		;GET ENTRY SIZE IN BYTES
	ASR R3			;/4
	ASR R3

2$:	ADD R0,R1		;COMPUTE POSITION OF TEST ENTRY

3$:	ASR R0			;HALVE OFFSET
	BIC R3,R0		;END?
	BEQ 7$			;YEP. EXIT FALSE

4$:	CMP R2,R1		;RUN OFF THE END OF THE ROLL?
	BLOS 6$			;YES, GO BACK UP
	CMP (R4),(R1)		;FIRST WORD MATCH?
	BNE 5$			;NOPE
	CMP 2(R4),2(R1)		;SECOND WORD MATCH?
	BEQ 8$			;YES. EXIT TRUE

5$:	BHI 2$			;GO THE OTHER WAY

6$:	SUB R0,R1		;BACK DOWN
	BR 3$			;AND CONTINUE

7$:	ADD R3,R1		;FIX POINTER
	ADD R3,R1
8$:	MOV (SP)+,R3		;RESTORE ENTRY SIZE
	BR SCANX		;EXIT THROUGH SCAN ROUTINE
	.PAGE
NEXT::	CALL SETROL		;SET UP REGISTERS
	MOV ROLUPD,R0		;GET ENTRY #
	ADD R0,R1		;COMPUTE ACTUAL ADDRESS
	ADD R3,R0		;+1 ENTRY
	INC ROLENT		;COUNT ENTRY
	CMP R1,R2		;AT THE TOP?
	BLO SCANX		;NOPE. JUST EXIT
	BR SCANXF		;YEP. EXIT FALSE

SCANC::	CALL SETROL		;SAVE/SET-UP REGS
	MOV ROLUPD,R0		;GET POINTER TO NEXT ENTRY
	ADD R0,R1		;UPDATE CURRENT POSITION
	BR SCCE			;CONTINUE SCANNING

SCAN::	CALL SETROL		;LINEAR ROLL SEARCH. SET REGISTERS
	CLR R0			;ASSUME FALSE
	CLR ROLENT		;ENTRY NUMBER

SCCE:
1$:	CMP R2,R1		;AT THE TOP?
	BLOS SCANXF		;YEP
	ADD R3,R0
	INC ROLENT
	CMP (R4),(R1)		;MATCH?
	BNE 2$			;NOPE
	CMP 2(R4),2(R1)		;MATCH?
	BEQ SCANX		;YEP. EXIT TRUE

2$:	ADD R3,R1		;INCREMENT TO NEXT ENTRY
	BR 1$			;AND CONTINUE

	.ENABL LSB
SCANXF::CLR R0			;FALSE CODE
SCANX::	MOV R1,ROLPNT		;SAVE ENTRY POINTER
	MOV R0,ROLUPD		;SAVE ENTRY INDEX (0 IF FALSE)
	BEQ 1$			;NOT FOUND

SCANY:	MOV R4,R2		;POINTER TO 'SYMBOL'
	NEG R3			;NEGATE ENTRY SIZE
	JMP XMIT0(R3)		;COPY THE REST OF THE ENTRY

1$:	CMP (R4)+,(R4)+		;SKIP THE SYMBOL
	ASR R3			;COMPUTE WORD COUNT
	SUB #2,R3		;-2 FOR SYMBOL
	BLE 3$			;TINY ROLL ENTRY SIZE. JUST EXIT

2$:	CLR (R4)+		;CLEAR REMINDER OF ENTRY
	DEC R3
	BGT 2$

3$:	RET
	.DSABL LSB
	.PAGE
SCANWC:: CALL SETROL		;SAVE/SET-UP REGS
	MOV ROLUPD,R0		;GET POINTER TO NEXT ENTRY
	ADD R0,R1		;UPDATE CURRENT POSITION
	BR SCWCE		;CONTINUE SCANNING

SCANW::
	CALL SETROL		;SAVE/SET UP REGS
	CLR R0
SCWCE:
1$:	CMP R2,R1		;AT TOP?
	BLOS 2$			;YEP. EXIT FALSE
	ADD R3,R0		;COUNT FOR UPD
	CMP (R4),(R1)		;MATCH?
	BEQ 3$			;YEP. EXIT TRUE
	ADD R3,R1		;NEXT ITEM
	BR 1$			;CONTINUE

2$:	CLR R0
3$:	MOV R1,ROLPNT		;SAVE POINTER
	MOV R0,ROLUPD		;SAVE FLAG
	BNE SCANY		;TRUE. GO COPY REST OF DATA
	TST (R4)+		;SKIP FIRST WORD
	ASR R3			;COMPUTE WORD COUNT OF ENTRY
	DEC R3			;-1 FOR SYMBOL
	BLE 4$			;TINY ROLL. JUST EXIT

5$:	CLR (R4)+		;CLEAR REST OF AREA
	SOB R3,5$

4$:	RET

APPEND::
	SETROL			;SET ROLL REGISTERS
	MOV R2,ROLPNT		;POINT TO TOP
	CLR ROLUPD		;PRETEND WE DIDN'T MATCH
	BR INSERF		;GO DO AN INSERT


INSERT::
	CALL SETROF		;SET REGISTERS (EXCEPT ROLNDX)
INSERF:	MOV ROLPNT,R0		;POINTS TO PROPER SLOT
	TST ROLUPD		;WAS SEARCH TRUE?
	BNE 5$			;YEP. JUST COPY DATA IN
	INCB ROLSIZ+1(R5)	;UPDATE ENTRY COUNT
	ADD R3,ROLTOP(R5)	;UPDATE TOP POINTER
	CMP R2,ROLBAS+2(R5)	;GAP BETWEEN ROLLS?
	BLO 5$			;YEP. JUST STUFF IN DATA
	MOV SP,R1		;'FROM' ADDRESS
	SUB R3,SP		;'TO' ADDRESS
	MOV SP,R2
	SUB R1,R0		;COMPUTE BYTE COUNT
	CLC
	ROR R0			;COMPTE WORD COUNT

2$:	MOV (R1)+,(R2)+		;MOVE EVERYTHING DOWN 1 ENTRY
	SOB R0,2$

4$:	SUB R3,ROLBAS(R5)	;DECREMENT ALL THE OTHER POINTERS TOO
	SUB R3,ROLTOP(R5)
	SUB #2,R5		;MORE ROLLS?
	BGE 4$			;YEP. DO THEM ALL

	MOV R2,R0		;POINT TO INSERTION SLOT
5$:	ASR R3			;COMPUTE SIZE IN WORDS OF ENTRY
6$:	MOV (R4)+,(R0)+		;MOVE THE ENTRY IN
	SOB R3,6$
	RET
	.PAGE
DELETE::
	CALL SETROF		;SET REGS (EXCEPT ROLNDX)
	MOV ROLPNT,R0		;POINT TO SLOT
	TST ROLUPD		;MATCH?
	BEQ 1$			;NOPE. NOTHING TO DELETE
	DECB ROLSIZ+1(R5)	;TAKE 1 FROM ENTRY COUNT
	SUB R3,ROLTOP(R5)	;ADJUST UPPER LIMIT
	MOV R0,R1
	ADD R3,R1		;POINT TO NEXT ENTRY
2$:	CMP R1,ROLTOP(R5)	;AT END?
	BHIS 1$			;YEP. DONE
	MOV (R1)+,(R0)+		;MOVE EVERYTHING DOWN 1
	BR 2$

1$:	RET
	.PAGE
	.SBTTL REGISTER SAVE/RESTORE ROUTINE

	ENTSEC IMPURE
STENAB:	.BLKW
	XITSEC

SAVREG::			;CALL THIS ROUTINE WITH A 'JSR R5,SAVREG'
	MOV R4,-(SP)		;SAVE ALL EXCEPT R0 (R5 ALREADY ON STACK)
	MOV R3,-(SP)
	MOV R2,-(SP)
	MOV R1,-(SP)
	MOV R5,-(SP)		;SAVE RETURN ADDRESS
	TST STENAB		;STACK TEST ENABLED?
	BNE 5$			;NOPE
	CMP STLLIM,SP		;ROOM?
	BHIS STOVF		;NOPE
5$:	MOV 10(SP),R5		;RESTORE R5 IN CASE ROUTINE NEEDS IT
	CALL @(SP)+		;CALL BACK THE CALLER
	MOV (SP)+,R1		;RESTORE REGS
	MOV (SP)+,R2
	MOV (SP)+,R3
	MOV (SP)+,R4
	MOV (SP)+,R5
	TST R0			;SET CC'S
	RET			;EXIT

STOVF:	MSGF <Stack underflow while reading >,128
	TFILE			;PRINT THE FILE THAT PRODUCED THE ERROR.

	.SBTTL DATA XMITTER

	.REPT MAXXMT-7
	MOV (R1)+,(R2)+
	.ENDR
XMIT7:	MOV (R1)+,(R2)+
XMIT6:	MOV (R1)+,(R2)+
XMIT5:	MOV (R1)+,(R2)+
XMIT4:	MOV (R1)+,(R2)+
XMIT3:	MOV (R1)+,(R2)+
XMIT2:	MOV (R1)+,(R2)+
XMIT1:	MOV (R1)+,(R2)+
XMIT0:	RET

MOVBYT::
1$:	MOVB (R1)+,(R2)+
	BNE 1$
	TSTB -(R2)
	RET
	.PAGE
	.SBTTL OPTION FILE INPUT
;+
; BEWARE: The radix after this point is OCTAL
;-
	.RADIX 8
;+
; Symbolic character defines.
;-

CH.IOR=	'!
CH.QTM=	'"
CH.HSH=	'#
CH.DOL=	'$
CH.PCT=	'%
CH.AND=	'&
CH.XCL=	''
CH.LP=	'(
CH.RP=	')
CH.MUL=	'*
CH.ADD=	'+
CH.COM=	',
CH.SUB=	'-
CH.DOT=	'.
CH.DIV=	'/
CH.COL=	':
CH.SMC=	';
CH.LAB=	'<
CH.EQU=	'=
CH.RAB=	'>
CH.QM=	'?
CH.IND=	'@
CH.BSL=	'\
CH.UAR=	'^

LET.A=	'A
LET.B=	'B
LET.C=	'C
LET.D=	'D
LET.E=	'E
LET.F=	'F
LET.G=	'G
LET.H=	'H
LET.O=	'O
LET.X=	'X
LET.Z=	'Z

DIG.0=	'0
DIG.9=	'9

TAB=	11
LF=	12
VT=	13
FF=	14
CR=	15
SPACE=	40

MODE   = SYMBOL + 4.
SECTOR = SYMBOL + 5.
VALUE  = SYMBOL + 6.
RELLVL = SYMBOL + 8.

.MACRO	ERROR ARG,FLAG
   .IF NB,<FLAG>
	MOV	#ERR.'ARG'+^O100000,R0
   .IFF
	MOV	#ERR.'ARG',R0
   .ENDC
	CALL	STMERR
	.ENDM

.MACRO	SR1234		;SAVE REGS 1,2,3 AND 4
	JSR R4,SR1234
	.ENDM

.MACRO	GCHTBL	CHAR,	ADDR	;GEN CHARACTER SCAN TABLE
	.WORD	ADDR,	CHAR
	.ENDM

	.sbttl OPTIONS Option file(s) handler

	ENTSEC	IMPURE
OPTFLG:	.BLKW
OPTLIN:	.BLKW
CRADIX:	.BLKW
OUTRDX:	.BLKW
CHRPNT:	.BLKW
DEFRAD:	.BLKW
SYMBEG:	.BLKW
	XITSEC

SR1234:	MOV R3,-(SP)		;SAVE ALL EXCEPT R0 AND R5 (R4 ALREADY ON STACK)
	MOV R2,-(SP)
	MOV R1,-(SP)
	MOV R4,-(SP)		;SAVE RETURN ADDRESS
	TST STENAB		;STACK TEST ENABLED?
	BNE 5$			;NOPE
	CMP STLLIM,SP		;ROOM?
	BLO 5$			;YEP
	JMP STOVF		;ELSE TAKE ERROR OUT
5$:	MOV 8.(SP),R4		;RESTORE R4 IN CASE ROUTINE NEEDS IT
	CALL @(SP)+		;CALL BACK THE CALLER
	MOV (SP)+,R1		;RESTORE REGS
	MOV (SP)+,R2
	MOV (SP)+,R3
	MOV (SP)+,R4
	TST R0			;SET CC'S
	RET			;EXIT

	.ENABL LSB
OPTION::
.IIF NE,DEB$,MSG <Options files interpreting>
	MOV	#1,OPTFLG	;SAY TO READ OPTION FILES
5$:	CALL	GETLIN		;GET A LINE OF OPTION STUFF
	BNE	10$		;GOT ONE
	CLR	OPTFLG		;DONE WITH OPTION FILES
	RET			;EOF ON ALL FILES

10$:	TST	OPTLIN		;THIS THE FIRST ONE?
	BNE	20$		;NOPE
	PRINT	#OPTLIN		;START WITH A BLANK LINE
	INC	OPTLIN		;AND SIGNAL WE GOT IT
20$:	CALL	STMNT		;PROCESS STATEMENT
	CALL	ENDLIN		;FINISH OFF THE LINE
.IIF NE,DEB$,MSG <Next option line>
	BR	5$		;AND CONTINUE
	.DSABL LSB
	.SBTTL OPTION LINE ERROR DISPLAY
STMERR:	SR1234			;SAVE ALL THE REGS
	MOV	SYMBEG,R1	;GET STARTING POSITION OF STRING IN ERROR
	MOV	R0,R5		;KEEP A COPY OF THE ERROR MESSAGE ADDRESS
	BPL	5$		;USE SYMBEG
	MOV	CHRPNT,R1	;ELSE USE CURRENT POSITION
5$:	BIC	#100000,R5	;ZAP THE FLAG BIT
	TST	LINERR		;ANY ERRORS THIS LINE ALREADY?
	BNE	10$		;YEP, NOT NECESSARY TO DUMP THE LINE AGAIN
	MOV	SP,TTKEY	;SIGNAL THIS GOES TO TT: TOO
	PRINT	#RBUFF,#2	;PRINT THE LINE IN ERROR
10$:	SUB	#LINBUF,R1	;COMPUTE PLACE OF ERROR
	ADD	#LEB,R1		;INDEX INTO ERROR BUFFER
	MOVB	#'^,(R1)+	;STUFF IN A "^" TO MARK THE SPOT
	CLRB	(R1)		;TERMINATE THE BUFFER
	MOV	SP,TTKEY	;SIGNAL THIS GOES TO TT: TOO
	PRINT	#LEB		;DISPLAY IT
	MOVB	#' ,(R1)	;FIX UP THE ERROR BUFFER FOR NEXT TIME
	MOVB	(R1),-(R1)	; (BOTH THE ^ AND 0)
	MOV	SP,TTKEY	;SIGNAL THIS GOES TO TT: TOO
	PRINT	R5		;DISPLAY THE ERROR MESSAGE
	INC	LINERR		;COUNT THE LINE IN ERROR
	RET			;AND EXIT

	ENTSEC	MSGS
ERR.A:	.ASCIZ \?LINKM-E-Address/expression error\
ERR.I:	.ASCIZ \?LINKM-E-Invalid character\
ERR.Q:	.ASCIZ \?LINKM-E-Questionable syntax\
ERR.T:	.ASCIZ \?LINKM-E-Value overflowed 65535 (truncation error)\
ERR.N:	.ASCIZ \?LINKM-E-Number inconsistant with current radix.\
ERR.U:	.ASCIZ \?LINKM-E-Undefined symbol\
	XITSEC

	.SBTTL GETLIN Input processor

GETLIN:	SR1234			;GET AN INPUT LINE
	MOV	#IMPLIN,R0
	MOV	#IMPLEN-IMPLIN/2,R1
1$:	CLR	(R0)+
	SOB	R1,1$		;CLEAR LINE ORIENTED VARIABLES
	CALL	20$		;GET A RECORD
	TST	R0		;EOF?
	BEQ	15$		;EXIT IF .EQ. 0
	MOV	#LINBUF,R2	;LINE BUFFER
	MOV	#RBUFF,R1	;RECORD BUFFER
;.IIF NE,DEB$,.PRINT R1
	MOV	R2,CHRPNT	;START AT BEGINNING OF LINE
	BR	6$

5$:	MOVB	R5,(R2)+	;MOVE INTO LINBUF
6$:	MOVB	(R1)+,R5	;FETCH NEXT CHAR
	MOVB	CTTBL(R5),R0	;GET CHARACTERISTICS
	BEQ	7$		;QUESTIONABLE
	BIT	#CT.LC,R0	;LOWER CASE?
	BEQ	5$		;  NO
	BIS	#200,R5		;YES, END UP WITH "200 + LC"
	BR	5$		;STORE

7$:	MOVB	R5,(R2)		;QUESTIONABLE, ASCIZ NULL?
	BEQ	10$		;  YES, ALL SET
	MOVB	#CH.QM,-1(R1)	;SUBSTITUTE A "?" IN RBUFF
	MOV	#200,R5		;STORE ZERO WITH FLAG BIT
	BR	5$

10$:	CALL	SETNB
	MOV	SP,R0		;RETURN WITH NON-ZERO TO INDICATE DATA PRESENT
15$:	RETURN

20$:	MOV	#RBUFF,R2
	CLR	R1
	CLR	SAEOF		;EOF IS OK TIL WE FIND CHAR
30$:	CALL	GETBYT		;GET A BYTE FROM OPTIONS FILE
	BEQ	30$		;SKIP NULLS
	CMP	R0,#LF		;END OF LINE?
	BEQ	50$		;YEP
	CMP	R0,#CR		;CR?
	BEQ	30$		;YEP, IGNORE THEM
	CMP	R2,#RBUFF+131.	;ROOM FOR CHAR?
	BHIS	30$		;NOPE, IGNORE THE REST
	MOV	SP,SAEOF	;EOF NOW IS BAD
	MOVB	R0,(R2)+	;PUT CHAR IN BUFFER
	BR	30$		;CONTINUE

50$:	CLRB	(R2)		;RECORD TERMINATOR
	SUB	#RBUFF,R2	;COMPUTE LENGTH
	BEQ	20$		;BLANK LINE, KEEP LOOKING
	RETURN

	.SBTTL ENDLIN End of line processor

ENDLIN:				;END OF LINE PROCESSOR
	TSTB	CTTBL(R5)	;EOL OR SEMI-COLON?
	BLE	1$		;  YES
	ERROR	Q,1		;QUESTIONABLE SYNTAX
1$:	TST	LINERR		;ANY ERRORS ON THIS LINE?
	BNE	10$		;YEP, WE'VE ALREADY DUMPED THE LINE
	PRINT	#RBUFF		;ELSE PRINT THE RECORD TOO
10$:	RETURN

	ENTSEC	IMPLIN
LINBUF:	.BLKB	132.
LINEND:	.BLKW	1
LINERR: .BLKW	1
SECSIZ: .BLKW	1	
	XITSEC

	ENTSEC	PURE
LEB:	.REPT 132./4.
	.BYTE SPACE,SPACE,SPACE,SPACE
	.ENDR
	XITSEC

	.SBTTL	STATEMENT PROCESSOR

STMNT:	CALL	GETSYM
	BEQ	20$
	SCAN	PSTROL
	BEQ	40$
	CLR	R3
	JMP	@SYMBOL+4	;GO TO FUNCTION

20$:	CALL	SETSYM		;RESET CHAR POINTER AND FLAGS
	TSTB	CTTBL(R5)
	BLE	42$		;NULL IF END OF LINE

40$:	ERROR	U		;UNDEFINED STATMENT
42$:	RETURN

.MACRO PST NAME,ADDR
	.RAD50 \NAME\
	.WORD ADDR
	.ENDM

PSTBAS:
	PST <GLOBL >,.GLOBL	;THESE MUST BE IN ALPHABETICAL
	PST <PSECT >,.PSECT	;  ORDER
	PST <RADIX >,.RADIX
	PST <SYMBOL>,.GLOBL
	PST <.GLOBL>,.GLOBL
	PST <.PSECT>,.PSECT
	PST <.RADIX>,.RADIX
	PST <.SYMBO>,.GLOBL
PSTTOP:
	.PAGE
	.SBTTL .GLOBL/.PSECT DIRECTIVES
.GLOBL:	INC	R3		;SIGNAL GLOBAL PROCESSING
.IIF NE,DEB$,MSG <Got to .GLOBL routine>
.PSECT:
.IIF NE,DEB$,MSG <Got to .PSECT routine>
5$:	CALL	TSTARG		;ANY ARGUMENTS?
	BNE	10$		;YEP
	RETURN			;NOPE, DONE

10$:	TST	R3		;MESSING WITH PSECTS?
	BNE	12$		;NOPE, SKIP THIS STUFF
	CLR	SECSIZ		;ASSUME NOT TO CHANGE PSECT SIZE
	CMPB	R5,#'^		;IS IT AND ^S?
	BNE	12$		;NOPE
	CALL	GETNB		;MAYBE, SKIP THE ^
	CMPB	R5,#'S		;S?
	BNE	15$		;NOPE, ERROR OUT
	INC	SECSIZ		;ELSE SAY WE'RE GONNA CHANGE THE SECTION SIZE
12$:	CALL	GETSYM		;TRY FOR A SYMBOL NAME
	BNE	20$		;GOT ONE
15$:	ERROR	U		;ELSE ERROR EXIT
	RET

20$:	CMPB	R5,#'=		;FOLLOWED BY EQUAL?
	BEQ	30$		;YEP
	CMPB	R5,#':		;OR COLON?
	BEQ	30$		;YEP
	ERROR	A		;ELSE GIVE 'EM AN ERROR
	RET

30$:	TST	R3		;.GLOBL?
	BNE	32$		;YEP
	SCAN	SECROL		;.PSECT, LOOK IN SECTION ROLL
	BR	33$	
32$:	SEARCH	SYMROL		;LOOK IN THE SYMBOL TABLE FOR SYMBOL
33$:	BEQ	15$		;NOT THERE, ERROR OUT
	CALL	GETNB		;SKIP THE = OR :
	MOV	#SYMBOL+2,R1	;POINT TO SYMBOL SPACE
	MOV	(R1),-(SP)	;SAVE THE SYMBOL
	MOV	-(R1),-(SP)
	CALL	EXPR		;EVALUATE EXPRESSION
	MOV	(SP)+,(R1)+	;RESTORE SYMBOL
	MOV	(SP),(R1)+
	MOV	VALUE,(SP)	;SAVE THE VALUE CALCULATED
	TST	R3		;.GLOBL?
	BNE	40$		;YEP
	SCAN	SECROL		;LOOK AGAIN FOR SECTION NAME
	TST	SECSIZ		;ARE WE TO CHANGE THE SECTION SIZE?
	BEQ	35$		;NOPE
	MOV	(SP)+,R0	;GET THE VALUE
	CMP	(R1)+,(R1)+	;ADVANCE TO SECTION SIZE
	CMP	R0,(R1)		;
	BLOS	5$		;CAN'T MAKE IT SMALLER THAN IT ALREADY IS
	MOV	R0,(R1)		;CAN MAKE IT BIGGER THOUGH
	BR	46$
35$:	BIS	#S.FORC,(R1)+	;SIGNAL FORCED OFFSET
	MOV	(SP)+,(R1)	;PASS VALUE
	INSERT			;PUT ENTRY IN SECROL
	MOV	ROLPNT,R2	;POINT TO CURRENT SECROL ENTRY
38$:	MOV	ROLPNT,R1	;POINT TO CURRENT SECROL ENTRY
	ADD	#RS.SEC*2,R2	;BUMP TO NEXT
	CMP	R2,ROLTOP+SECROL ;AT THE UPPER LIMIT?
	BHIS	5$		;YEP, DONE
	MOV	R2,R0
	CMP	(R1)+,(R0)+	;NAMES MATCH?
	BNE	5$		;NOPE, DONE
	CMP	(R1)+,(R0)+	;?
	BNE	5$		;NOPE
	BISB	#S.FORC,(R0)	;ELSE SET THE FORCED BIT IN THE TABLE TOO
	BR	38$

40$:	SEARCH	SYMROL		;GET THE SYMBOL
	MOV	#256.+S.DEF,(R1)+ ;MAKE SURE ITS ABSOLUTE
45$:	MOV	(SP)+,(R1)	;COPY IN THE VALUE
46$:	INSERT			;UPDATE TABLE
	BR	5$		;AGAIN

	.SBTTL .RADIX directive

.RADIX:
.IIF NE,DEB$,MSG <Got to .RADIX routine>
	CALL	TSTARG		;CHECK FOR ARG
	BNE	10$		;GOT ONE
5$:	MOV	DEFRAD,CRADIX	;SET TO THE DEFAULT
	RET			;ELSE WE'RE DONE

10$:	MOV	#10.,CRADIX	;ASSUME DECIMAL WHILE DOING EXPR
	CALL	EXPR		;EVALUATE EXPRESSION
	MOV	VALUE,R0	;GET THE VALUE
	CMP	R0,#2		;CAN'T BE LESS THAN 2
	BHIS	20$		;OK
15$:	ERROR	A		;ELSE ZAP IT
	BR	5$		;AND CHANGE TO DEFAULT

20$:	CMP	R0,#16.		;CAN'T BE GREATER THAN 16
	BHI	15$		;BAD
	MOV	R0,CRADIX
	RET
	.PAGE
	.SBTTL	SYMBOL/CHARACTER HANDLERS

GETSYM:	SR1234
	MOV	CHRPNT,SYMBEG	;SAVE IN CASE OF RESCAN
	MOV	#SYMBOL+4,R1
	CLR	-(R1)
	CLR	-(R1)
	BITB	CTTBL(R5),#CT.ALP	;ALPHA?
	BEQ	5$		;  NO, EXIT FALSE
	MOV	#26455,R2	
	CALL	SETR50
1$:	CALL	MULR50
2$:	ASR	R2
	BCS	1$
	ADD	R0,(R1)
3$:	CALL	GETR50
	BLE	4$
	ASR	R2
	BCS	2$
	BEQ	3$
	TST	(R1)+
	BR	1$

4$:	CALL	SETNB
5$:	MOV	SYMBOL,R0
	RETURN


MULR50::			;MULTIPLY R0 * 50
	IMULI	50,R0
	RETURN
	.PAGE
GETR50:	CALL	GETCHR
SETR50:	MOV	R5,R0
TSTR50:	BITB	#CT.ALP!CT.NUM!CT.SP!CT.TAB,CTTBL(R0) ;ALPHA, NUMERIC, TAB, OR SPACE?
	BEQ	1$		;  NO, EXIT MINUS
	CMP	R0,#CH.DOL	;YES, TRY DOLLAR
	BLO	2$		;SPACE
	BEQ	3$		;DOLLAR
	CMP	R0,#LET.A
	BLO	4$		;DOT OR DIGIT
	BR	5$		;ALPHA

1$:	MOV	#100000+SPACE,R0	;INVALID, FORCE MINUS
2$:	SUB	#SPACE-11,R0	;SPACE
3$:	SUB	#11-22,R0	;DOLLAR
4$:	SUB	#22-100,R0	;DOT, DIGIT
5$:	SUB	#100,R0		;ALPHABETIC
	RETURN

CVTNUM:				;CONVERT TEXT TO NUMERIC

				; IN  -  R2    RADIX

				; OUT -  VALUE RESULT
				; R0 - HIGH BIT  - OVERFLOW
				;    - HIGH BYTE - CHARACTER COUNT
				;    - LOW  BYTE - OVERSIZE COUNT


	SR1234
	CLR	R0		;RESULT FLAG REGISTER
	CLR	R1		;NUMERIC ACCUMULATOR
10$:	MOV	CHRPNT,SYMBEG	;SAVE FOR RESCAN
1$:	MOV	R5,R3		;GET A COPY OF THE CURRENT CHAR
	SUB	#DIG.0,R3	;CONVERT TO ABSOLUTE
	CMP	R3,#9.		;NUMERIC?
	BLOS	11$		;ITS OK
	SUB	#7.,R3		;A-F
	CMP	R3,#10.		;TOO SMALL?
	BLO	9$		;YEP
	CMP	R3,#16.		;TOO BIG?
	BHIS	9$		;YEP
11$:	CMP	R3,R2		;YES, LESS THAN RADIX?
	BLO	2$		;  YES
	INC	R0		;NO, BUMP "N" ERROR COUNT
2$:	MOV	R2,R4		;COPY OF CURRENT RADIX
	CLR	-(SP)		;TEMP AC
3$:	ASR	R4		;SHIFT RADIX
	BCC	4$		;BRANCH IF NO ACCUMULATION
	ADD	R1,(SP)		;ADD IN
4$:	TST	R4		;ANY MORE BITS TO PROCESS?
	BEQ	5$		;  NO
	ASL	R1		;YES, SHIFT PATTERN
	BCC	3$		;BRANCH IF NO OVERFLOW
	BIS	#100000,R0	;OH, OH.  FLAG IT
	BR	3$

5$:	MOV	(SP)+,R1	;SET NEW NUMBER
	ADD	R3,R1		;ADD IN CURRENT NUMBER
	ADD	#000400,R0	;TALLY CHARACTER COUNT
	CALL	GETCHR		;GET ANOTHER CHARACTER
	BNE	1$		;CONTINUE IF NOT EOL

9$:	MOV	R1,VALUE	;RETURN  RESULT IN "VALUE"
	BISB	#S.DEF,FLAGS	;PASS DEFINED FLAG
	RETURN			;RETURN, TESTING R0


GSARG:
TSTARG:				;TEST ARGUMENT
1$:	CALL	SETNB		;GET THE NEXT NON-BLANK CHAR
	MOVB	CTTBL(R5),R0	;GET CHARACTERISTICS
	BLE	12$		;THROUGH IF EOL OR SEMI-COLON
	BIT	#CT.COM,R0	;NO, COMMA?
	BNE	10$		;  YES, BYPASS IT
	TST	ARGCNT		;IS THIS THE FIRST ARGUMENT?
	BEQ	11$		;  YES, GOOD AS IS
	CMP	CHRPNT,ARGPNT	;DID ANYBODY USE ANYTHING?
	BNE	11$		;  YES, OK
3$:	CALL	GETCHR		;NO, BYPASS TO AVOID LOOPS
	BITB	#CT.PC+CT.SP+CT.TAB-CT.COM-CT.SMC,CTTBL(R5)
	BNE	3$		;  YES, BYPASS
	BR	1$		;NOW TRY AGAIN

10$:	CALL	GETNB		;BYPASS COMMA
	MOVB	CTTBL(R5),R0	;GOT A NEW CHAR, GET NEW FLAGS
11$:	INC	ARGCNT		;INCREMENT ARGUMENT COUNT
12$:	CLR	EXPFLG
	MOV	CHRPNT,ARGPNT	;SAVE POINTER
	BIC	#177600,R0	;SET FLAGS
	RETURN


	ENTSEC	IMPLIN		;CLEAR EACH LINE
ARGCNT:	.BLKW			;ARGUMENT COUNT
ARGPNT:	.BLKW			;START OF LAST ARGUMENT
EXPFLG:	.BLKW			;SET WHEN COMMA REQUIRED
	XITSEC
	.PAGE
CT.EOL=	000		; EOL
CT.COM=	001		; COMMA
CT.TAB=	002		; TAB
CT.SP=	004		; SPACE
CT.PCX=	010		; PRINTING CHARACTER
CT.NUM=	020		; NUMERIC
CT.ALP=	040		; ALPHA, DOT, DOLLAR
CT.LC=	100		;  LOWER CASE ALPHA
CT.SMC=	200		;  SEMI-COLON  (MINUS BIT)

CT.PC=	CT.COM!CT.SMC!CT.PCX!CT.NUM!CT.ALP	;PRINTING CHARS

	.MACRO	GENCTT	ARG	;GENERATE CHARACTER TYPE TABLE
	.IRP	A,	<ARG>
	.BYTE	CT.'A
	.ENDM
	.ENDM


	ENTSEC	PURE
CTTBL:				;CHARACTER TYPE TABLE
	GENCTT	<EOL, EOL, EOL, EOL, EOL, EOL, EOL, EOL>
	GENCTT	<EOL, TAB, EOL, EOL, EOL, EOL, EOL, EOL>
	GENCTT	<EOL, EOL, EOL, EOL, EOL, EOL, EOL, EOL>
	GENCTT	<EOL, EOL, EOL, EOL, EOL, EOL, EOL, EOL>

	GENCTT	<SP , PCX, PCX, PCX, ALP, PCX, PCX, PCX>
	GENCTT	<PCX, PCX, PCX, PCX, COM, PCX, ALP, PCX>
	GENCTT	<NUM, NUM, NUM, NUM, NUM, NUM, NUM, NUM>
	GENCTT	<NUM, NUM, PCX, SMC, PCX, PCX, PCX, PCX>

	GENCTT	<PCX, ALP, ALP, ALP, ALP, ALP, ALP, ALP>
	GENCTT	<ALP, ALP, ALP, ALP, ALP, ALP, ALP, ALP>
	GENCTT	<ALP, ALP, ALP, ALP, ALP, ALP, ALP, ALP>
	GENCTT	<ALP, ALP, ALP, PCX, PCX, PCX, PCX, PCX>

	GENCTT	<EOL, LC , LC , LC , LC , LC , LC , LC >
	GENCTT	<LC , LC , LC , LC , LC , LC , LC , LC >
	GENCTT	<LC , LC , LC , LC , LC , LC , LC , LC >
	GENCTT	<LC , LC , LC , PCX, PCX, PCX, PCX, EOL>

	XITSEC

SETSYM:				;SET SYMBOL FOR RE-SCAN
	MOV	SYMBEG,CHRPNT	;SET THE POINTER
	BR	SETCHR		;SET CHARACTER AND FLAGS

GETNB:				;GET A NON-BLANK CHARACTER
	INC	CHRPNT		;BUMP POINTER
SETNB::	CALL	SETCHR		;SET REGISTER AND FLAGS
	BITB	#CT.SP!CT.TAB,CTTBL(R5)	;BLANK?
	BNE	GETNB		;  YES, BYPASS
	BR	SETCHR		;EXIT, SETTING FLAGS

GETCHR::			;GET THE NEXT CHARACTER
	INC	CHRPNT		;BUMP POINTER
SETCHR::MOVB	@CHRPNT,R5	;SET REGISTER AND FLAGS
	BPL	1$		;OK IF NO SIGN BIT
	SUB	#177600+40,R5	;TRY FOR LOWER CASE MAP
	BGE	1$		;OK IF NOT 0 OR MINUS
	ERROR	I,1		;ELSE FLAG INVALID CHAR
	BR	GETCHR		;LOOP ON INVALID CHARACTER
1$:	RETURN

CHSCAN:				;CHARACTER SCAN ROUTINE
1$:	TST	(R0)+		;END (ZERO)?
	BEQ	2$		;  YES
	CMP	(R0)+,R5	;THIS THE ONE?
	BNE	1$		;  NO
	TST	-(R0)		;YES, MOVE POINTER BACK
	MOV	CHRPNT,SYMBEG	;SAVE CURRENT POINTER
	CALL	GETNB		;GET NEXT NON-BLANK
2$:	MOV	-(R0),R0	;MOVE ADDR OR ZERO INTO R0
	RETURN

SETXPR:				;SET EXPRESSION REGISTERS
	MOV	#SYMBOL,R1
	MOV	#SECTOR,R2
	MOV	#MODE,R3
	MOV	#VALUE,R4
	RETURN

; **-EXPR-EXPRESSION EVALUATION

EXPR::	SR1234			;SAVE REGISTERS
EXPI:	CALL	TERMI		;++023 GET FIRST TERM
	TST	R0		;++023 TEST RESULT
	BEQ	5$		;EXIT IF NULL
1$:	CALL	SETXPR		;SET EXPRESSION REGISTERS
	CHSCAN	BOPTBL		;SCAN THE BINARY OPERATOR TABLE
	BEQ	2$		;  BRANCH IF NOT FOUND
	CALL	10$		;FOUND, CALL HANDLER
	BR	1$		;TEST FOR MORE

2$:
6$:	TST	RELLVL		;TEST RELOCATON LEVEL
	BEQ	4$		; OK IF 0
	ERROR	A		;NOT ALLOWED
4$:
	MOV	SP,R0		;SET TRUE
5$:	RETURN

10$:	MOV	R0,-(SP)	;++001 STACK OPERATOR ROUTINE ADDRESS
	MOV	(R1)+,-(SP)	;STACK SYMBOL
	MOV	(R1)+,-(SP)
	MOV	(R1)+,-(SP)	;  MODE,
	MOV	(R1)+,-(SP)	;  VALUE,
	MOV	(R1)+,-(SP)	;  AND REL LEVEL
	CALL	TERMI		;++024 GET NEXT TERM
	MOV	#EXPBAK+10.,R3	;++024 POINT TO EXPRESSION SCRATCH AREA
	MOV	(SP)+,-(R3)	;++024 UNSTACK PREVIOUS RELOCATION LEVEL
	MOV	(SP)+,-(R3)	;++024 		VALUE,
	MOV	R3,R2		;++024 LEAVE R2 POINTING TO PREVIOUS VALUE
	MOV	(SP)+,-(R3)	;++024 		MODE (FLAG & PSECT)
	MOV	(SP)+,-(R3)	;++024		AND SYMBOL.
	MOV	(SP)+,-(R3)	;++024
	CMPB	-(R2),-(R4)	;++019 ARE PSECT'S THE SAME?
	BEQ	100$		;++019 YES, PSECT TEST SUCCESS
	TSTB	(R2)		;++019 ELSE, IS FIRST VALUE A CONSTANT?
	BEQ	100$		;++019 YES, PSECT TEST SUCCESS
	TSTB	(R4)		;++019 ELSE, IS SECOND VALUE A CONSTANT?
	BEQ	100$		;++019 YES, PSECT TEST SUCCESS
	ERROR	A		;NOPE, ERROR U CAN'T DO COMPLEX IN COMPLEX

100$:	CMPB	(R2)+,(R4)+	;++019 RESTORE REGISTERS
	BIS	-(R2),-(R4)	;MERGE ATTRIBUTES AND PSECT NUMBERS
	CMP	(R2)+,(R4)+	;RESTORE REGISTERS
	JMP	@(SP)+		;DISPATCH TO BINARY OPERATOR FUNCTION

	ENTSEC	IMPLIN
EXPBAK:	.BLKW	5
ERRSTK:	.BLKW	1
EXPFGS::.BLKW	1
	XITSEC

	ENTSEC	PURE		;++017
BOPTBL:				;BINARY OP TABLE
	GCHTBL	CH.ADD,	BOPADD  ; "+" ADD
	GCHTBL	CH.SUB,	BOPSUB  ; "-" SUB
	GCHTBL	CH.MUL,	BOPMUL	; "*" MUL
	GCHTBL	CH.DIV,	BOPDIV	; "/" DIV
	GCHTBL	CH.AND,	BOPAND	; "&" AND
	GCHTBL	CH.IOR,	BOPIOR	; "!" OR
	GCHTBL	CH.QM,	BOPXOR	; "?" XOR
	.WORD	0
	XITSEC

BOPSUB:	NEG	(R4)		; -, NEGATE VALUE
	NEG	RELLVL		;  AND RELLVL
	BR	ADDX		;++001 BRANCH INTO COMMON CODE

BOPADD:
ADDX:	ADD	(R2)+,(R4)+	;++001 + ADD VALUES
	ADD	(R2),(R4)	;  AND RELOCATION LEVELS
	CMP	-(R2),-(R4)	;POINT BACK TO VALUES
	BIT	#177400,-(R2)	;++019 FIRST VALUE CONSTANT?
	BEQ	3$		;++019 YES, CONSIDER ADDITION DONE
	BIT	#177400,-(R4)	;++019 SECOND VALUE CONSTANT?
	BEQ	4$		;++019 YES, USE ATTRIBUTES OF FIRST VALUE
	BISB	(R2),(R4)	;++019 NO CONSTANTS--MERGE ATTRIBUTES
3$:	RETURN

4$:	MOV	(R3)+,(R1)+	;++024 TRANSFER PREVIOUS SYMBOL NAME
	MOV	(R3)+,(R1)+	;++024 
	BIS	(R3)+,(R1)+	;++024 AND MERGE PREVIOUS ATTRIBUTES
	RETURN

BOPAND:	COM	(R2)
	BIC	(R2),(R4)
	RETURN

BOPIOR:	BIS	(R2),(R4)
	RETURN

BOPXOR:	MOV	(R2),-(SP)
	BIC	(R4),(SP)
	BIC	(R2),(R4)
	BIS	(SP)+,(R4)
	RETURN

BOPMUL:	MOV	(R2),R0		;FETCH FIRST ARGUMENT
	MOV	(R4),R3		;SET SECOND ARG
	MUL	R3,R0		;MULTIPLY
	MOV	R1,(R4)		;PASS BACK ANSWER
	RETURN

BOPDIV:	MOV	(R4),R3		;GET DIVISOR
	MOV	(R2),R1		;GET DIVIDEND
	SXT	R0		;SIGN EXTENDED
	DIV	R3,R0		;DIVIDE
	MOV	R0,(R4)		;SET RESULT
	RETURN

	.SBTTL	TERM EVALUATOR

TERM:	SR1234			;SAVE REGISTERS
TERMI:				;++023 REF LABEL FOR INTERNAL ENTRY
	CALL	SETXPR		;  AND SET "EXPRESSION" TYPE
	CLR	(R3)		;CLEAR MODE
	CLR	(R4)		;  AND VALUE
	CALL	TERM10		;PROCESS TERM
	BIC	#^C<S.DEF>,(R3)	;CLEAR EXTRANEOUS
	CLR	RELLVL		;ASSUME ABSOLUTE
	BIT	#S.REL,(R3)	;TRUE?
	BEQ	1$
	INC	RELLVL		;  NO, RELOCATABLE
1$:	INC	EXPFLG		;MARK AS EXPRESSION
	JMP	SETNB		;EXIT WITH NON-BLANK AND R0 SET

TERM10:	CALL	GETSYM		;TRY FOR A SYMBOL
	BEQ	TERM20		;BRANCH IF NOT A SYMBOL
	SEARCH	SYMROL		;SEARCH THE SYMBOL TABLE
	BEQ	16$		;BRANCH IF NOT FOUND
	BIT	#S.DEF,(R3)	;DEFINED?
	BNE	12$		;  YES
16$:	ERROR	U		;NO, UNDEFINED ERROR
12$:	BIC	#^C<S.DEF>,(R3)	;CLEAR UNUSED STUFF
CRFTRM:	BR	TERM28

TERM20:
	MOV	CRADIX,R2	;ASSUME NUMBER, CURRENT RADIX
21$:	CALL	CVTNUM		;CONVERT
	BEQ	TERM30		;  NOPE, MISSED AGAIN
	BPL	22$		;NUMBER, ANY OVERFLOW?
	ERROR	T		;  YES, FLAG IT
22$:	CMP	R5,#CH.DOT	;NUMBER, DECIMAL?
	BEQ	24$		;  YES
	TSTB	R0		;NO, ANY NUMBERS OUT OF RANGE?
	BEQ	TERM28		;  NO
	ERROR	N		;YES, FLAG IT
	CMP	R2,#16.		;HEX?
	BEQ	25$		;YEP. CAN'T DO ANYMORE
	CMP	R2,#10.		;DECIMAL?
	BNE	23$		;TRY AGAIN WITH DECIMAL
	MOV	#16.,R2		;ELSE TRY WITH HEX
	BR	26$

24$:	CMP	R2,#10.		;"." OR "$", WERE WE DECIMAL?
	BEQ	25$		;  YES
23$:	MOV	#10.,R2		;  TRY AGAIN WITH DECIMAL RADIX
26$:	CALL	SETSYM		;RESET POINTERS
	BR	21$

25$:	CMP	R5,#CH.DOT	;DECIMAL?
	BEQ	TERM27		;  YES

TERM26:	ERROR	U		;  NO, FLAG AS UNDEFINED
TERM27:	CALL	GETCHR		;BYPASS DOT OR DOLLAR
TERM28:
ALT28:	CALL	SETNB		;++001 RETURN POINTING TO NON-BLANK
	MOV	SP,R0		;SET NON-ZERO
TERM29:	RETURN

TERM30:	CHSCAN	UOPTBL		;SCAN UNARY OPERATOR TABLE
	BEQ	TERM29		;  NOT THERE
	CLR	R2		;CLEAR FOR FUTURE USE
	CALL	(R0)		;FOUND, GO AND PROCESS
	BR	ALT28		;++001 EXIT TRUE VIA ALTERNATE EXIT

	ENTSEC	PURE		;++017
UOPTBL:
	GCHTBL	CH.ADD,	TERMI	; "+" ++024
	GCHTBL	CH.SUB,	TERM42	; "-"
	GCHTBL	CH.LAB,	TERM47	; "<"
	GCHTBL	CH.UAR,	TERM50	; "^"
	.WORD	0
	XITSEC

TERM42:	MOV	#1,-(SP)	;++001 INDICATE NEGATE BY 1 ON STACK
	BR	COMTRX		;++001 USE COMMON CODE TO PROCESS

TERM47:				;++023 "<"
	CALL	EXPI		;++023 EVALUATE EXPRESSION
	CMP	R5,#CH.RAB	;">"?
	BNE	TERM48		;++001 NO, REPORT ERROR
	CALL	GETCHR		;++001 YES, BYPASS IT
	BR	ALT28		;++001 EXIT

TERM48:	ERROR	A		;NFG
	CLR	R0		;SAY FAIL
	RETURN	
	.PAGE
TERM50:	CHSCAN	UARTBL		;"^"-SCAN ON NEXT CHARACTER
	BEQ	TERM48		;  INVALID, ERROR
	JMP	(R0)		;CALL ROUTINE

	ENTSEC	PURE		;++017
UARTBL:				;UP ARROW TABLE
	GCHTBL	LET.C,	TERM51	;  ^C = COMPLIMENT
	GCHTBL	LET.D,	TERM52	;  ^D = DECIMAL RADIX
	GCHTBL	LET.O,	TERM53	;  ^O = OCTAL RADIX
	GCHTBL	LET.B	TERM54	;  ^B = BINARY RADIX
	GCHTBL	LET.H,	TERM57	;  ^H = HEX RADIX
	GCHTBL	LET.X,	TERM57	;  ^X = HEX RADIX
	GCHTBL	'R,	TERM56	;  ^R = RAD50
	GCHTBL	'S,	TERM58	;  ^S = SECTION SIZE
	.WORD	0
	XITSEC

TERM51:	CLR	-(SP)		;++001 INDICATE COMPLEMENT BY 0 ON STACK
COMTRX:	CALL	TERMI		;++024 GET GLOBAL TERM
	COM	(R4)		;++001 COMPLEMENT VALUE
	ADD	(SP)+,(R4)	;++001 MAKE IT NEGATE IF 1 ON STACK
	NEG	RELLVL		;++001 NEGATE THE RELOCATION LEVEL
	JMP	TERM28

TERM57:	ADD	#6.,R2		;HEX
TERM52:	ADD	#2.,R2		;DECIMAL
TERM53:	ADD	#6.,R2		;OCTAL
TERM54:	ADD	#2.,R2		;BINARY
	MOV	CRADIX,-(SP)	;STACK CURRENT RADIX
	MOV	R2,CRADIX	;REPLACE WITH LOCAL
	CALL	TERMI		;++024 EVALUATE TERM
	MOV	(SP)+,CRADIX	;RESTORE RADIX
	JMP	TERM28

TERM56:				;++022 ^R
	CALL	SETSYM		;++022 BACK UP CHAR PTR TO THE "R"
	MOV	#64,R2		;++022 SET CONTROL MASK IN R2
10$:	CALL	GETR50		;++022 FETCH A RADIX-50 CHAR
	BMI	40$		;++ IF MI, NON-RAD50 CHAR ENCOUNTERED
	TST	R2		;++022 CHECK CONTROL MASK
	BEQ	10$		;++022 IF EQ SKIP CHARS PAST 3
20$:	ASR	R2		;++022 SHIFT CONTROL MASK
	BCS	30$		;++022 IF CS PROPER RAD50 POWER REACHED
	CALL	MULR50		;++022 ELSE, MULTIPLY BY 50
	BR	20$		;++022 REPEAT MULTIPLY LOOP
30$:	ADD	R0,(R4)		;++022 ADD RESULT TO ACCUMULATED VALUE
	BR	10$		;++022 REPEAT FOR 3 RADIX-50 CHARACTERS
40$:	JMP	TERM28

TERM58:	CALL	GETSYM		;TRY FOR A SYMBOL
	BNE	10$		;OK
5$:	ERROR	U		;NFG
	BR	40$

10$:	SCAN SECROL		;LOOK IN THE PSECT ROLL FOR THE NAME
	BEQ	5$		;TWAS'NT THERE
	MOV	SYMBOL+8.,R2	;ACCUMULATE SIZES
20$:	SCANC	SECROL		;GET THE NEXT ONE
	BEQ	30$		;DONE
	ADD	SYMBOL+8.,R2	;ACCUMULATE SIZES
	BR	20$		;UNTIL NO MORE

30$:	CLR	FLAGS		;MAKE SURE ITS SET ABS
	MOV	R2,(R4)		;PASS THE VALUE
40$:	JMP	TERM28		;EXIT TRUE

	ENTSEC ROLBAS
ROLEND:
	.PSECT	IMPURE
IMPEND:
	.PSECT	IMPLIN
IMPLEN:
	XITSEC
	.END START
