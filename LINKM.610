	.TITLE LINKM PDP11 CROSS LINKER FOR MICROPROCESSORS

DEB$ = 0		;.NE. IF DEBUG MODE
DMP$ = 0		;.NE. IF CRASH DUMP REQUESTED AFTER PASS x
VAX$ = 0		;.NE. IF TO RUN ON VAX SYSTEM
EIS$ = 1		;.NE. IF EIS AVAILABLE

	.SBTTL MACRO DEFINITIONS
	.ENABL LC
	.RADIX 10
	.NLIST BEX,CND

.MACRO GTVNUM
	.ASCII \V6.10\
	.ENDM

	.MCALL .CLOSE,.CSISPC,.DATE,.DSTAT,.ENTER
	.MCALL .EXIT,.FETCH,.GTIM,.GTLIN,.HERR
	.MCALL .LOOKUP,.PRINT,.PURGE,.RCTRLO
	.MCALL .READW,.REOPEN,.SAVES,.SERR,.SETTOP
	.MCALL .SRESET,.TTYIN,.TTYOUT,.WRITW

.MACRO ENTSEC ARG
	.SAVE
	.PSECT ARG
	.ENDM

.MACRO XITSEC
	.RESTORE
	.ENDM

.MACRO MSG MESS,LABL,OPT
	ENTSEC <MSGS,D>
...1	=.
...2	=0
	.IIF NB,<OPT>,...2=OPT
	.IIF NB,<LABL>,LABL:
	.ASCII \MESS\
	.BYTE ...2
	XITSEC
	.PRINT #...1
	.ENDM MSG

.MACRO MSGF MESS,OPT
	.PRINT #$FATAL
	MSG ^\MESS\,,OPT
	.ENDM MSGF

.MACRO MSGW MESS,OPT
	.PRINT #$WARN
	MSG ^\MESS\,,OPT
	.ENDM MSGW

	ENTSEC <MSGS,D>
$FATAL::.ASCII \?LINKM-F-\<128.>
$WARN::	.ASCII \?LINKM-W-\<128.>
	XITSEC

.MACRO RET
	RTS PC
	.ENDM

.MACRO SAVREG
	JSR R5,SAVREG
	.ENDM

.MACRO GENCAL OP,IMM
	.IF NB,<IMM>
	.MACRO OP L
	MOV #L,R0
	CALL OP
	.ENDM
	.IFF
   .MACRO OP L
	.IIF NB,<L>,MOV L,R0
	CALL OP
	.ENDM OP
	.ENDC
	.ENDM GENCAL

	GENCAL SEARCH,I
	GENCAL SCAN,I
	GENCAL SCANC,I
	GENCAL SCANW,I
	GENCAL SCANWC,I
	GENCAL CHSCAN,I
	GENCAL NEXT,I
	GENCAL APPEND,I
	GENCAL ZAP,I
	GENCAL INSERT
	GENCAL DELETE
	GENCAL SETROL


.MACRO TFILE ARG
	.IF NB,<ARG>
	MOV ARG,R0
	.IFF
	CLR R0
	.ENDC
	JMP TFILE
	.ENDM

.IF EQ,EIS$
.MACRO DIV S,D
	.IIF DIF,<S>,<R3>,MOV S,R3
	.IIF DIF,<D>,<R0>,.ERROR D ;ILLEGAL DIV ARG
	CALL DIV
	.ENDM

.MACRO MUL S,D
	.IIF DIF,<S>,<R3>,MOV S,R3
	.IIF DIF,<D>,<R0>,.ERROR D ;ILLEGAL MUL ARG
	CALL MUL
	.ENDM

.MACRO SOB R,A
	DEC R
	BNE A
	.ENDM

.MACRO SXT ARG,?LAB1,?LAB2
	BMI LAB1
	MOV #0,ARG	;CAN'T MESS THE CARRY
	BR LAB2
LAB1:	MOV #-1,ARG
LAB2:
	.ENDM
.ENDC

.macro	xor src,dst
	mov src,-(sp)
	bic dst,(sp)
	bic src,dst
	bis (sp)+,dst
	.endm

.MACRO PRINT ARG,ROOM,COUNT
	.IIF NB,<ARG>,MOV ARG,R0
	.IIF NB,<COUNT>,MOVB COUNT,-(SP)
	.IIF B,<COUNT>,CLR -(SP)
	.IIF NB,<ROOM>,MOVB ROOM,-(SP)
	.IIF B,<ROOM>,CLR -(SP)
	CALL PRINT
	.ENDM
	.PAGE
	.SBTTL Integer MULtilply Immeadiate macro

.MACRO IMULI COUNT,ADDR
	.LIST MEB
T.VAL	=COUNT
	.IF EQ,T.VAL
	CLR ADDR
	.IFF
	.IF LT,T.VAL
T.VAL	=-T.VAL
	NEG ADDR
	.ENDC
T.FLAG	=0
T.MASK	=^O40000
	.REPT 14.
	.IF LE,T.MASK-T.VAL
	.IF NE,T.MASK&T.VAL
	.IF NE,T.MASK-T.VAL
	.IF EQ,T.FLAG
	MOV ADDR,-(SP)
T.FLAG	=1
	.IFF
	.IF NE,T.MASK-1&T.VAL
	ADD (SP),ADDR
	.IFF
	ADD (SP)+,ADDR
T.FLAG	=0
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	ASL ADDR
	.ENDC
T.MASK	=T.MASK/2
	.ENDR
	.IF NE,T.FLAG
	ADD (SP)+,ADDR
	.ENDC
	.ENDC
	.NLIST MEB
	.ENDM IMULI
.if ne,deb$
.if ne,vax$
	.page
; The following is a MACRO to create the required flag word for the
; SNAP dump feature of RT11TASK. The arguments are:
;
;	NUM - number of bytes to dump (0 to 255.)
;	RAD - radix select, can be either 8. or 16.
;	BYT - if 1, then dump bytes otherwise dump words
;	R50 - if 1, then dump words with RAD50 equivalent too.
;	REG - if 1, then dump registers then dump memory
;	IND - if 1, then address is indirect
;	ASC - if 1, then dump only ASCII bytes
;	DAT - if 1,then display date/time on dump
;
; DUMP argument lists consist of word pairs where the first word is the flag
; word and the second is the starting address (or the address of the address) 
; to dump stored position independent (address-.).
; The argument list is terminated with a flag word of 0.
;
; THE EXECUTION OF A SNAP DUMP DOES NOT AFFECT THE CONDITION CODES.

.MACRO SNPFLG NUM=0,RAD=8.,BYT=0,R50=0,REG=0,IND=0,ASC=0,DAT=0
	...1=NUM&255.
	.IIF NE,BYT,	...1=...1+256.
	.IF EQ,RAD-8.
	.IFF
	.IF EQ,RAD-16.
	...1=...1+512.
	.IFF
	.ERROR RAD ;RADIX CAN BE ONLY 8 OR 16
	.ENDC
	.ENDC
	.IIF NE,R50,	...1=...1+1024.
	.IIF NE,REG,	...1=...1+2048.
	.IIF NE,IND,	...1=...1+4096.
	.IIF NE,ASC,	...1=...1+8192.
	.IIF NE,DAT,	...1=...1+16384.
	.WORD ...1
	.ENDM

.MACRO SNPADR ADDRESS
	.WORD <ADDRESS>-.
	.ENDM

.MACRO SNAP ARG
	.WORD ^O30,<ARG>-.
	.ENDM

; Some examples on how to use the SNAP dump:

; STMSG: .ASCII \Symbol Table (first 32 symbols):\
; STMSGS = .-STMSG
; SSYM:  .ASCII \SYMBOL (temporary area)\
; SSYMS = .-SSYM
; SNPARG:
;	SNPFLG NUM=STMSGS,ASC=1,DAT=1
;	SNPADR STMSG
;	SNPFLG NUM=128.,IND=1,R50=1,REG=1
;	SNPADR ROLBAS+SYMROL
;	SNPFLG NUM=SSYMS,ASC=1
;	SNPADR SSYM
;	SNPFLG NUM=8.,R50=1
;	SNPADR SYMBOL
;	.WORD 0			;TERMINATE THE ARGUMENT LIST
;	.
;	.
;	.
;LOOP:	CALL STUFF	;do the program
;	SNAP SNPARG	;do the snap dump.
;	.
;	.
;	BR LOOP
	.page
.endc
.sbttl	debugging macros

	.save
	.psect debug
db.fix:	mov r1,-(sp)		;save r1 (r0 is already on the stack)
	mov 6(sp),r1		;get number to print
	mov 4(sp),6(sp)		;move the return address
	mov 2(sp),4(sp)		;move the saved r0 value
	mov (sp)+,(sp)		;move the saved r1 value
				;stack frame = 	saved r1
				;		saved r0
				;		return from call to "db.xxx"
				; r0 = return to call from fix
				; r1 = number to print
	call (r0)		;call back the caller
	mov (sp)+,r1		;restore regs
	mov (sp)+,r0
	return

db.ocb:	jsr r0,db.fix		;fix the stack, save r0,r1
	clr r0			;get only the lower byte
	bisb r1,r0
	swab r0
	ror r0			;adjust for the 3 bit shifts
	mov r0,-(sp)
	mov #3,r1		;loop counter
	br db.coc		;do common octal stuff

db.ocw:	jsr r0,db.fix		;fix the stack, save some regs
	mov r1,r0		;get the number
	asl r0			;put bit 15 into bit 0 position
	adc r0
	mov r0,-(sp)		;save the number again
	bic #-2,r0		;print the first bit
	bis #'0,r0
	.ttyout
	mov #5,r1		;loop count
db.coc:	asl (sp)		;get the next digit
	adc (sp)
	asl (sp)
	adc (sp)
	asl (sp)
	adc (sp)
	mov (sp),r0
	bic #-8.,r0
	bis #'0,r0
	.ttyout
	sob r1,db.coc
	tst (sp)+		;purge stack
	return			;and return

db.hex:	.ascii \0123456789ABCDEF\

db.hxb:	jsr r0,db.fix		;fix the stack, save r0,r1
	br db.chb		;do common byte output

db.hxw:	jsr r0,db.fix		;fix the stack, save r0,r1
	swab r1			;get the upper byte first
	call db.chb		;print hex byte
	swab r1			;get the lower byte

db.chb:	clr r0			;zap r0
	bisb r1,r0		;get the lower byte
	asr r0			;/16
	asr r0
	asr r0
	asr r0
	call 10$		;print it
	mov r1,r0
	bic #-16.,r0		;zap the upper nibble
10$:	movb db.hex(r0),r0	;get the ascii equivalent
	.ttyout			;and display it
	return
	.restore

.macro	say text,nocrlf
	mov r0,-(sp)
	msg <text>,,nocrlf
	mov (sp)+,r0
	.endm say

.macro octal number,nocrlf
	mov number,-(sp)
	call db.ocw
   .if b,<nocrlf>
	say <>
   .endc
	.endm octal

.macro octalb number,nocrlf
	mov number,-(sp)
	call db.ocb
  .if b,<nocrlf>
	say <>
  .endc
.endm octalb

.macro hex number,nocrlf
	mov number,-(sp)
	call db.hxw
   .if b,<nocrlf>
	say <>
   .endc
.endm hex

.macro hexb number,nocrlf
	mov number,-(sp)
	call db.hxb
    .if b,<nocrlf>
	say <>
    .endc
.endm hexb

.macro	show what
	say <	what=	>,128.
	hex what
	.endm show

.macro	showb what
	say <	what=	>,128.
	hexb what
	.endm showb

.macro kill what
	.macro what a1,a2,a3,a4,a5,a6,a7,a8
	.endm what
	.endm kill

.macro orkin
	kill hex
	kill hexb
	kill octal
	kill octalb
	kill say
	kill show
	kill showb
	kill orkin
	.endm orkin

.macro	orkin2
	orkin
	kill	dump
	kill	orkin2
	.endm	orkin2
.endc	
	.PAGE
	.SBTTL ROLL DEFINITIONS

	.MACRO GENROL NAME,BASE,TOP,SIZE
	ENTSEC ROLBAS
NAME'ROL==.-ROLBAS
	.WORD BASE
	.PSECT ROLTOP
	.WORD TOP
	.PSECT ROLSIZ
	.WORD SIZE*2
	XITSEC
RS.'NAME=SIZE
	.IIF GT, SIZE-MAXXMT,MAXXMT=SIZE
	.ENDM GENROL

	ENTSEC ROLBAS
ROLBAS::
	.PSECT ROLTOP
ROLTOP::
	.PSECT ROLSIZ
ROLSIZ::
	.PSECT IMPLIN
IMPLIN:
	XITSEC
MAXXMT	=0

	GENROL RLD,0,0,3	;RLD ENTRIES
	GENROL CRF,0,0,8	;CROSS REFERENCES
	GENROL SYM,0,0,4	;SYMBOL TABLE
	GENROL BND,0,0,4	;BOUNDS CHECKS
	GENROL SCR,0,0,3	;SECTION CROSS-REF ROLL
	GENROL SEC,0,0,6	;SECTION NAMES
	GENROL MLD,0,0,8	;MULTIPLE DEFINITIONS
	GENROL MOD,0,0,3	;MODULE NAMES
	GENROL IDN,0,0,3	;IDENTS
	GENROL TIM,0,0,4	;CREATION DATES/TIMES
	GENROL FIL,0,0,5	;FILE SPECS
	GENROL DUM,0,0,0	;DUMMY ROLL AT END TO STOP THINGS
	GENROL PST,PSTBAS,PSTTOP,3	;PERMANENT SYMBOLS FOR OPTIONS

	ENTSEC IMPURE
IMPURE::
	XITSEC

	.IDENT /ITEST/
	.PAGE
	.SBTTL DATA DECLARATIONS

CR	=^O15
FF	=^O14
LF	=^O12
ERRBYT	=^O52
ERRCOM	=^O53
RMON	=^O54
ER.WRN	=1
ER.ERR	=2
ER.HER	=4

	ENTSEC IMPURE
SYMBOL::.BLKW MAXXMT		;SYMBOL NAME AND STUFF
TMPSYM:	.BLKW MAXXMT		;TEMPORARY SYMBOL STORAGE
WA:	.BLKW 6			;I/O PROG.REQ. SPACE
SCHAN::	.BLKW
CHAN::	.BLKW
DPAGE:	.BLKW			;DPAGE FOR MAC69
LNKNXT:	.BLKW
FILEN:	.BLKW 4			;SPEC OF CURRENT FILE
CSISPC:	.BLKW 39		;WORK SPACE FOR CSI
BOTTOM:	.BLKW			;FLOATING FREE SPACE POINTER
STLLIM:	.BLKW			;STACK LOWER LIMIT
STGARD:	.BLKW			;STACK GUARD ZONE
STWARN:	.BLKW			;STACK UNDERFLOW'D ONCE
CSLCNT:	.BLKW			;COUNT OF CSI LINES ENTERED
CSEND:	.BLKW

CSBUFF::.BLKW 256		;COMMAND STRING BUFFER
OBUF:	.BLKW 256		;OUTPUT BUFFER
IBUF:	.BLKW 256		;INPUT BUFFER
MBUF:	.BLKW 256		;MAP BUFFER

.LNK::	.BLKW			;.LNK INDIRECT INPUT
SWA::	.BLKW			;NOT USED ANYMORE
SWC::	.BLKW			;CONTINUE ON NEXT LINE
SWL::	.BLKW			;.LDA REQUESTED
SWR::	.BLKW			;X-REF OUTPUT REQUESTED
SWO::	.BLKW			;DISPLAY OUTPUT IN OCTAL
XCRF:	.BLKW			;DISABLE CROSS REFERENCES
XUDF:	.BLKW			;DISABLE UNDEFINED CROSS REFERENCES
XMDF:	.BLKW			;DISABLE MULTIPLE DEFINED REFERENCES
MDFCNT:	.BLKW			;COUNT MULTIPLE DEFINED
CNTQAL:	.BLKW			;COUNT OF X-REF QUALIFIERS
CRFQAL:	.BLKW 26		;X-REF QUALIFIERS
R3SAV:	.BLKW			;REG SAVE AREA
R4SAV:	.BLKW
R5SAV:	.BLKW
SAEOF:	.BLKW

IBP:	.BLKW			;INPUT BUFFER POINTER
IBLOCK:	.BLKW			;INPUT BLOCK POINTER
OBP:	.BLKW			;OUTPUT BUFFER POINTER
OBLOCK:	.BLKW			;OUTPUT BLOCK POINTER
MBP:	.BLKW			;MAP BUFFER POINTER
MBLOCK:	.BLKW			;MAP BLOCK POINTER

RBUFF:	.BLKW 256		;RECORD BUFFER
RBSIZE	=.-RBUFF

OUT::	.BLKW 5			;OUTPUT FILE SPEC
MAP::	.BLKW 5			;MAP FILE SPEC
SYM::	.BLKW 5			;SYMBOL TABLE FILE SPEC
	XITSEC

	ENTSEC PURE
LIM:	.LIMIT
DEXT:	.RAD50 /OBJ/		;INPUT
	.RAD50 /SAV/		;OUTPUT
	.RAD50 /MAP/		;OUTPUT
	.RAD50 /SYM/		;OUTPUT
	XITSEC

	ENTSEC MSGS
VERSION: .ASCII \% Atari LINKM \
	GTVNUM
	.ASCIZ \ %\
	XITSEC
	.PAGE
	.SBTTL ENTRY
	ENTSEC MAIN
START::	JSR R4,INIT		;GO INITIALISE STUFF
	MOV #CSBUFF,R4		;POINT TO COMMAND STRING BUFFER
	CLR R3			;GET FIRST INPUT FROM TERMINAL

	.ENABL LSB
BEGIN::	MOV #CSISPC,R5		;POINT TO CSI SPACE
	.CSISPC R5,#DEXT,R3,R4	;GET FILE SPECS
	BCC 10$			;OK
	MSGF <Illegal command string. - >,128
	.PRINT R3
	BR START

10$:	INC CSLCNT		;COUNT COMMAND LINE
	TSTB SWC+1		;FIRST TIME THROUGH?
	BNE 30$			;NOPE
	MOV #OUT,R0
	MOV R5,R1		;COPY OUTPUT SPECS
	MOV #15,R2		;15 WORDS

20$:	MOV (R1),(R0)+
	CLR (R1)+		;COVER OUR TRACKS
	SOB R2,20$

30$:	TST 30(R5)		;ANY INPUT?
	BNE 40$			;YES. PROCEED
	.PRINT #VERSION		;DISPLAY VERSION NUMBER
	BR START

40$:	MOV (SP)+,R2		;GET SWITCH COUNT
	BEQ STEP1		;NONE
	INC .LNK		;DON'T ALLOW .LNK INPUT IF SWITCH INPUT
	MOV R3,R3SAV		;SAVE SOME REGS
	MOV R4,R4SAV		; (CAN'T USE THE STACK HERE)
	MOV R5,R5SAV
50$:	MOV (SP)+,R1		;GET SWITCH
	MOV #SWTBL,R3		;POINT TO THE SWITCH TABLE
	MOVB R1,R0		;GET A COPY OF THE CHAR (0 THE UPPER BYTE)
60$:	MOV (R3)+,R4		;GET ADDRESS OF ROUTINE OR FLAG
	BEQ 90$		;ISN'T IN THE TABLE
	CMP R0,(R3)+		;MATCH CHAR?
	BNE 60$			;NOPE, KEEP LOOKING	
	ASR R4			;ROUTINE?
	BCS 70$			;YEP
	ASL R4			;FIX THE ADDRESS
	INC (R4)		;SET THE FLAG
	BR 80$

70$:	ASL R4			;FIX THE ADDRESS
	MOV #80$,R5		;SET THE RETURN ADDRESS
	JMP (R4)		;GO TO THE ROUTINE
	
80$:	TST R1			;WAS THERE A VALUE?
	BMI 90$		;YEP, CAN'T HAVE THAT
	DEC R2			;COUNT SWITCH
	BGT 50$			;CONTINUE
	MOV R5SAV,R5		;RESTORE THE REGS
	MOV R4SAV,R4
	MOV R3SAV,R3
	BR STEP1

90$:	MSGF <"/>,128
	.TTYOUT R1		;PRINT SWITCH LETTER
	MSG <" illegal switch>
	BR START

SW$L:	TSTB SWC+1		;FIRST TIME THROUGH?
	BNE 90$		;NOPE. BAD SWITCH THEN
	INC SWL			;YEP. SIGNAL SAME
	CMP OUT+6,#^RSAV	;DEXT = .SAV?
	BNE 120$		;NOPE. LEAVE IT ALONE THEN
	MOV #^RLDA,OUT+6	;CHANGE IT TO .LDA
	BR 120$			;CONTINUE

SW$R:	INC SWR			;SIGNAL XREF WANTED
	TST R1			;ANY VALUE?
	BPL 120$		;NOPE
	DEC SWR			;UNDO THE FLAG PREVIOUSLY SET
	MOV (SP)+,R0		;GET THE VALUE
	MOV CNTQAL,R1		;GET INDEX INTO QUALIFIER ARRAY
	CMP R1,#52		;TOO MANY ALREADY?
	BLO 100$		;NOPE
	MSG <Too many xref qualifiers. Extras ignored>
	BR 120$			;CONTINUE

100$:	MOV R0,CRFQAL(R1)	;SAVE THE QUALIFIER
	TST (R1)+		;ADD 2 TO INDEX
	MOV R1,CNTQAL		;SAVE IT
	BR 120$			;GO BACK

SW$I:	TST R1			;VALUE?
	BPL 120$		;NOPE
	MOV (SP)+,R0		;GET THE VALUE
	MOV #SWITBL,R3		;POINT TO SWITCH I TABLE
110$:	MOV (R3)+,R4		;GET ADDRESS OF FLAG
	BEQ 90$		;ILLEGAL VALUE
	CMP R0,(R3)+		;VALUES MATCH?
	BNE 110$		;NOPE
	INC (R4)		;YEP, SET FLAG
	CLR R1			;FIX IT SO THERE ARE NO ERRORS
120$:	JMP (R5)		;GO BACK
	.DSABL LSB

.MACRO SWT CHAR,ADDR
	.WORD ADDR,''CHAR
	.ENDM

SWTBL:	SWT A,SWA		;DON'T CARE ABOUT THIS ONE
	SWT O,SWO		;OCTAL
	SWT C,SWC		;CONTINUATION
	SWT L,SW$L+1		;/LDA REQ. SPECIAL
	SWT R,SW$R+1		;XREF SPECIAL
	SWT I,SW$I+1		;IGNORE INDICATORS
	.WORD 0			;TERMINATOR

.MACRO SWT CHAR,ADDR
	.WORD ADDR
	.RAD50 \CHAR\
	.ENDM
SWITBL:	SWT U,XUDF		;IGNORE UNDEFINED
	SWT M,XMDF		;IGNORE MULTIPLE DEFINES
	SWT R,XCRF		;IGNORE ALL XREF'S
	.WORD 0			;TERMINATOR
	.ENABL LSB
STEP1:	MOV (R5),R0		;OUTPUT FILES?
	BIS 10(R5),R0
	BIS 20(R5),R0
	BEQ 10$			;NOPE
	MSGF <Too many output files specified.>
	JMP START

10$:	TSTB (R4)+		;SKIP TO END OF COMMAND STRING
	BNE 10$
	CMP R4,#OBUF-2		;CAN'T GET TOO BIG
	BLOS 20$			;OK
	MOV #OBUF-2,R4
20$:	MOVB #CR,-1(R4)		;PUT THE CR,LF BACK IN.
	MOVB #LF,(R4)+
	CLRB (R4)		;AND TERMINATE THE STRING
	MOV R4,CSEND		;KEEP TRACK OF END OF STRING

	CALL OPEN		;GET STATS ON INPUT FILES
	TST .LNK		;.LNK LEGAL?
	BNE 60$			;NOPE
	CMP 30+6(R5),#^RLNK	;.LNK INPUT?
	BNE 60$			;NOPE. NEVER MIND
	CALL READ		;READ 1 BLOCK OF INPUT FILE
	INC SCHAN		;SAY THE REAL READ CHANNEL IS 1 GREATER
	MOV #IBUF,R0		;POINT TO INPUT STRING
	MOV R0,R3		;SAVE IT

30$:	CMPB (R0)+,#CR		;LOOK FOR END OF STRING
	BEQ 40$			;FOUND IT
	CMP R0,#IBUF+512	;RUN OFF THE END?
	BLO 30$			;NOPE
	MSGF <.LNK File too long.>
	JMP START

40$:	CLRB -1(R0)		;ZAP THE END FOR C.S.I.
	CLRB (R0)+		;ZAP THE LF CODE
	MOV R0,LNKNXT		;POINT TO THE NEXT INPUT STRING
	INC .LNK		;CAN'T GET ANYMORE .LNK FILES
50$:	JMP BEGIN		;PROCESS COMMAND STRING

60$:	DECB SWC		;/C?
	BMI PASS0		;NOPE. START LINKING
	INCB SWC+1		;YEP. DISALLOW /A,/L AND ANY MORE OUTPUT FILES
	MOV LNKNXT,R3		;POINT TO NEXT C.S.
	BEQ 50$			;COMING FROM TERMINAL
	MOV R3,R0		;COMING FROM FILE. POINT TO NEXT LINE
	BR 30$			;GO FIX UP THE LINE AND CONTINUE
	.DSABL LSB
	.PAGE
	.SBTTL PASS0  LINK PROCESS CONTROL
GSD	=1
ENDGSD	=2
TXT	=3
RLD	=4
ISD	=5
ENDMOD	=6
LIBHDR	=7
LIBEND	=8

PASS0:	MOV #16,R0		;ASSUME OUTPUT RADIX TO 16
	TST SWO			;T-11 MODE?
	BEQ 10$			;NOPE
	ASR R0
10$:	MOV R0,CRADIX		;OPTIONS INPUT DEFAULT
	MOV R0,OUTRDX		;AND OUTPUT LISTING DEFAULT
	MOV R0,DEFRAD		;AND DEFAULT RADIX
20$:	MOV SEQ,R0		;SEQUENCE CODE
	ADD #2,SEQ		;+2 FOR NEXT TIME
	CLR CHAN		;BE SURE TO START AT BEGINING
	CLR IBP			;WITH AN EMPTY BUFFER
	CALL @DTABL(R0)		;CALL ROUTINE
.IF NE,DMP$
	CMP SEQ,#DMP$*2		;ARE WE TO CRASH DUMP HERE?
	BLO 20$			;NOPE
	MOV ROLBAS+CRFROL,R0	;POINT TO PLACE OF CRF ROLL
	MOV ROLBAS+MLDROL,R1	;POINT TO PLACE OF MULTIPLE DEFINITIONS
	MOV #ROLBAS,R2		;POINT TO ROLL BASE
	HALT			;CRASH DUMP
.IFF
	BR 20$			;CONTINUE
.ENDC

DTABL:	INMAP			;INTIALISE THE MAP FILE
	FILSYM			;FILL SYMBOL TABLE
	SUMFIL			;SUMMARIZE FILE STUFF IN MAP
	OPTIONS			;PROCESS OPTIONS FILE
	RELOCT			;RESOLVE ABSOLUTE VALUES OF SYMBOLS
	BNDCHK			;DO BOUNDS CHECK ON SECTIONS
	FINMAP			;FINISH THE LOAD MAP
	PURXRF			;DISCARD THE XREF TABLES
	CREBIN			;CREATE BINARY OUTPUT
	SYMOUT			;Symbol table output
	CLOSUP			;CLOSE UP
	START			;BEGIN AGAIN

	.SBTTL FILSYM SYMBOL TABLE CREATION
FILSYM::CLR VTOP
	MOV #-1,VBOTT
.IIF NE,DEB$,	MSG <Fill symbol table>
P1.GR:	CALL READR		;READ A RECORD
	BNE 10$			;GOT ONE
	RET			;END OF ALL FILES

10$:	MOV #RBUFF,R5		;POINT TO START OF RECORD
	MOV R0,R4		;COUNT OF BYTES IN RECORD
	SUB #2,R4		;-2 FOR TYPE WORD
	CMP (R5),#GSD		;GSD ENTRY?
	BEQ 20$			;YEP
	CALL GETTOP		;LOOK FOR .VCTRS STUFF
	BR P1.GR		;CONTINUE

20$:	TST (R5)+		;SKIP TYPE CODE
GSD0:	MOVB 5(R5),R0
	ASL R0			;MAKE IT A WORD INDEX
	CMP R0,#GSDMAX		;LEGAL TYPE?
	BHIS 10$		;NOPE. ERROR EXIT
	MOV R5,-(SP)		;SAVE POINTER
	MOV #SYMBOL,R3		;POINT TO SYMBOL AREA
	JMP @GSDT(R0)		;GO TO ROUTINE
10$:	JMP BADOBJ

GSDT:	 GSDMOD		;TYPE 0 - MODULE NAME
	 CSECT		;     1 - CSECT DECLARATION
	 GSDTIM		;     2 - INTERNAL SYMBOL
	 GSDNXT		;     3 - XFER ADDRESS
	 GLOBAL		;     4 - GLOBAL SYMBOL REF/DEF
	 PSECT		;     5 - PSECT DECLARATION
	 GSDIDN		;     6 - .IDENT NAME
	 GSDNXT		;     7 - .VIR DECLARATION
GSDMAX	=.-GSDT
	.PAGE
	.SBTTL ASECT/CSECT/BSECT/PSECT HANDLERS

	ENTSEC IMPURE
SECNAM:	.BLKW 2
SECFLG:	.BLKB
SECNUM:	.BLKB
SECOFF:	.BLKW
SECLEN:	.BLKW
SEQ:	.BLKW
	XITSEC

; GSD FOR PSECT DATA TYPES (FOR MAC65,MAC68,MAC69)
S.FORC	=1			;FORCED OFFSET (OPTIONS FILE INPUT)
S.MDF	=2			;MULTIPLY DEFINED
S.OVR	=4			;OVERLAY
S.DEF	=8			;DEFINITION
S.BSE	=16			;BASE PAGE
S.REL	=32			;RELOCATION
S.M68	=64			;6800 WORD TYPE
S.BYT	=128			;BYTE MODE
;GSD PSECT DATA TYPES (FOR MAC11)
S.ALL	=4			;ALLOCATION, 0 = CONCATINATED, 1 = OVERLAY
S.DATA	=128			;0 = SECTION TO BE WORD ALIGNED

GSDNXT:	MOV (SP)+,R5		;RESTORE R5
	ADD #8,R5		;SKIP TO NEXT ITEM
	SUB #8,R4		;DECREMENT BYTE COUNT
	BGT GSD0		;STILL MORE
	BR P1.GR		;GO GET NEXT RECORD

; FOR THE SECROL, THE FOLLOWING DEFINITIONS APPLY

FLAGS	=4			;OFFSET FROM 'SYMBOL' (R3 IN THESE ROUTINES)
SECT	=5
OFFSET	=6
LENGTH	=8

CSECT:	MOVB #S.REL,R0		;ASSUME RELOCATION AND CONCATINATED
	TST (R5)		;TRUE? (UN-NAMED CSECT)
	BEQ 30$			;YEP.
	CMP (R5),#^R. B		;.BSECT?
	BNE 10$			;NOPE
	BIS #S.BSE,R0		;YES. SIGNAL SAME
	TST 2(R5)		;UNNAMED BSECT?
	BEQ 30$			;YEP, CONCATINATE
	BR 20$			;NOPE, OVERLAYED

10$:	CMP (R5),#^R. A		;.ABS?
	BNE 20$			;NAMED CSECTS ARE OVERLAYED
	CMP 2(R5),#^RBS.
	BNE 20$
	CLR R0			;SAY ITS ABSOLUTE
20$:	BIS #S.OVR,R0		;AND OVERLAYED
30$:	MOVB R0,4(R5)		;RECORD FLAGS.
	.PAGE
	.ENABL LSB
PSECT:	MOVB CHAN,5(R5)		;PUT FILE # INTO TYPE CODE BYTE
	MOV (R5)+,(R3)		;PASS SYMBOL
	MOV (R5)+,2(R3)
	MOV 2(R5),(PC)+
PS.0:	.WORD 0			;KEEP LENGTH OF SECTION
	SCAN SECROL		;LOOK FOR SECTION NAME IN ROLL
	BEQ 30$			;DIDN'T FIND ONE
	MOV (R5),-(SP)
	BIC #^C<S.REL!S.OVR!S.BSE>,(SP)
	MOVB FLAGS(R3),R0
	BIC #^C<S.REL!S.OVR!S.BSE>,R0
	CMP (SP)+,R0		;ATTRIBUTES MATCH?
	BEQ 10$			;YEP
	CALL BADATT		;NOPE, PRINT AN ERROR
	MOVB FLAGS(R3),(R5)	;USE THE FIRST VALUE
10$:	BIT #S.OVR,(R5)		;SECTIONS TO BE OVERLAYED
	BEQ 60$			;NOPE, CONCATINATE THEM
	MOV ROLENT,CURSEC	;KEEP TRACK OF CURRENT SECTION #
	CMP 2(R5),LENGTH(R3)	;KEEP LARGEST
	BLOS 40$		;ALREADY HAVE IT
	MOV 2(R5),LENGTH(R3)	;GET NEW HIGH

20$:	INSERT			;AND STICK IT IN
	BR 40$			;CREF IT AND EXIT

30$:	MOV (R5)+,FLAGS(R3)	;CONCATINATE SECTION, COPY FLAGS
	ADD (R5),LENGTH(R3)
	APPEND SECROL		;PUT SECTION NAME AT END OF ROLL
	MOVB ROLSIZ+SECROL+1,CURSEC	;KEEP TRACK OF CURRENT SECTION NUMBER

40$:	CMP (R3),#^R. A		;. ABS. ?
	BNE 50$			;NOPE
	CMP 2(R3),#^RBS.
	BNE 50$			;NOPE
	TST PS.0		;SIZE = 0?
	BEQ GSDNXT		;YEP, SKIP SECTION
50$:	CALL CRFSEC		;CREF THE SECTION
	BR GSDNXT

60$:	CLR LENGTH(R3)		;ZAP LENGTH IN CASE OF APPEND
	TST (R3)		;UNNAMED CSECT?
	BEQ 30$			;YEP. APPEND IT
	CMP (R3),#^R. B		;UNAMED BSECT?
	BNE 70$			;NOPE
	TST 2(R3)
	BEQ 30$			;YEP, JUST APPEND
70$:	MOV (SP),R5		;RESET R5

80$:	NEXT SECROL		;GET THE NEXT SECTION DEFINITION
	BEQ 90$			;END
	CMP (R3),(R5)		;SAME NAME?
	BNE 90$			;NOPE
	CMP 2(R3),2(R5)
	BEQ 60$			;YEP. GO TO NEXT ONE

90$:	MOV ROLENT,CURSEC	;KEEP CURRENT SECTION #
	CALL FIXSEC		;GO FIX REFERENCES TO THIS SECTION #
	MOV (R5)+,(R3)+		;PASS SYMBOL
	MOV (R5)+,(R3)+
	MOV (R5)+,(R3)+		;+ FLAGS
	CLR (R3)+		;+ OFFSET
	MOV (R5),(R3)		;+ LENGTH
	CLR ROLUPD		;SAY SEARCH FAIL
	BR 20$			;STICK IT IN THE ROLL, CREF, EXIT
	.DSABL LSB

CRFSEC::MOV #SYMBOL,R0		;POINT TO SYMBOL AREA
	MOV CURSEC,(R0)+	;PASS CURRENT SECTION NUMBER
	CLR (R0)+		;FILLER WORD FOR COMPATIBILITY
	CLRB (R0)+		;NO FLAGS
	MOVB CHAN,(R0)		;AND CURRENT CHANNEL
	APPEND SCRROL		;STICK IT AT THE END OF THE CREF ROLL
	RETURN

	ENTSEC MSGS
CNFATT:	.ASCII \?LINKM-W-CNFATT, Conflicting section attributes. PSECT=\
CNFSEC:	.BLKB 40.
	XITSEC

BADATT:	SAVREG			;SAVE ALL THE REGS
	MOV R3,R1		;POINT TO SECTION NAME IN ERROR
	MOV #CNFSEC,R2		;POINT TO MESSAGE SPACE
	CALL SYMTOA		;UNPACK SYMBOL NAME
10$:	CMPB -(R2),#SPACE	;BACKUP OVER SPACES
	BEQ 10$
	INC R2			;SKIP TO NEXT CHAR
	MOVB #^O73,(R2)+	;FOLLOW WITH A ;
	MOVB #SPACE,(R2)+	;AND A SPACE
	MOV #M.FILE,R1		;POINT TO "FILE=" MESSAGE
	CALL MOVBYT		;COPY IT IN
	MOV #FILEN,R0		;POINT TO CURRENT FILE NAME
	CALL CVFN		;PUT IT IN TOO
	MOV SP,TTKEY		;SAY THIS LINE GOES TO TT: TOO
	PRINT #CNFATT		;DISPLAY IT
	RET			;DONE
	.PAGE
BADOBJ:	MSGF <Bad GSD entry type. >,128
	TFILE

GSDTIM:	MOV #TIMROL,R0		;TIME/DATE
	BR IDNMOD

GSDMOD:	MOV #MODROL,R0
	BR IDNMOD

GSDIDN:	MOV #IDNROL,R0
IDNMOD:	MOV CHAN,(R3)+		;RECORD CHANNEL NUMBER
	MOV (R5)+,(R3)+		;COPY NAME/TIME
	MOV (R5)+,(R3)+
	MOV 2(R5),(R3)+		;DATE IF TIMROL ELSE DON'T CARE
	CALL APPEND		;STICK STUFF IN ROLL
	JMP GSDNXT		;CONTINUE



FIXSEC:	MOV ROLBAS+SCRROL,R0	;POINT TO CREF ROLL
10$:	CMP R0,ROLTOP+SCRROL	;AT THE END?
	BHIS 30$		;NOPE
	CMP (R0),CURSEC		;IS ENTRY POINTING TO CURRENT SECTION?
	BLO 20$			;NOPE
	INC (R0)		;YEP, BUMP IT
20$:	ADD #RS.SCR*2,R0	;SKIP TO NEXT ENTRY
	BR 10$

30$:	MOV ROLBAS+SYMROL,R0	;POINT TO SYMBOL ROLL
40$:	CMP R0,ROLTOP+SYMROL
	BHIS 60$		;CONTINUE
	CMPB 5(R0),CURSEC	;SYMBOL POINTING TO THIS SECROL?
	BLO 50$			;NOPE
	INCB 5(R0)
50$:	ADD #RS.SYM*2,R0	;SKIP TO NEXT ENTRY
	BR 40$

60$:	RETURN
	.PAGE
	.SBTTL GLOBAL HANDLER
; THE FOLLOWING DEFINITIONS APPLY TO THE SYMROL
FLAGS	=4
SECT	=5
VALUE	=6

;The following FLAGS bit definitions apply for GLOBAL symbols

S.SW	=1			;STRONG/WEAK indicator (OPTIONS FILE INPUT)
S.MDF	=2			;MULTIPLY DEFINED
S.DEF	=8			;DEFINITION
S.BSE	=16			;BASE PAGE
S.REL	=32			;RELOCATION

GLOBAL:	MOV (R5)+,(R3)+		;PASS SYMBOL
	MOV (R5)+,(R3)+
	BICB #^C<S.DEF!S.BSE!S.REL>,(R5)	;ZAP UNUSED BITS
	SEARCH SYMROL		;LOOK FOR SYMBOL
	BEQ 40$			;DIDN'T FIND IT
	BIT #S.DEF,(R5)		;DEFINITION COMING UP?
	BEQ 70$			;NOPE. JUST A REFERENCE
	BIT #S.DEF,(R3)		;ALREADY DEFINED?
	BEQ 50$			;NOPE.
	MOV 2(R3),R2		;SAVE CURRENT VALUE FOR LATER TEST
	CMP FILEN+6,#^RSYM	;IS THIS A .SYM FILE?
	BEQ 70$			;YEP, NEVER MIND ABOUT IT THEN
	TST XMDF		;SUPPOSED TO IGNORE MDF'S?
	BNE 10$			;YEP
	SEARCH MLDROL		;LOOK FOR SYMBOL IN MLD ROLL
	CALL FILBIT		;INSTALL FILE # BIT
	BISB #S.MDF,(R5)	;SIGNAL MULTIPLE DEFINITIONS
10$:	BIT #S.REL,(R5)		;RELOCATABLE SYMBOL?
	BNE 20$			;YES, ERROR
	CMP R2,2(R5)		;VALUES MATCH?
	BEQ 30$			;YEP. OK THEN
20$:	BISB #S.MDF,(R3)	;ELSE SIGNAL THAT THIS IS REALLY A M.D.
	INC MDFCNT		;COUNT THAT THERE WERE MDF'S
30$:	TST XMDF		;SUPPOSED TO IGNORE MDF'S?
	BEQ 60$			;NOPE, INSERT AND CREF IT
	BR 70$			;YEP, JUST CREF IT

40$:	BITB #S.DEF,(R5)	;DEFINITION FOLLOWING?
	BEQ 60$			;NOPE, JUST INSERT AND CREF IT

50$:	BISB (R5),(R3)+		;PASS FLAGS
	MOVB CURSEC,(R3)+	;PASS RELATIVE SECTION #
	MOV 2(R5),(R3)		;PASS VALUE
60$:	INSERT			;STUFF IT IN ROLL, FALL THRU TO CREF IT

70$:	CALL CRFSYM		;CREF THE SYMBOL
	JMP GSDNXT

	.ENABL LSB
CRFSYM::
	TST XCRF		;XREF'S ALLOWED?
	BNE 10$			;NOPE, TAKE THE EASY WAY OUT
	CMP SP,STGARD		;AT THE GUARD BAND YET?
	BHIS 20$		;NOPE, OK THEN
	INC STWARN		;SIGNAL STACK ABOUT TO UNDERFLOW
	MSGW <2MNYSYM, Too many symbols to cross reference>
	CALL PURXRF		;ZAP THE XREF ROLL
10$:	RET

20$:	TST STWARN		;OVERFLOW'D YET?
	BNE 10$			;YEP, DON'T XREF THEN
	MOV CNTQAL,R0		;ANY QUALIFIERS?
	BEQ 40$			;NOPE
30$:	SUB #2,R0		;BACKUP 1 SLOT
	BMI 10$			;RAN OFF THE END, DON'T XREF
	MOV CRFQAL(R0),R1	;GET THE QUALIFIER
	CMP SYMBOL,R1		;MATCH?
	BLO 30$			;NOPE, DON'T BOTHER WITH IT
	ADD #^O50*^O50,R1	;UP IT BY 1 RAD50 CHARACTER
	CMP SYMBOL,R1		;MATCH?
	BHIS 30$		;NOPE

40$:	SEARCH CRFROL		;LOOK FOR CREF'D SYMBOL
	BISB (R5),SYMBOL+FLAGS	;PASS DEFINED/MULTIPLE-DEFINED FLAGS
	BIT #S.DEF,(R5)		;ARE WE DEFINING HERE?
	BEQ 50$			;NOPE, LEAVE THE FILE NUMBER ALONE
	BIT #S.MDF,(R5)		;HAS IT PREVIOUSLY BEEN DEFINED?
	BNE 50$			;YEP, LET THE FIRST ONE STAND
	MOVB CHAN,SYMBOL+SECT	;PASS FILE NUMBER
50$:	CALL FILBIT		;INSERT FILE # BIT
	INSERT			;STICK IN THE REFERENCE
	RETURN
	.DSABL LSB
	.PAGE
	.SBTTL RELOCT -Resolve values of globals
	.ENABL LSB

; The following definitions apply to secrol:

FLAGS	=4		;Offsets from SYMBOL
SECT	=5
OFFSET	=6
LENGTH	=8

RELOCT:
.IIF NE,DEB$,MSG <Locate sections and relocate symbols>
	PRINT #SSMRY,#$SSMR,#$SSMR-2	;SECTION SUMMARY
	MOV ROLBAS+SECROL,R5	;POINT TO START OF SECTION ROLL
	MOV LENGTH(R5),R5	;GET SIZE OF .ASECT
	CLR R4			;BSECT'S START AT LOC 0
	CLR ROLUPD		;Start at begining
	CLR ROLENT		;MUST BE 0 FOR CREF TO WORK
	MOV #SYMBOL,R3		;MAKE SURE R3 IS SET UP

10$:	NEXT SECROL		;Get next PSECT
	BNE 20$			;got one
	JMP 160$
20$:	BIT #S.FORC,FLAGS(R3)	;forced to a location?
	BNE 30$			;yep, treat it as though its a ABS section
	BIT #S.REL,FLAGS(R3)	;Relocatable section?
	BNE 100$			;Yes, continue
30$:	MOV #TMPSYM+2,R2	;point to temp space
	CMP 2(R3),(R2)+		;same as last time?
	BNE 40$			;nope
	CMP (R3),-4(R2)		;same?
	BEQ 50$			;yep
40$:	CLR (R2)		;zap the old offset
	BIT #S.FORC,FLAGS(R3)	;forced to a place in mem?
	BEQ 50$			;nope, start at 0 then
	MOV OFFSET(R3),(R2)	;yep, start at the position indicated
	BR 70$			;and accumulate from there
50$:	TST SWO			;/O MODE?
	BEQ 60$			;nope
	BIT #S.DATA,FLAGS(R3)	;data section?
	BNE 60$			;yep
	INC (R2)		;instruction, force it to word boundary
	BIC #1,(R2)
60$:	ADD (R2),OFFSET(R3)	;Position section
70$:	ADD LENGTH(R3),(R2)	;update top address in temp space
	ADC OOV			;+ any overflow
	CMP (R2),HILIMIT	;max out section size
	BLOS 80$		;already got it
	MOV (R2),HILIMIT
80$:	BIT #S.FORC+S.REL,FLAGS(R3) ;forced or relocatable section?
	BEQ 140$		;nope, proceed normally
	TST SWO			;/O mode?
	BNE 90$			;yep, can't have bsect's
	BIT #S.BSE,FLAGS(R3)	;base section?
	BEQ 90$			;nope
	CMP (R2),R4		;else force up the base position
	BLOS 140$
	MOV (R2),R4
	BR 140$

90$:	CMP (R2),R5		;else force up the relocatable position
	BLOS 140$		;already set to a higher value
	MOV (R2),R5		;bump it
	BR 140$

100$:	TST SWO			;/O mode?
	BNE 110$			;yep, can't have bsects
	BIT #S.BSE,FLAGS(R3)	;.BSECT?
	BEQ 110$			;NOPE
	ADD R4,OFFSET(R3)	;position section in memory
	ADD LENGTH(R3),R4	;update load address
	BR 130$			;continue

110$:	TST SWO			;/O mode?
	BEQ 120$			;nope
	BIT #S.DATA,FLAGS(R3)	;data section?
	BNE 120$			;yep
	INC R5			;instruction, force it to word boundary
	BIC #1,R5
120$:	ADD R5,OFFSET(R3)	;Place section in real memory
	ADD LENGTH(R3),R5	;Update top address
130$:	ADC OOV			;keep any overflow
140$:	INSERT			;Update section roll
	MOV R3,R1		;SOURCE
	MOV #TMPSYM,R2		;DEST
	CALL XMIT2		;make a copy of the old SYMBOL
	TST (R3)		;unnamed CSECT/BSECT/PSECT?
	BNE 150$		;nope, print it anyway
	TST LENGTH(R3)		;size=0?
	BEQ 10$			;yep, don't print it
150$:	TST MAP			;output?
	BEQ 10$			;nope, skip the rest of this stuff
	MOV #LB,R2		;point to line buffer
	MOV R3,R1		;point to symbol
	CALL SYMTOA		;unpack symbol
	MOV OFFSET(R1),R0	;get load point
	CALL OUTNUM		;print it
	DEC R2			;back up 1 space
	MOV LENGTH(R1),R0	;get size
	CALL OUTNUM		;Print it
	DEC R2			;back up 1 space
	CALL ATTRIB		;Display section attributes
	MOV ROLENT,(R1)+	;set name
	CLR (R1)
	CALL REFRSS		;do cref on section
	JMP 10$			;continue
	.PAGE
160$:	MOV OOV,TTKEY		;signal any overflow errors to TT: too
	BEQ 180$			;ok
	TST R5			;right on boundary?
	BEQ 170$			;yes, no message required
	PRINT #OOV65K		;WARNING, OUTPUT OVERFLOWED 65K
170$:	MOV #-1,R5		;force top address = FFFF
180$:	CMP R4,R5		;check for bsect bigger than other
	BLOS 190$			;ok
	MOV R4,R5		;else use the bsect size
190$:	CMP R5,HILIMIT		;max out limit
	BLOS 200$
	MOV R5,HILIMIT		;Keep top address
200$:	CLR ROLUPD		;Start search at begining again

; The symbol OFFSET is replaced with the symbol VALUE for the following code

VALUE	=6

210$:	NEXT SYMROL		;Get symbol
	BEQ 220$		;At the end
	MOVB SECT(R3),R0	;Get section # of definition
	BEQ 210$		;Undefined, ignore relocation
	DEC R0			;Make it relative to 0
	IMULI RS.SEC*2,R0	; * size of section roll in bytes
	ADD ROLBAS+SECROL,R0	;Compute address of entry of definition
	ADD OFFSET(R0),VALUE(R3)	;Compute absolute value of symbol
	INSERT			;Update symbol roll
	BR 210$			;Continue

220$:	RET			;exit pass 2
	.DSABL LSB

	ENTSEC IMPURE
OOV:	.BLKW
	XITSEC

	ENTSEC MSGS
OOV65K:	.ASCIZ \?LINKM-W-Output overflowed 65K bytes.\
	XITSEC

	.SBTTL BNDCHK check for section overmaps

; The following definitions apply to secrol:

FLAGS	=4		;Offsets from SYMBOL
SECT	=5
OFFSET	=6
LENGTH	=8

LOLIM	=4		;Offsets from SYMBOL for BNDROL
HILIM	=6

BNDCHK:	mov #symbol,r3		;point to symbol array
	CLR ROLUPD		;prepare to search BNDROL
10$:	NEXT BNDROL		;get the next bound check
	bne 20$			;got one
	ret			;else we're done

20$:	mov rolbas+secrol,r5	;point to start of section roll
	mov roltop+secrol,r4	;point to top of section roll
30$:	cmp (r3),(r5)		;match?
	bne 40$			;nope
	cmp 2(r3),2(r5)		;match?
	beq 50$			;yep
40$:	add #rs.sec*2,r5	;update pointer
	cmp r5,r4		;at the limit yet?
	blo 30$			;nope, keep looking
	br 10$			;go to next section

50$:	mov length(r5),r2	;get the size of the section
	add offset(r5),r2	;point to last byte
	dec r2
	cmp offset(r5),lolim(r3) ;in range?
	blo 60$			;nope
	cmp r2,hilim(r3)	;in range?
	blos 70$		;yep
60$:	call doobnd		;else display section out of bounds
70$:	mov rolbas+secrol,r1	;point to start of section roll
80$:	cmp r1,r5		;checking against ourselves?
	beq 90$			;yep, never mind then
	mov length(r1),r0	;get the length of the section
	beq 90$			;don't bother with 0 length sections
	add offset(r1),r0	;compute the address of the last byte
	dec r0
	cmp r2,offset(r1)	;my end addr < his start addr?
	blo 90$			;yep, its ok then
	beq 85$			;= constitutes an overmap
	cmp offset(r5),r0	;my start addr > then his end addr?
	bhi 90$			;yep, its ok then
85$:	call dovrmap		;else display an overmap condition
90$:	add #rs.sec*2,r1	;up to next section
	cmp r1,r4		;at the limit?
	blo 80$			;nope, keep checking
	br 40$			;go to next section to test

	.sbttl BNDCHK utilities
	entsec msgsec
bc.oob:	.asciz \?LINKM-W-Section \
	.asciz \out of bounds.\

bc.ovr:	.asciz \?LINKM-W-Section \
	.asciz \overmapped with section \
	xitsec		

doobnd:	savreg			;save all the regs
	mov #lb,r2		;point to free space
	mov #bc.oob,r1		;point to text
	call movbyt		;copy in the message
	mov r1,-(sp)		;save pointer
	mov r3,r1		;point to symbol to convert
	call symtoa		;dump the symbol
	dec r2			;back up a char
	mov (sp)+,r1		;restore pointer
	call movbyt		;copy rest of message
	mov sp,ttkey		;signal that this goes to the terminal too
	print #lb		;display the message
	ret			;done

dovrmap:
	savreg			;save all the regs
	mov r1,-(sp)		;save pointer to symbol tested
	mov #bc.ovr,r1		;point to text
	mov #lb,r2		;point to free space
	call movbyt		;mov in message
	mov r1,r0		;save pointer to rest of message
	mov (sp)+,r1		;get pointer to symbol
	mov r0,-(sp)		;save pointer to rest of message
	call symtoa		;(r1 points to symbol)
	dec r2			;backup 1 space
	mov (sp)+,r1		;restore pointer to rest of message
	call movbyt		;copy rest of message
	mov r3,r1		;point to symbol under test
	call symtoa		;dump it
	mov sp,ttkey		;this goes to the terminal too
	print #lb		;display it
	ret			;done

	.SBTTL FINMAP finish up the load map

FINMAP:	CALL P2GSS		;Global symbol summary to load map
	CALL P2UDF		;Undefined symbol summary to load map/TT:
	CALL P2MDF		;Multiple definition output to load map/TT:
	RET

	.SBTTL PURXRF Purge all X-ref rolls
; PURXRF Purges all the rolls defined before SYMROL
;   namely the X-ref rolls which can be discarded after relocation
;    is complete.

PURXRF:	SAVREG			;MAKE SURE NOT TO ZAP THE REGS
	MOV ROLBAS+SYMROL,R5	;POINT TO BOTTOM OF SYMBOL ROLL
	MOV ROLBAS,R4		;POINT TO BOTTOM OF ALL ROLLS
	CLR R0			;START INDEX AT 0
10$:	CMP R0,#SYMROL		;AT THE LIMIT?
	BHIS 20$		;YEP, DONE THEN
	MOV R5,ROLBAS(R0)	;INIT THE ADDRESSES
	MOV R5,ROLTOP(R0)	; WHICH EFFECTIVELY ZAPS THE ROLLS
	CLRB ROLSIZ+1(R0)
	ADD #2,R0		;UP TO NEXT ENTRY
	BR 10$

20$:	MOV R4,R0
	SUB SP,R0		;COMPUTE # OF BYTES TO MOVE
	BEQ 40$			;NUTHIN' TO MOVE
	MOV R5,R1		;START OF SYMROL
	SUB R0,R1		;-SIZE TO MOVE = DESTINATION @
	CLC
	ROR R0			;WORDS TO MOVE
	MOV R1,R2		;VALUE TO SET STACK WHEN DONE (DESTINATION)
	MOV SP,R3		;GET CURRENT STACK POINTER (SOURCE)
30$:	MOV (R3)+,(R1)+		;COPY STACK UP
	SOB R0,30$
	MOV R2,SP		;MOVE THE STACK
40$:	RET			;DONE
	.PAGE
ATTRIB:	MOV R1,-(SP)		;SAVE R1
	CLR R0
	BITB #S.REL,SYMBOL+FLAGS ;TRUE?
	BNE 10$			;YES
	TST (R0)+
10$:	MOV PM.REL(R0),R1	;POINT TO REL,
	CALL MOVBYT		;PASS TEXT
	CLR R0
	BITB #S.OVR,SYMBOL+FLAGS ;TRUE?
	BNE 20$			;YEP
	TST (R0)+
20$:	MOV PM.OVR(R0),R1	;POINT TO OVR,
	CALL MOVBYT		;PASS TEXT
	CLR R0
	TST SWO			;/O?
	BEQ 30$			;NOPE
	CMP (R0)+,(R0)+		;BUMP UP
	BITB #S.DATA,SYMBOL+FLAGS
	BR 40$
30$:	BITB #S.BSE,SYMBOL+FLAGS
40$:	BNE 50$			;BASE
	TST (R0)+
50$:	MOV PM.BSE(R0),R1	;POINT TO BSE,
	CALL MOVBYT		;PASS TEXT
	MOV (SP)+,R1
	RET

	.ENABL LSB
	ENTSEC MSGS
10$:	.ASCIZ \REL\
20$:	.ASCIZ \ABS\
	XITSEC

PM.REL:	.WORD 10$,20$

	ENTSEC MSGS
30$:	.ASCIZ \,OVR\
40$:	.ASCIZ \,CON\
	XITSEC

PM.OVR:	.WORD 30$,40$

	ENTSEC MSGS
50$:	.ASCIZ \,BSE  \
60$:	.ASCIZ \      \
70$:	.ASCIZ \,DAT  \
80$:	.ASCIZ \,INS  \
	XITSEC

PM.BSE:	.WORD 50$,60$,70$,80$
	.DSABL LSB
	.PAGE
	.SBTTL INTMAP - Initialise for load map output
	.ENABL LSB

INMAP:	.GTIM #WA,#LTIME	;Get time of day
	.DATE			;Get current date
	MOV R0,LDATE
	MOV #MAP,R1		;Point to map file spec
	TST (R1)		;Map file requested?
	BNE 10$			;Yes, continue
	RET			;Else just exit

10$:	.FETCH BOTTOM,R1	;GET OUTPUT DEVICE
	BCC 20$			;OK

ILLDVC:	MSGF <Illegal device. >,128
	BR 30$			;ERROR EXIT

20$:	MOV R0,BOTTOM		;UPDATE FREE SPACE POINTER
	ADD #128,R0		;MOVE THE LOWERLIMIT
	MOV R0,STLLIM
	ADD #128,R0
	MOV R0,STGARD
	.CLOSE #1		;CLAIM CHANNEL 1
	.ENTER #WA,#1,R1,8(R1)	;Open output channel 1 for map file
	BCC 40$

OFTO:	MSGF <output file failed to open. >,128
30$:	TFILE R1

40$:	MOV #MBUF,MBP		;SET OUTPUT POINTER
	CMP (R1),#^RTT 		;MAP OUTPUT TT:?
	BNE 50$			;NOPE
	MOV SP,TTMAP		;SIGNAL YES
50$:	MOV #TTIME,R2		;Point to title time area
	MOV #LTIME,R0		;POINT TO 2 WORD TIME CODE
	CALL UNPTIM		;Convert time to ASCII
	MOV #TDATE,R2
	MOV LDATE,R0
	CALL UNPDAT		;Convert date to ASCII
	MOV #OUT,R0
	CALL CVFNLB		;Convert output file name to ASCII
	MOV #57,LINCNT		;60 lines per page (-3 for title lines)
	MOV #LB,R1
	MOV #TIFN,R2		;Point to title region
	CALL MOVBYT		;Put filename into title region
60$:	MOVB #' ,(R2)+		;Blank fill
	CMP R2,#TIFN+14
	BLO 60$
	MOV CSEND,R0		;POINT TO END OF C.S.
	CLRB -2(R0)		;ZAP THE LAST CR,LF'S
	PRINT #CSBUFF,CSLCNT,CSLCNT	;Print command string
	RET			;DONE WITH THIS PHASE
	.DSABL LSB

	ENTSEC IMPURE
LINCNT:	.BLKW 2
HILIMI:	.BLKW
	XITSEC
	.PAGE
SUMFIL:	TST MAP			;ANY MAP?
	BNE 10$			;YEP
	RET			;ELSE DONE WITH THIS TOO

10$:	PRINT #FNSMRY,#$FNSMR,#$FNSMR-2	;PRINT FILE NAME SUMMARY
	MOV #1,R4		;CHANNEL #
	CLR ROLUPD		;START AT BEGINING
	TST SCHAN		;.LNK FILE?
	BEQ 20$			;NOPE
	NEXT FILROL		;YEP. SKIP IT
20$:	MOV #LB,R2		;POINT TO LINE BUFFER
	NEXT FILROL		;GET FILE NAME
	BEQ 70$			;END
	MOV #SYMBOL,R0
	CALL CVFN		;PRINT FILE NAME
	MOV R0,R2		;UPDATE POINTER
30$:	MOVB #' ,(R2)+		;BLANK FILL
	CMP R2,#LB+16
	BLO 30$
	MOV ROLUPD,-(SP)	;SAVE POSITION
	TST SYMBOL+8		;OPTIONS?
	BEQ 40$			;NOPE
	MOV #OPTMSG,R1		;YEP, POINT TO OPTIONS MESSAGE
	CALL MOVBYT		;COPY IT TO LINE BUFFER
	BR 60$			;AND PRINT IT
	
40$:	MOV #SYMBOL,R1		;POINT TO SYMBOL SPACE
	MOV R4,(R1)+		;PASS CHANNEL #
	SCANW MODROL		;LOOK FOR MODULE NAME
	CALL SYMTOA		;UNPACK IT
	SCANW IDNROL		;LOOK FOR .IDENT
	CALL SYMTOA		;UNPACK IT
	CLRB (R2)		;  (IN CASE NO 'TIME' PRESENT.)
	SCANW TIMROL		;LOOK FOR TIME/DATE CODES
	BEQ 60$			;NO DATE/TIME/LANG OR OTHER FLAGS
	MOV 4(R1),R0		;GET DATE CODE
	CALL UNPDAT		;CONVERT TO ASCII
	MOV R0,R2		;UPDATE BUFFER POINTER
	MOVB #' ,(R2)+		;FOLLOW WITH 2 BALNKS
	MOVB #' ,(R2)+
	MOV R1,R0		;POINT TO 2 WORD TIME CODE
	CALL UNPTIM		;CONVERT TO ASCII
	CLRB (R0)		;TERMINATE LINE IN CASE NO LANG AND STUFF
	MOV R0,R2		;UPDATE POSITION
	SCANWC TIMROL		;CONTINUE LOOKING FOR STUFF
	BEQ 60$			;DIDN'T FIND ANY
	MOVB #' ,(R2)+		;FOLLOW WITH 2 BALNKS
	MOVB #' ,(R2)+
	CALL SYMTOA		;DISPLAY LANGUAGE PROCESSOR
	CLRB (R2)		;SET TERMINATOR IN CASE OF NO ERRORS
	MOV #SYMBOL+6,R5	;POINT TO ERROR/WARN COUNT WORD
	TSTB (R5)+		;ANY ERRORS?
	BEQ 50$			;NOPE
	MOV #ERRDET,R1		;ELSE COPY IN ERRORS DETECTED MESSAGE
	CALL MOVBYT
	CLR R1
	BISB -1(R5),R1		;GET ERROR COUNT
	MOV #1,DNCDIG		;ONLY 1 DIGIT REQUIRED
	CALL DNC		;DISPLAY IT IN DECIMAL
	CLRB (R2)		;TERMINATE
50$:	TSTB (R5)		;ANY WARNINGS?
	BEQ 60$			;NOPE
	MOV #WARDET,R1		;ELSE COPY IN WARNINGS DETECTED
	CALL MOVBYT
	CLR R1
	BISB (R5),R1
	CALL DNC		;DISPLAY THE NUMBER OF WARNINGS	IN DECIMAL
	CLRB (R2)		;TERMINATE
60$:	PRINT #LB		;PRINT THE LINE
	MOV (SP)+,ROLUPD	;RESTORE FILE NAME POSITION
	INC R4			;NEXT CHANNEL
	BR 20$			;CONTINUE

70$:	RET			;EXIT

	ENTSEC MSGS
OPTMSG: .ASCIZ \Options file\
ERRDET: .ASCIZ \  Errors detected: \
WARDET: .ASCIZ \  Warnings detected: \
	XITSEC
	.PAGE
	.SBTTL P2GSS - Global symbol summary to load map
P2GSS:	TST MAP			;Any map output?
	BNE 10$			;yep. continue
	RET			;just exit

10$:
	TST XCRF		;CROSS-REF DISABLED?
	BNE 30$			;YEP, DON'T DO IT THEN
	TST SWR			;CROSS-REFERENCE REQUESTED?
	BEQ 30$			;NO.
	TST STWARN		;ANY X-REF?
	BNE 30$			;NOPE, CAN'T DO A /R THEN
	PRINT #GSMRY,#$GSMR,#$GSMR-2	;GLOBAL SYMBOL SUMMARY
	MOV #SYMBOL,R1		;POINT TO SYMBOL AREA
	CLR ROLUPD		;START AT BEGINING

20$:	NEXT SYMROL		;GET SYMBOL
	BEQ 120$			;END
	BIT #S.DEF,FLAGS(R1)	;DEFINED?
	BEQ 20$			;NOPE. SKIP IT
	MOV #LB,R2		;POINT TO START OF BUFFER
	CALL SYMTOA		;PRINT SYMBOL
	MOV VALUE(R1),R0	;GET VALUE
	CALL OUTNUM		;DISPLAY IT
	CALL REFRNC		;DISPLAY REFERENCES
	BR 20$			;CONTINUE

30$:	MOV ROLTOP+SYMROL,R1
	SUB ROLBAS+SYMROL,R1	;COMPUTE SIZE OF ROLL
	BLOS 120$		;EMPTY
	CLR R0
	DIV #RS.SYM*2*8,R0	;COMPUTE TOTAL # OF LINES TO BE PRINTED
	TST R1			;ANY REMAINDER?
	BEQ 40$			;NOPE.
	INC R0			;ROUND UP TO NEXT LINE
40$:	MOV R0,-(SP)		;SAVE TOTAL LINE COUNT
	TST -(SP)		;PUT A HOLE ON STACK
	MOV ROLBAS+SYMROL,-(SP)	;POINT TO ROLL
	PRINT #GSYMS,#$GSMR,#$GSMR-2
	MOV LINCNT+2,R4		;GET LINES FREE ON PAGE

50$:	SUB R4,4(SP)		;TAKE FROM TOTAL
	BPL 60$			;OK
	ADD 4(SP),R4		;USE RESIDUAL LINE COUNT
60$:	MOV R4,R0
	MOV R0,2(SP)		;SAVE PAGE LINE COUNT
	IMULI RS.SYM*2,R4	;BYTES/COLUMN
	.PAGE
70$:	CLR R3			;ITEM COUNTER
	MOV #LB,R2		;BUFFER POINTER
	MOV #8,R5		;COLUMN COUNTER

80$:	MOV (SP),R1		;POINT TO ROLL
	ADD R3,R1		;POINT TO ENTRY
	CMP R1,ROLTOP+SYMROL	;OFF THE END?
	BHIS 100$		;YES. TERMINATE LINE
	CALL SYMTOA		;PRINT SYM
	DEC R2			;BACKUP 1 BYTE
	BIT #S.SW,FLAGS(R1)	;WEAK?
	BEQ 90$		;NOPE
	MOVB #'-,-1(r2)		;else mark it so
90$:	MOV VALUE(R1),R0
	CALL OUTNUM		;PRINT VALUE
	ADD R4,R3		;POINT TO NEXT COLUMN
	SOB R5,80$		;COUNT AND COUNTINUE

100$:	CLRB (R2)		;CLOSE LINE
	PRINT #LB		;PRINT LINE
	ADD #RS.SYM*2,(SP)	;NEXT LINE
	DEC 2(SP)		;COUNT DOWN
	BGT 70$
	TST 4(SP)		;ANY MORE?
	BLE 110$			;NO
	SUB R4,R3		;ADJUST POINTER
	ADD R3,(SP)		;UPDATE SYMROL POINTER
	MOV LINCNT,R4		;GET NEW COUNT
;	INC R4			;+1
	BR 50$			;CONTINUE

110$:	ADD #6,SP		;PURGE STACK

120$:	MOV #$LL,R1		;POINT TO LOW LIMIT MESSAGE
	MOV #LB,R2		;POINT TO BUFFER
	CALL MOVBYT		;PASS TEXT
	MOV VBOTT,R0		;GET LOW LIMIT
	CMP R0,#-1		;ANY CODE GENERATED?
	BNE 130$			;YES
	CLR R0			;NO, SAY LOW = 0
130$:	CALL OUTNUM
	MOV #$HL,R1		;POINT TO HIGH LIMIT MESSAGE
	CALL MOVBYT		;PASS TEXT
	MOV HILIMI,R0		;GET HIGH LIMIT
	CALL OUTNUM
	CLRB (R2)		;BE SURE TO STOP THE LIST
	PRINT #LB,#3,#3		;PRINT HIGH LIMIT
	RET

	ENTSEC MSGS
$HL:	.ASCIZ \High limit = \
$LL:	.ASCIZ <CR><LF>\Low limit = \
	XITSEC

	.PAGE
REFRSS:	SAVREG
	MOV ROLUPD,-(SP)	;SAVE ROLL POINTER
	MOV ROLENT,-(SP)
	MOV R2,CRF.LIN		;SAVE STARTING BUFFER ADDRESS
	MOV #12,R3		;SET THE NUMBER OF NAMES/LINE
	MOV R3,CRF.IPL		;RECORD ITEMS/LINE COUNT
	CLR R5			;TOTAL COUNTER IN CASE NO REFERENCES
	CLR ROLUPD		;START AT TOP

10$:	SCANC SCRROL		;CONTINUE SCANNING SCRROL
	BEQ 20$			;EMPTY
	MOVB SYMBOL+SECT,R1	;GET CHANNEL NUMBER
	CALL GETFSP		;GET FILE SPECS
	BHIS 10$		;ILLEGAL. IGNORE IT
	ADD #2,R1		; + 2 TO SKIP OVER DEVICE NAME
	CALL SYMTOA		;DISPLAY FILE NAME
	SOB R3,10$		;COUNT AND CONTINUE
	CLRB -2(R2)		;ZAP THE 2 SPACES THAT FOLLOW THE SYMBOL
	CALL PRTCRF		;PRINT CREF LINE
	BR 10$			;CONTINUE

20$:	CLRB (R2)		;TERMINATE IN CASE OF ERROR
	TST R5			;ANYTHING PRINTED?
	BEQ 30$			;NOPE, PRINT LINE ANYWAY
	CMP R3,CRF.IPL		;ANYTHING ON THE LINE?
	BEQ 40$			;NEVER MIND
30$:	MOV CRF.TT,TTKEY	;SET TO PRINT TO TT: IF NECESSARY
	PRINT #LB		;DISPLAY IT

40$:	MOV (SP)+,ROLENT	;RESTORE ROLL CONTROLS
	MOV (SP)+,ROLUPD
	RET

	ENTSEC IMPURE
CRF.TTK: .BLKW			;ENABLE TTY OUTPUT
CRF.LIN: .BLKW			;LINE BUFFER START
CRF.IPL: .BLKW			;ITEMS/LINE REG
	XITSEC
	.PAGE
FLAGS	= 4
SECT	= 5
FILMAP	= 6
.IIF NE,DEB$,.ENABL LSB
REFRNC:	SAVREG
	MOV ROLUPD,-(SP)	;SAVE ROLL POINTER
	MOV ROLENT,-(SP)
	MOV #14,R3		;14 ITEMS PER LINE
	MOV R3,CRF.IPL
	MOV R2,CRF.LIN		;SAVE STARTING BUFFER ADDRESS
	CLR R5			;TOTAL COUNTER IN CASE NO REFERENCES
	SEARCH CRFROL		;LOOK IN CRFROL FOR X-REFERENCES
.IF NE,DEB$
	BNE 10$			;FOUND ONE
	MSG <Empty X-ref ROL>
	BR 80$			;EXIT
10$:
.IFF
	BEQ 80$			;THERE AREN'T ANY.
.ENDC
	MOV #TMPSYM,R2
	MOV #SYMBOL,R1
	CALL XMIT0-<RS.CRF*2>	;COPY SYMBOL NAME AND REF BITS INTO TEMPSYM
	SEARCH MLDROL		;LOOK IN MULTIPLE DEFINITION ROLL TOO
	MOV CRF.LIN,R2		;RESTORE R2
	MOVB TMPSYM+SECT,R1	;GET CHANNEL # THAT DEFINED SYMBOL
	BEQ 20$			;ITS UNDEFINED, DON'T MESS WITH IT
	CALL GFILBIT		;GET FILE BIT
	BISB R1,SYMBOL+FILMAP(R0) ;INSERT THE "DEFINED HERE" BIT

20$:	CLR R4			;MAP INDEX
30$:	TST TMPSYM+FILMAP(R4)	;ANY REFERENCES IN THIS GROUP?
	BEQ 70$			;NOPE, SKIP UP TO NEXT GROUP
	MOV #1,R1		;FLYING BIT MAP
	CLR R0			;POSITION OF BIT
40$:	BIT R1,TMPSYM+FILMAP(R4)	;REFERENCED IN THIS FILE?
	BEQ 60$			;NOPE
	BIT R1,SYMBOL+FILMAP(R4)	;DEFINED IN THIS FILE?
	BEQ 50$			;NOPE
	SEC			;ELSE SIGNAL SAME TO DISREF
50$:	CALL DISREF		;YEP, DISPLAY FILENAME
60$:	INC R0			;BUMP POSITION #
	ASL R1			;MOVE BIT
	BCC 40$			;KEEP LOOKING
70$:	TST (R4)+		;BUMP THE INDEX
	CMP R4,#10		;OVERFLOW?
	BLT 30$			;NOPE, KEEP LOOKING

80$:	CLRB (R2)		;TERMINATE IN CASE OF ERROR
	TST R5			;ANYTHING PRINTED?
	BEQ 90$			;NOPE, PRINT LINE ANYWAY
	CMP R3,CRF.IPL		;ANYTHING ON THE LINE?
	BEQ 100$			;NEVER MIND
90$:	MOV CRF.TT,TTKEY	;SET TO PRINT TO TT: IF NECESSARY
	PRINT #LB		;DISPLAY IT

100$:	MOV (SP)+,ROLENT	;RESTORE ROLL CONTROLS
	MOV (SP)+,ROLUPD
	RET
.IIF NE,DEB$,.DSABL LSB
DISREF:	MOV R0,-(SP)		;SAVE SOME REGS
	MOV R1,-(SP)
	MOV R4,-(SP)
	ROR -(SP)		;SAVE DEFINED FLAG
	ASL R4			;COMPUTE CHANNEL #
	ASL R4
	ASL R4
	ADD R0,R4		
	MOV R4,R1
	INC R1
	CALL GETFSP		;GET FILE SPECS
	BHIS 30$		;ILLEGAL, IGNORE IT
	ADD #2,R1		;+2 TO SKIP OVER FILE NAME
	CALL SYMTOA		;DISPLAY FILE NAME
	TST (SP)		;DEFINED HERE?
	BPL 20$			;NOPE
	MOV R2,R0		;POINT TO CURRENT POSITION
10$:	CMPB -(R0),#' 		;BACK UP TO FIRST NON-BLANK
	BEQ 10$
	MOVB #'#,1(R0)		;MARK SYMBOL AS DEFINED
20$:	DEC R3
	BGT 30$			;OK
	CLRB -2(R2)		;ZAP THE 2 SPACES THAT FOLLOW THE SYMBOL
	CALL PRTCRF		;PRINT CREF LINE
30$:	TST (SP)+		;PURGE DEFINED FLAG
	MOV (SP)+,R4		;RESTORE REGS
	MOV (SP)+,R1
	MOV (SP)+,R0
	RET

PRTCRF:	MOV #LB,R2		;POINT TO LINE BUFFER
	MOV CRF.TT,TTKEY	;SET TO PRINT TO TT: IF NECESSARY
	PRINT R2		;PRINT IT
	INC R5			;COUNT LINE
	MOV CRF.LIN,R0		;STARTING POINT
	SUB R2,R0		;COMPUTE SIZE OF FILL AREA
10$:	MOVB #' ,(R2)+		;CLEAR IT
	SOB R0,10$
	MOV CRF.IPL,R3		;RESET R3
	RET

FILBIT:	MOVB CHAN,R1		;START WITH CURRENT CHANNEL #
	CALL GFILBIT		;GET THE BITS
	BISB R1,SYMBOL+FILMAP(R0)	;INSERT BIT INTO ARRAY
	RET

GFILBIT:DEC R1			;MAKE CHAN # RELATIVE TO 0
	MOV R1,R0		;NEED 2 COPIES
	ASR R1			;GET A BYTE INDEX
	ASR R1
	ASR R1
	BIC #-8,R0		;ISOLATE BIT NUMBER
	INC R0			;+1 SO SOB WORKS
	MOV R1,-(SP)		;SAVE THE BYTE INDEX
	CMP R1,#10		;C=1 IF (SP) =0-9 ELSE C=0
	BIC R1,R1		;ZAP R1 WITHOUT MESSING THE CARRY
10$:	ROL R1			;PUT THE BIT IN THE BYTE
	SOB R0,10$
	BISB (SP)+,R0		;RETURN WITH BIT IN R1 AND INDEX IN R0
	RET
	.PAGE
P2UDF:	CLR ROLUPD		;FIND UNDEFINED GLOBALS
	CLR R5			;ITEM COUNTER
	MOV SP,CRF.TTK		;SIGNAL ALL OUTPUT GOES TO TT: TOO
	MOV #SYMBOL,R1
10$:	NEXT SYMROL		;GET SYMBOL
	BEQ 30$			;END
	BIT #S.DEF,FLAGS(R1)	;DEFINED?
	BNE 10$			;YEP. SKIP IT
	TST R5			;FIRST TIME THRU?
	BNE 20$			;NOPE
	MOV SP,TTKEY		;SIGNAL TO TYPE TOO
	PRINT #UDFGLB,#$UDF,#$UDF-2	;PRINT UNDEF GLOBL MESSAGE
	INCB LERRS		;COUNT ERRORS
20$:	INC R5			;COUNT IT
	TST XUDF		;SUPPOSED TO IGNORE UDF MSGS?
	BNE 30$			;YEP, JUST LOOK THROUGH THE TABLE
	MOV #LB,R2		;POINT TO BUFFER
	CALL SYMTOA		;PRINT SYMBOL
	MOVB #' ,(R2)+		;SEPERATE FIELDS
	MOVB #' ,(R2)+
	CLRB (R2)		;IN CASE OF ERRORS
	CALL REFRNC		;DISPLAY REFERENCES
	BR 10$			;CONTINUE

30$:	CLR CRF.TTK
	RET			;EXIT

SYMTOA:	MOV (R1),R0		;GET FIRST WORD
	CALL R50TOA		;CONVERT TO ASCII
	MOV R0,R2		;UPDATE POINTER
	MOV 2(R1),R0		;GET SECOND WORD
	CALL R50TOA		;CONVERT TO ASCII
	MOV R0,R2		;UPDATE POSITION
	MOVB #' ,(R2)+		;FOLLOW WITH 2 SPACES
	MOVB #' ,(R2)+
	CLRB (R2)		;TERMINATE IN CASE LAST THING ON LINE
	RET			;EXIT


	ENTSEC IMPURE
TTKEY:	.BLKW
TTMAP:	.BLKW
VBOTT:	.BLKW
VTOP:	.BLKW
CURLOC:	.BLKW
CURSEC:	.BLKW
	XITSEC
	.SBTTL P2MDF - Output multiple definition roll
P2MDF:	CLR ROLUPD		;FIND UNDEFINED GLOBALS
	CLR R5			;ITEM COUNTER
	MOV SP,CRF.TTK		;SIGNAL ALL OUTPUT GOES TO TT: TOO
	MOV #SYMBOL,R1
	TST MDFCNT		;ANY ERRORS?
	BEQ 40$			;NOPE
	TST XMDF		;SUPPOSED TO IGNORE MDF'S?
	BNE 20$			;YEP, SKIP RIGHT TO MESSAGE

10$:	NEXT MLDROL		;GET SYMBOL
	BEQ 40$			;END
	BIT #S.MDF,FLAGS(R1)	;REALLY MULTIPLY DEFINED?
	BEQ 10$			;NOPE, SKIP IT
	TST R5			;FIRST TIME THRU?
	BNE 30$			;NOPE
20$:	MOV SP,TTKEY		;SIGNAL TO TYPE TOO
	PRINT #MDFSYM,#$MDF,#$MDF-2	;PRINT/TYPE MULT DEF MESSAGE
	INCB LERRS
30$:	INC R5			;COUNT IT
	TST XMDF		;SUPPOSED TO IGNORE MDF'S?
	BNE 40$			;YEP, WE'RE DONE THEN
	MOV #LB,R2		;POINT TO BUFFER
	CALL SYMTOA		;PRINT SYMBOL
	MOVB #' ,(R2)+		;SEPERATE FIELDS
	MOVB #' ,(R2)+
	CLRB (R2)		;IN CASE OF ERRORS
	CALL REFRNC		;DISPLAY REFERENCES
	BR 10$			;CONTINUE

40$:	CLR CRF.TTK
	RET			;EXIT
	.PAGE
	.SBTTL SYMOUT- Output symbol table
	.ENABL LSB
SYMOUT:	MOV #SYM,R1
	TST (R1)		;SYMBOL OUTPUT
	BEQ 10$			;NO
	.FETCH BOTTOM,R1	;GET HANDLER
	BCC 20$
	JMP ILLDVC		;BAD
10$:	RET

20$:	MOV R0,BOTTOM		;UPDATE POINTER
	MOV R0,OBP		;START AT LOW LIMIT
	ADD #256.+512.,R0	;MAKE ROOM FOR A BUFFER AND STK CUSHION
	CMP SP,R0		;TOO BIG?
	BHIS 35$		;NOPE
34$:	MSGF <Too many symbols, no room for output buffer. >,128.
	TFILE #SYM

35$:	CLR OBLOCK		;MAKE SURE TO START AT BLOCK 0
	.CLOSE #2		;CLAIM A CHANNEL
	.ENTER #WA,#2,R1,8(R1)	;OPEN FILE
	BCC 30$
	JMP OFTO
30$:	MOV SWL,-(SP)		;SAVE LDA OUT FLAG
	MOV SP,SWL		;SIGNAL LDA OUTPUT
	MOV SP,R0		;GET TOP
	SUB #128.,R0
	MOV R0,STGARD		;EARLY WARNING
	SUB #128.,R0
	MOV R0,STLLIM		;LIMIT
	SUB BOTTOM,R0		;-BOTTOM @ = SIZE OF BUFFER
	BIC #511.,R0		;ROUND TO BLOCK BOUNDARY
	BEQ 34$			;NO ROOM
	MOV R0,OSIZE		;SAVE SIZE IN BYTES
	ADD BOTTOM,R0		;+ BOTTOM @
	MOV R0,TOP		;= TOP LIMIT
	MOV #.ABS.,R1
	MOV #TBLA,R2
	MOV #.ABSIZ/2,R0
40$:	MOV (R1)+,(R2)+
	SOB R0,40$
	MOV #.ABSIZ,TBSIZ
	CALL FLTXT
	MOV ROLTOP+SYMROL,R5	;POINT TO TOP OF SYMBOL ROLL
	MOV ROLBAS+SYMROL,R4	;POINT TO BOTTOM OF SYMBOL ROLL
50$:	MOV #5,R3		;TRY FOR 5 SYMBOLS/BLOCK
	MOV #TB,R2		;POINT TO TEXT BUFFER
60$:	MOV R2,R0		;SAVE STARTING POINT
	MOV (R4)+,(R2)+		;PASS SYMBOL
	MOV (R4)+,(R2)+
	MOV (R4)+,(R2)+		;+ FLAGS
	MOVB #4,-1(R2)		;TYPE 4 = GLOBAL DEFINITION
	MOV (R4)+,(R2)+		;+ VALUE
	BICB #^CS.DEF,-4(R2)	;ZAP ALL BUT DEFINED FLAG
	BEQ 70$			;NDF, SO FORGET IT
	TST WSFLAG		;WEAK/STRONG STUFF?
	BEQ 80$			;NOPE, EVERYTHING GOES
	MOV -4(R4),-(SP)	;GET THE FLAG BIT
	ADD WSFLAG,(SP)		;XOR WSFLAG,FLAGS
.IIF NE,S.SW-1,.ERROR S.SW ;ASSUMES S.SW TO BE BIT 0 IN FLAGS!!!!
	ROR (SP)+		;TEST IT
	BCC 80$			;IF 0, THEN IT GOES
70$:	MOV R0,R2		;ELSE IT STAYS, SO FIX THE POINTER
	INC R3			;AND DON'T COUNT IT
80$:	CMP R4,R5		;AT THE LIMIT?
	BHIS 90$		;YEP, WE'RE DONE THEN
	SOB R3,60$
90$:	SUB #TB,R2		;ANYTHING THERE?
	BEQ 100$		;NOPE, EMPTY RECORD
	ADD #2,R2		;+2 FOR GSD TYPE
	MOV R2,TBSIZ
	CALL FLTXT
	CMP R4,R5		;ANY MORE?
	BLO 50$			;YEP
100$:	MOV #ENDGSD,TBLA
	MOV #2,TBSIZ
	CALL FLTXT		;ENDGSD
	MOV #ENDMOD,TBLA
	CALL FLTXT		;ENDMOD
	CALL FOUT		;FLUSH
	.CLOSE #2		;FINISH
	MOV (SP)+,SWL		;RESTORE
110$:	RET
	.DSABL LSB

	ENTSEC PURE
.ABS.:	.WORD GSD		;GSD TYPE RECORD
LTIME:	.BLKW 2			;TIME
	.WORD 2*256		;ISD TYPE
LDATE:	.BLKW			;DATE
	.RAD50  \LINKM \	;PROGRAM NAME
	.WORD 2*256		;2ND ISD IS PROGRAM NAME
LERRS:	.BLKB			;.NE. IF ERRORS
LWRNS:	.BLKB			;.NE. IF WARNINGS
	.RAD50	\. ABS.\	;. ABS. SECTION
	.BYTE S.M68!S.OVR!S.DEF	;ABS/OVRLAYED AND EXTRA STUFF SO IT MATCHES
	.BYTE 5			;PSECT
	.WORD 0			;LENGTH
.ABSIZ = .-.ABS.
	XITSEC
	.PAGE
	.SBTTL GETTOP CHECK FOR .VCTRS/.FILL DIRECTIVES

FILL	=^O20			;RLD FOR .FILL

GETTOP:
10$:	CMP (R5)+,#TXT		;TXT RECORD?
	BNE 50$			;NOPE. TRY FOR RLD
	TST CURSEC		;.ABS. SECTION?
	BNE 40$			;NOPE. NEVER MIND
	CMP (R5),VBOTT		;LOOK FOR BOTTOM ADDRESS
	BHIS 20$
	MOV (R5),VBOTT
20$:	SUB #4,R0		;TEXT COUNT = RECORD COUNT -2 (TYPE) -2 (L.A.)
	ADD (R5),R0		;COMPUTE TOP ADDRESS
	BCC 30$
	MOV #-1,R0
30$:	CMP R0,VTOP		;AT LIMIT?
	BLOS 40$			;NOPE, CONTINUE
	MOV R0,VTOP		;RECORD NEW LIMIT
40$:	RET

50$:	CMP -2(R5),#RLD		;RLD RECORD?
	BNE 40$			;NOPE

60$:	BIC #-32,(R5)		;ZAP UNUSED BITS
	CMP (R5),#FILL		;.FILL CHAR?
	BNE 70$			;NOPE
	MOV 2(R5),FILLC		;PASS IT
	BR 40$			;CONTINUE

70$:	CMP (R5),#7		;.LCD?
	BNE 40$			;NOPE, NEVER MIND
	MOV (R5)+,CURSEC	;PASS SECTION CODE
	CMP (R5)+,#^R. A	;. ABS.?
	BNE 40$			;NOPE
	CMP (R5)+,#^RBS.
	BNE 40$			;NOPE
	CLR CURSEC		;SIGNAL .ABS. SECTION
	BR 40$			;TEST AND CONTINUE
	.SBTTL	CREBIN OUTPUT CREATION

	ENTSEC IMPURE
FILLC:	.BLKW			;FILL CHARACTER
OSIZE:	.BLKW			;OUTPUT BUFFER SIZE
OPOS:	.BLKW			;RELATIVE C OF BUFFER
TOP:	.BLKW
OBLKS:	.BLKW
	XITSEC
	.ENABL LSB
CREBIN:
.IIF NE,DEB$,MSG <Create binary output>
	CMP VTOP,HILIMI		;.VCTRS/.CKSUM USED?
	BHIS 10$			;YEP
	MOV HILIMI,VTOP		;UPDATE HIGH LIMIT.

10$:	MOV #OUT,R1
	TST (R1)		;OUTPUT WANTED?
	BNE 20$			;YEP
	RET			;NOPE

20$:	.FETCH BOTTOM,R1	;GET DVC
	BCC 30$			;OK
	JMP ILLDVC

30$:	MOV R0,BOTTOM		;UPDATE LO LIMIT
	MOV R0,OBP		;POINT TO BUFFER
	MOV SP,R0		;GET TOP ADDR
	CLR R1
	BISB ROLSIZ+SECROL+1,R1	;GET NUMBER OF SECTIONS
	IMULI RS.RLD*2,R1	;*SIZ OF SECROL IN BYTES
	SUB R1,R0		;LEAVES ROOM FOR SECROL GROWTH
	SUB #256.+512.,R0	;ALLOW 200 WORD STACK AND 1 BLOCK BUFFER
	CMP R0,BOTTOM		;ROOM?
	BHIS 35$		;YEP
34$:	MSGF <Too many symbols, no room for output buffer. >,128.
	TFILE #OUT

35$:	ADD #512.,R0		;RE-ADJUST THE BUFFER
	SUB BOTTOM,R0		;COMPUTE BUFFER SIZE
	BIC #511,R0		;ROUND TO BLOCK BOUNDARY
	BEQ 34$			;NO ROOM
	MOV R0,OSIZE		;KEEP SIZE OF OUTPUT BUFFER IN BYTES
	ADD BOTTOM,R0
	MOV R0,TOP
	ADD #128.,R0		;SET THE LOWER LIMIT
	MOV R0,STLLIM
	ADD #128.,R0
	MOV R0,STGARD		;SET EARLY WARNING
	.CLOSE #2		;CLAIM CHANNEL
	CLR R2
	TST SWL			;.LDA?
	BNE 40$			;YEP. GET 1/2 LARGEST EMPTY SPACE
	MOV VTOP,R2		;GET TOP ADDRESS
	INC R2			;WORD BOUNDARY
	ROR R2			;IN WORDS
	ADD #255,R2		;ROUND TO BLOCK BOUNDARY
	CLRB R2
	SWAB R2
40$:	.ENTER #WA,#2,#out,R2	;OPEN FILE
	BCC 50$			;OK
	JMP OFTO		;OUTPUT FAILED TO OPEN

50$:	MOV R0,OBLKS		;SAVE SIZE OF OUTPUT FILE
	TST SWL			;.LDA OUTPUT?
	BNE 100$			;YES. DON'T PRE-FILL
	MOV FILLC,R1		;GET FILL CHARACTER
	MOV OSIZE,R2		;GET OUTPUT BUFFER SIZE
	MOV BOTTOM,R0		;GET BOTTOM ADDRESS
	MOV OBLKS,R3		;GET SIZE OF OUTPUT FILE IN BLOCKS
	SWAB R3			;  COMPUTE SIZE IN WORDS
60$:	MOVB R1,(R0)+		;FILL UP BUFFER
	SOB R2,60$
	MOV OSIZE,R1		;GET OUTPUT BUFFER SIZE IN BYTES
	CLC
	ROR R1			;IN WORDS
70$:	SUB R1,R3		;TAKE FROM TOTAL
	BHIS 80$			;OK
	ADD R3,R1		;ELSE USE RESIDUAL
80$:	.WRITW #WA,#2,BOTTOM,R1,R2
	BCC 90$
	TSTB @#ERRBYT		;ERROR?
	BEQ 100$			;EOF
ERRO:	MSGF <Error writing output. >,128
	TFILE #OUT

90$:	SWAB R0
	ADD R0,R2
	TST R3			;ANYMORE?
	BGT 70$			;YEP. CONTINUE

100$:	CLR TBSIZ		;MAKE SURE TXT BUFFER IS EMPTY
	CLR OBLOCK		;MAKE SURE TO START AT 0
	.DSABL LSB

P50:	ZAP RLDROL		;PURGE RLDROL
P51:	CALL READR		;GET RECORD
	BNE 20$
	CALL FLTXT		;FLUSH OUT TXT BUFF
	TST SWL			;.LDA OUTPUT?
	BEQ 10$			;NOPE
	MOV XFERAD,TBLA		;PASS XFER ADDRESS
	MOV #2,TBSIZ
	CALL FLTXT		;WRITE A EOF RECORD
10$:	CALL FOUT		;FLUSH OUTPUT
	.CLOSE #2		;DONE
	RET

20$:	MOV R0,R4		;KEEP BYTE COUNT OF RECORD
	SUB #2,R4		;-2 FOR TYPE CODE
	MOV #RBUFF,R5		;POINT TO BUFFER
	MOV (R5)+,R0		;GET TYPE CODE
	CMP R0,#RTMAX		;LEGAL?
	BLO P52
JBO:	JMP BADOBJ		;NOPE

P52:	ASL R0
	JMP @RTABL(R0)

RTABL:	.WORD JBO		;0=BAD OBJ
	.WORD R.GSD		;GSD TYPE
	.WORD P51		;ENDGSD (NOP)
	.WORD R.TXT		;TXT RECORD
	.WORD R.RLD		;RLD RECORD
	.WORD P51		;ISD (NOP)
	.WORD P50		;ENDMOD (PURGE RLDROL)
RTMAX=.-RTABL/2
	.PAGE

R.GSD:	MOVB 5(R5),R0		;GET TYPE
	ASL R0
	MOV R5,-(SP)		;SAVE POINTER
	MOV #SYMBOL,R3		;POINT TO ROLL WORK SPACE
	ADD R0,PC		;GO TO ROUTINE
	BR R.GSDN		;MODULE NAME
	BR R.CSCT		;CSECT
	BR R.GSDN		;INTERNAL SYMBOL
	BR R.XFER		;XFER ADDR
	BR R.GSDN		;GLOBL SYMBOL
	BR R.PSCT		;PSECT
	BR R.GSDN		;.IDENT
	BR R.GSDN		;.VIR

R.GSDN:	MOV (SP)+,R5		;RESTORE POINTER
	ADD #8,R5		;BUMP UP
	SUB #8,R4		;COUNT DOWN
	BGT R.GSD
	BR P51			;CONTINUE

R.XFER:	MOV (R5)+,(R3)		;GET SYMBOL
	MOV (R5)+,2(R3)
	CLR ROLUPD		;START AT THE BEGINNING
10$:	SCANC SECROL		;LOOK FOR THE SECTION
	BIT #S.OVR,FLAGS(R3)	;OVERLAYED?
	BNE 20$			;YES. DON'T LOOK ANY FURTHER
	CMPB CHAN,SECT(R3)	;MATCH?
	BNE 10$			;NO GET NEXT ONE

20$:	ADD 2(R5),OFFSET(R3)	;COMPUTE XFER ADDRESS
	MOV OFFSET(R3),XFERAD	;AND KEEP IT FOR LATER
	BR R.GSDN

R.CSCT:
R.PSCT:	MOV (R5)+,(R3)		;PASS SYMBOL
	MOV (R5)+,2(R3)
	CLR ROLUPD
10$:	SCANC SECROL		;GET SECTION STUFF
	BIT #S.OVR,FLAGS(R3)	;OVERLAYED?
	BNE 20$			;YES. DON'T LOOK ANY FURTHER
	CMPB CHAN,SECT(R3)	;MATCH?
	BNE 10$			;NO GET NEXT ONE

20$:	MOV OFFSET(R3),FLAGS(R3);SET VALUE
	APPEND RLDROL		;PUT IT IN RLDROL
	BR R.GSDN

R.TXT:	CALL FLTXT		;FLUSH OUT TXT BUFFER
	MOV R4,TBSIZ		;SAVE BYTE COUNT
	BLE P51
	MOV #TBLA,R1		;POINT TO TXT BUFFER
10$:	MOVB (R5)+,(R1)+	;COPY IT
	SOB R4,10$
	ADD CURLOC,TBLA		;POSITION TXT
	BR P51

	ENTSEC IMPURE
TBSIZ:	.BLKW
TBLA:	.BLKW
TB:	.BLKB 132
BYTMOD:	.BLKW
M68FLG:	.BLKW
XFERAD:	.BLKW 
	XITSEC
	.PAGE
R.RLD:	MOVB (R5)+,R0		;GET TYPE
	CLR R1
	BISB (R5)+,R1		;GET DISLACEMENT
	SUB #4,R1		;ADJUST DISPLACEMENT
	ASL R0
	ROR BYTMOD		;SAVE BYTE MODE FLAG
	MOVB R0,R0		;PROPAGATE M68 FLAG
	MOV R0,M68FLG		;SAVE IT
	BIC #-128,R0		;ZAP UNUSED BIT
	CMP R0,#RLDMAX		;LEGAL?
	BLO 10$
	JMP BADOBJ

10$:	MOV #SYMBOL,R3
	CLR (R3)		;START WITH NO SYMBOL
	CLR 2(R3)
	JMP @RLDTBL(R0)		;BYE

RLDTBL:	.WORD BADOBJ		;(00) BAD
	.WORD RL.IR		;(01) INTERNAL RELOCATION
	.WORD RL.GR		;(02) GLOBAL RELOCATION
	.WORD RL.IDR		;(03) INTERNAL DISPLACED RELOCATION
	.WORD RL.GDR		;(04) GLOBAL DISLACED RELOCATION
	.WORD RL.GAR		;(05) GLOBAL ADDITIVE RELOCATION
	.WORD RL.GAD		;(06) GLOBAL ADDITIVE DISLACED RELOCATION
	.WORD RL.LCD		;(07) LOCATION COUNTER DEFINITION
	.WORD RL.LCM		;(10) LOCATION COUNTER MODIFICATIION
	.WORD RL.LIM		;(11) .LIMIT
	.WORD RL.PSC		;(12) PSECT RELOCATION
	.WORD RL.VCT		;(13) .VCTRS/.CKSUM
	.WORD RL.PDR		;(14) PSECT DISLACED RELOCATION
	.WORD RL.PAR		;(15) PSECT ADDITIVE RELOCATION
	.WORD RL.PAD		;(16) PSECT ADDITIVE DISLACED RELOCATION
	.WORD RL.CMP		;(17) COMPLEX
	.WORD RL.DPG		;(20) .DPAGE directive in MAC69
RLDMAX=.-RLDTBL

RL.IR:	CALL M68MOV		;GET CONSTANT
	ADD CURLOC,R0		;+PSECT BASE
RL.M4:	SUB #4,R4		;COUNT DOWN

RL.RET:	TST BYTMOD		;BYTE MODE?
	BPL 10$			;NO
	MOVB R0,TB(R1)		;YES. PASS BYTE
	CLRB R0
	SWAB R0
	BEQ RL.NOM		;OK
	CMPB R0,DPAGE		;MATCH DPAGE?
	BEQ RL.NOM		;YEP, OK THEN
	INCB R0			;ALL 1'S?
	BEQ RL.NOM		;YEP. OK
	MOV #BRELOC,R2
	MOV TBLA,R0		;LOAD ADDRESS
	ADD R1,R0		;+ DISPLACEMENT OFFSET
	CALL E.SO		;PRINT INFO ABOUT ERROR
	PRINT #BRERR
	INCB LWRNS
	BR RL.NOM
	.PAGE
10$:	TST M68FLG		;6800 MODE?
	BMI 20$			;YES
	SWAB R0			;SWITCH AROUND
20$:	MOVB R0,TB+1(R1)
	SWAB R0
	MOVB R0,TB(R1)

RL.NOM:	TST R4
	BGT R.RLD
	JMP P51

RL.GR:	CALL RL.SYM		;LOOK UP SYMBOL IN GLOBAL TABLE
RL.PR:	SUB #6,R4		;CONT DOWN
	BR RL.RET		;STUFF IT
RL.IDR:	CALL M68MOV		;GET CONSTANT
RL.DSP:	SUB TBLA,R0		;-LOAD ADDRESS
	SUB R1,R0		;-DISLACEMENT
	DEC R0
	TST BYTMOD
	BMI 10$
	DEC R0
10$:	BR RL.M4		;TAKE 4

RL.GDR:	CALL RL.SYM		;GLOBL DSP
RL.PD:	SUB #2,R4
	BR RL.DSP

RL.GAR:	CALL RL.SYM		;GLBL ADD RGL
RL.GA:	CALL M68ADD		;ADD DISPLACMENT
	SUB #8,R4
	BR RL.RET		;DO IMMEDIATE

RL.GAD:	CALL RL.SYM
RL.PDA:	CALL M68ADD		;ADDITIVE
	SUB #4,R4		;COUNT (8-4)
	BR RL.DSP		;DO DISPLACEMENT

	.PAGE
RL.LCD:	CALL RL.RLD
	MOV R0,CURLOC		;NEW LOCATION
	MOV ROLENT,CURSEC	;RECORD CURRENT SECTOR
	DEC CURSEC		;MAKE SECTOR # RELATIVE TO 0
	TST (R5)+		;SKIP OVER CONSTANT
	SUB #8,R4
	BR RL.NOM		;NO MODIFICATION RQD

RL.LCM:	TST (R5)+		;NOP
	SUB #4,R4
	BR RL.NOM

RL.DPG:	MOV (R5)+,DPAGE		;RECORD DPAGE
	SUB #4,R4		;COUNT DOWN
	BR RL.NOM

RL.LIM:	ADD #2,R1		;LOW LIMIT IS ALWAYS 0
	MOV HILIMI,R0		;HI LIMIT
	SUB #2,R4
	BR RL.RET

RL.PSC:	CALL RL.RLD
	BR RL.PR

RL.PDR:	CALL RL.RLD
	BR RL.PD

RL.PAR:	CALL RL.RLD
	BR RL.GA

RL.PAD:	CALL RL.RLD
	BR RL.PDA

RL.VCT:	CALL RL.SYM		;.VCTRS/.CKSUM POSITION POINTER.
	CALL M68ADD		;ADDITIVE
	MOV R0,TBLA
	SUB #8,R4
	BR RL.NOM

RL.SYM:	MOV (R5)+,(R3)+
	MOV (R5)+,(R3)+
	SEARCH SYMROL
	MOV 2(R3),R0
	RET

RL.RLD:	MOV (R5)+,(R3)+
	MOV (R5)+,(R3)+
	SCAN RLDROL
	MOV (R3),R0
	RET
	.PAGE
M68MOV:	MOV (R5)+,R0		;GET CONSTANT
	TST M68FLG		;6800 MODE?
	BPL 10$			;NOPE
	SWAB R0			;SWITCH IT AROUND

10$:	TST BYTMOD		;BYTE?
	BPL 20$			;NOPE
	MOVB R0,R0		;SIGN EXTEND
20$:	RET

M68ADD:	MOV R0,-(SP)		;SAVE R0
	CALL M68MOV		;GET CONSTANT
	ADD (SP)+,R0		;ADDITIVE
	RET
	.SBTTL	COMPLEX RELOCATION

RL.CMP:	MOV R1,DSPSVE		;SAVE DISPLACEMENT
	MOV SP,R2		;SAVE STACK
	sub #2,r4		;count the cplx command and displacement
	ble bcx			;nfg if nothing left
C.NOP:	MOVB (R5)+,R0		;GET CODE BYTE
	DEC R4			;COUNT BYTE
	BLT BCX			;N.F.G.
	ASL R0			;WORD INDEX
	CMP R0,#CPXMAX		;LEGAL?
	BHIS BCX
	MOV CX(R0),-(SP)
	CLR R0
	JMP @(SP)+

BCX:	MSGF <Bad complex string (RLD). File=>,128
	TFILE

CX:	.WORD C.NOP		;0  NO-OP
	.WORD C.ADD		;1  ADDITION
	.WORD C.SUB		;2  SUBTRACTION
	.WORD C.MUL		;3  MULTIPLICATION
	.WORD C.DIV		;4  DIVISION
	.WORD C.AND		;5  AND
	.WORD C.OR		;6  OR
	.WORD C.XOR		;7 EXCLUSIVE OR
	.WORD C.NEG		;10 NEGATE
	.WORD C.COM		;11 COMPLIMENT
	.WORD C.IMM		;12 STORE IMM
	.WORD C.DSP		;13 STORE DISPLACED
	.WORD C.USD		;14 UNSIGNED DIVIDE
	.WORD c.swb		;15 swap bytes
	.WORD C.FGS		;16 GET GLOBAL SYMBOL
	.WORD C.FRV		;17 GET RELOCATABLE VALUE
	.WORD C.CNST		;20 GET CONSTANT
	.word c.HIB		;21 USE HIGH BYTE ONLY
	.word C.LOB		;22 USE LOW BYTE ONLY
	.word C.MOD		;23 MODULO
	.word BCX		;24 Unassigned
	.word C.SHL		;25 SHIFT LEFT
	.word C.SHR		;26 SHIFT RIGHT
CPXMAX=.-CX

C.ADD:	ADD (SP)+,(SP)
C.CONT:	CMP SP,R2		;OK?
	BHIS BCX		;STACK UNDER/OVERFLOW
	br c.nop

C.SUB:	SUB (SP)+,(SP)
	BR C.CONT
C.MUL:
	MOV (SP)+,R0
	MUL (SP)+,R0
	MOV R1,-(SP)
	BR C.CONT
	.PAGE
C.USD:	INC R0			;SIGNAL UNSIGNED DIVIDE
C.DIV:	MOV (SP)+,R3		;DIVISOR
	mov (sp)+,r1		;get dividend
	call c.cdiv		;do common divide stuff
	mov r0,-(sp)		;pass back result
	br c.cont		;and continue

c.cdiv:	ASR R0			;GET SIGNED/UNSIGNED FLAG IN C AND CLR R0
	bit r3,r3		;divisor?
	BNE 10$			;OK
	MOV R2,-(SP)
	MOV DSPSVE,R0
	ADD TBLA,R0
	MOV #ERRLOC,R2
	CALL E.SO		;DISPLAY FAILING ADDRESS
	PRINT #DIVBY0
	INCB LWRNS
	MOV (SP)+,R2
	clr r0			;return 0 quotient
	clr r1			;return 0 remainder
	return			;and return

10$:	BCC 20$			;SIGNED DIVIDE
	BPL 20$			;UNSIGNED, BUT DIVISOR IS +
	CMP R3,r1		;DO UNSIGNED 16 BIT DIVIDE
	BHI 40$			;DIVISOR IS BIGGER THAN DIVIDEND, ANS=0
	sub r3,r1		;compute remainder
	INC R0			;and set quotient of 1
	BR 40$

20$:	bit r1,R1		;GET DIVIDEND
	BCS 30$			;UNSIGNED, LEAVE R0 0
	SXT R0			;ELSE SIGN EXTEND IT
30$:	DIV R3,R0		;DIVIDE <R0,R1>/R3
40$:	return			;r0=quotient/r1=remainder

C.AND:	COM (SP)
	BIC (SP)+,(SP)
	BR C.CONT

C.OR:	BIS (SP)+,(SP)
	BR C.CONT

C.XOR:	MOV (SP)+,R0
	MOV (SP),R1
	BIC R0,(SP)
	BIC R1,R0
	BIS R0,(SP)
	BR C.CONT

C.NEG:	NEG (SP)
	BR C.CONT

C.COM:	COM (SP)
	BR C.CONT

C.IMM:	call c.adj		;fix up buffer, r1 and stack
	JMP RL.RET		;and go patch byte immediate mode

C.DSP:	call c.adj		;fix up buffer, r1 and stack
	ADD #4,R4		;compensate for r.dsp taking 4 from count
	JMP RL.DSP		;and go patch byte PC relative

c.adj:	mov (sp)+,r3		;get the return address
	MOV (SP)+,R0		;get the value to store
	CMP SP,R2		;stack match entry value?
	beq c.ad10		;its ok
	jmp bcx			;else its bad

c.ad10:	tst r4			;any data left in buffer?
	ble 20$			;nope, never mind about move then
	bit #1,r5		;is the pointer even?
	beq 20$			;yep, leave it alone then
	mov r5,r1		;point to our position
	dec r1			;-1
	mov r1,-(sp)		;save the new address
	mov r4,-(sp)		;save the byte count
10$:	movb (r5)+,(r1)+	;backup 1 byte
	sob r4,10$		;until all bytes are moved
	mov (sp)+,r4		;restore count
	mov (sp)+,r5		;restore address
	dec r5			;-1
20$:	MOV DSPSVE,R1		;get the offset into the text buffer
	jmp (r3)		;go back to caller

C.FGS:	MOV #SYMBOL,R3
	MOVB (R5)+,(R3)+
	MOVB (R5)+,(R3)+
	MOVB (R5)+,(R3)+
	MOVB (R5)+,(R3)+
	SEARCH SYMROL
	MOV 2(R3),-(SP)
	SUB #4,R4		;TAKE 4 BYTES FROM TOTAL
	BR jC.CONT

C.CNST:	MOVB (R5)+,-(SP)
	MOVB (R5)+,1(SP)
	SUB #2,R4		;TAKE 2 MORE BYTES FROM TOTAL
	BR jC.CONT

C.FRV:	CLR R0
	BISB (R5)+,R0		;SECTOR #
	MOVB (R5)+,-(SP)	;OFFSET WITHIN SECTOR
	MOVB (R5)+,1(SP)
	IMULI RS.RLD*2,R0
	ADD ROLBAS+RLDROL,R0
	ADD 4(R0),(SP)
	SUB #3,R4		;TAKE 3 MORE BYTES FROM TOTAL
jc.cont: jmp C.CONT
	.page
c.mod:	mov (sp)+,r3		;get divisor
	bpl 10$			;modulus is +, so ok as is
	neg r3			;else fix it
	bpl 10$			;its ok now
	inc r0			;do unsigned divide
10$:	mov (sp)+,r1		;get dividend
	call c.cdiv		;do common divide stuff
	mov r1,-(sp)		;keep only the remainder
	br jc.cont

c.swb:	swab (sp)		;swap bytes
	br jc.cont

c.shr:	mov (pc)+,r1		;prepare for a code crash
	ror (sp)		;  inner loop instruction
	br c.shx		;do common shift code

	.enabl lsb
c.shl:	mov (pc)+,r1		;prepare for the code crash
	rol (sp)		;  inner loop instruction
c.shx:	mov	r1,30$		;crash our code
	mov	(sp)+,r3	;get the shift count
	bgt	10$		;its gotta shift some
	beq	50$		;nuthin to do
	neg	r3		;fix the shift count
	bmi	40$		;its too big, give 'em a 0
	xor	#^O100,30$	;change the ROL/ROR instruction (code crash)
10$:	cmp	r3,#16.		;shifting more than 16 bits?
	bge	40$		;yep, just give 'em a 0
20$:	clc
30$:	rol	(sp)		;shift it
	sob	r3,20$		;until all shifted
	br	50$

40$:	clr	(sp)		;force a 0
50$:	br	jc.cont		;and return
	.dsabl lsb

c.hib:	clrb (sp)		;make a hole
	swab (sp)		;and put the high byte there
	br jc.cont		;continue

c.lob:	clrb 1(sp)		;zap the upper byte
	br jc.cont		;and continue

	.NLIST BEX
	ENTSEC MSGS
DIVBY0:	.ASCII	\?LINKM-W-Divide by 0: \
ERRLOC:	.BLKB 40

BRERR:	.ASCII	\?LINKM-W-Byte relocation error: \
BRELOC:	.BLKB 40
	XITSEC

	ENTSEC IMPURE
DSPSVE:	.BLKW
VIRTL:	.BLKW
	XITSEC
	.PAGE
	.SBTTL E.SO display error address
E.SO:	MOV R4,-(SP)		;SAVE SOME REGS
	MOV R3,-(SP)
	MOV R1,-(SP)
	MOV R0,-(SP)
	MOV #' ,R3		;GET A SPACE CODE FOR LATER
	MOV #SYMBOL,R1		;POINT TO SYMBOL
	MOV R1,R4		;KEEP 2 COPIES OF SYMBOL ADDRESS
	TST (R1)		;ANY SYMBOL?
	BEQ 20$			;NO, NEVER MIND
	MOVB #'",(R2)+		;IDENTIFY SYMBOL IN ERROR
	CALL SYMTOA
10$:	CMPB R3,-(R2)		;FIND LAST NON-SPACE
	BEQ 10$
	INC R2
	MOVB #'",(R2)+		;CLOSE SYMBOL FIELD
	MOVB R3,(R2)+		;FOLLOW WITH A COUPLE SPACES
	MOVB R3,(R2)+

20$:	MOV CURSEC,R0		;GET CURRENT SECTION #
	IMULI RS.RLD*2,R0	; * SECTION SIZE IN BYTES
	ADD ROLBAS+RLDROL,R0	; + ROLL ADDRESS
	MOV (R0)+,(R4)+		;PUT SECTION NAME IN SYMBOL
	MOV (R0)+,(R4)+
	MOV (R0),R4		;KEEP OFFSET
	MOVB #'[,(R2)+		;OPEN SECTION NAME FIELD
	TST (R1)		;UN-NAMED SECTION?
	BNE 30$			;NOPE, DISPLAY NAME
	MOV R4,R0		;PRINT OFFSET INSTEAD OF NAME
	CALL OUTNUM
	BR 40$			;CLEAN UP

30$:	CALL SYMTOA		;DISPLAY NAME

40$:	CMPB R3,-(R2)
	BEQ 40$			;REMOVE EXTRA SPACES
	INC R2
	MOVB #'],(R2)+		;CLOSE NAME FIELD
	MOVB #'+,(R2)+		;FOLLOW WITH A +
	MOV (SP)+,R0		;GET ABSOLUTE ADDRESS
	SUB R4,R0		;MAKE IT RELATIVE TO SECTION BOTTOM
	CALL OUTNUM		;DISPLAT IT
	MOV #M.FILE,R1		;POINT TO "file="
	CALL MOVBYT		;PASS IT
	MOV #FILEN,R0		;POINT TO CURRENT FILE NAME
	CALL CVFN		;DISPLAY IT TOO
	MOV (SP)+,R1		;RESTORE AND EXIT
	MOV (SP)+,R3
	MOV (SP)+,R4
	MOV SP,TTKEY		;SIGNAL STUFF GOES TO TT: TOO
	RET

	ENTSEC MSGS
M.FILE:	.ASCIZ \file=\
	XITSEC
	.PAGE
	.SBTTL	TXT RECORD HANDLER
FLTXT:	MOV TBSIZ,R1		;GET TEXT BUFF SIZE
	BLE 60$			;EMPTY, EXIT
	MOV R2,-(SP)
	MOV #TBLA,R2
	TST SWL			;LDA FILE?
	BNE TXTLDA		;YES
	MOV (R2),R0		;GET LOAD ADDRESS
	SUB VIRTL,R0		;IS LOAD ADDRESS IN BUFFER?
	BLO 10$			;NOPE
	CMP R0,OSIZE
	BLO 20$			;YEP
10$:	CALL FOUT		;FLUSH OUTPUT
	MOV (R2),R0		;GET LOAD ADDRESS
	BIC #511,R0		;ROUND DOWN TO BLOCK
	CALL ROUT		;READ STUFF

20$:	MOV (R2)+,R0		;COMPUTE INDEX INTO BUFFER
	SUB VIRTL,R0
	ADD BOTTOM,R0		;R0 NOW POINTS TO OUTPUT
	DEC R1
	BR 40$

30$:	MOVB (R2)+,(R0)+
40$:	DEC R1
	BLE 50$			;DONE
	CMP R0,TOP		;OFF END OF BUFFER?
	BLO 30$			;NO
	CALL FOUT		;FLUSH OUTPUT
	MOV OSIZE,R0
	ADD VIRTL,R0		;BUMP TO NEXT GROUP
	CALL ROUT		;READ IN A BUNCH
	MOV BOTTOM,R0
	BR 30$			;CONTINUE

50$:	CLR TBSIZ
	MOV (SP)+,R2
60$:	RET

TXTLDA:	ADD #4,R1		;LDA COUNT
	MOV R3,-(SP)		;SAVE R3
	MOV #1,R0		;.LDA RECORD STARTS WITH 1,0
	MOV R0,R3		;INIT THE CHECKSUM
	CALL LDAOUT
	CLR R0
	CALL LDAOUT		;0
	MOV R1,R0
	ADD R0,R3		;CHECKSUM COUNT
	CALL LDAOUT		;LSB OF COUNT
	SWAB R0
	ADD R0,R3		;+ COUNT MSB
	CALL LDAOUT		;MSB OF COUNT
	MOVB (R2)+,R0
	ADD R0,R3
	CALL LDAOUT		;ADDR LSB
	MOVB (R2)+,R0
	ADD R0,R3
	CALL LDAOUT		;ADDR MSB
	SUB #6,R1		;COUNT DOWN
	BLE 20$			;DONE
10$:	MOVB (R2)+,R0		;COPY STUFF
	ADD R0,R3
	CALL LDAOUT
	DEC R1
	BGT 10$

20$:	NEG R3			;COPY CHECKSUM
	MOV R3,R0
	CALL LDAOUT
	MOV (SP)+,R3		;RESTORE
	MOV (SP)+,R2
	RET			;EXIT

LDAOUT:	MOVB R0,@OBP		;WRITE DATA
	INC OBP
	CMP OBP,TOP		;BUFFER FULL?
	BLO 10$			;NO
	CALL FOUT		;FLUSH OUTPUT
10$:	RET

	.ENABL LSB
ROUT:	MOV R0,VIRTL		;INDICATE VIRTUAL ADDRESS OF BUFFER
	ASR R0			;FIGURE BLOCK #
	SWAB R0
	BIC #-128,R0
	MOV R0,OBLOCK		;INDICATE BLOCK
	MOV OSIZE,R0		;GET SIZE
	ROR R0			;IN WORDS
	MOV R0,-(SP)
	.READW #WA,#2,BOTTOM,(SP)+,OBLOCK
	BCC 10$			;OK
	MSGF <Error reading output file. >,128
	TFILE #OUT

10$:	RET
	.DSABL LSB
	.PAGE
FOUT:	MOV R0,-(SP)
	MOV R1,-(SP)
	MOV R2,-(SP)
	TST SWL			;LDA OUTPUT?
	BNE 50$			;YES.
	MOV VIRTL,R1		;GET VIRTUAL ADDRESS OF THIS BLOCK
	MOV VTOP,R2		;GET TOP ADDRESS
	SUB R1,R2		;COMPUTE SIZE IN BYTES
	CMP R2,OSIZE		;BIGGER THAN BUFFER?
	BLOS 10$			;NOPE. USE THE COMPUTED COUNT
	MOV OSIZE,R2		;ELSE USE THE SIZE OF THE BUFFER
10$:	ADD #511,R2		;ROUND UP TO BLOCK BOUNDARY
	ROR R2			;WORD COUNT
	CLRB R2			;WRITE ONLY BLOCK SIZED RECORDS
	ROR R1
	CLRB R1
	SWAB R1
20$:	.WRITW #WA,#2,BOTTOM,R2,R1	;WRITE DATA
	BCC 30$
	JMP ERRO

30$:	SWAB R0
	ADD R0,OBLOCK
40$:	MOV BOTTOM,OBP
	MOV (SP)+,R2
	MOV (SP)+,R1
	MOV (SP)+,R0
	RET

50$:	MOV BOTTOM,R1		;BUFFER @
	MOV OBP,R2		;POINTER
	MOV R2,R0
	SUB R1,R2		;COMPUTE SIZE IN BYTES
	BLOS 40$			;EMPTY
60$:	BIT #511,R2		;ON BLOCK BOUNDARY?
	BEQ 70$			;YEP
	CLRB (R0)+		;ZERO FILL LAST BLOCK
	INC R2
	BR 60$

70$:	ROR R2			;WORD COUNT
	MOV OBLOCK,R1
	BR 20$			;WRITE LAST BLOCK
	.PAGE
	.SBTTL	CLOSUP FINISH UP

CLOSUP:
.IIF NE,DEB$,MSG <Close up the files>
	TST MAP			;ANY MAP OUTPUT?
	BEQ 10$
	CALL MFLUSH
	.CLOSE #1		;DONE
10$:	RETURN
	.PAGE
	.SBTTL	MAP TEXT
	ENTSEC MSGS

	.NLIST BEX
TITLE:	.ASCII <CR>\ATARI LINKM \
	GTVNUM 
	.ASCII \ LOAD MAP   \
TDATE:	.BLKB 9			;CURRENT DATE
	.ASCII \   \
TTIME:	.BLKB 9			;CURRENT TIME
	.BYTE CR,LF
TIFN:	.BLKB 14		;OUTPUT FILE NAME
	.BYTE CR,CR,LF,0

FNSMRY:	.ASCII <CR><LF>\File Summary:\<CR><LF>
	.ASCIZ \    Name	Title	Ident	Creation Date/Time   Langauge statistics\
$FNSMR	=4		;MUST BE ROOM FOR 4 LINES TO PRINT

SSMRY:	.ASCII <CR><LF>\Section Summary:\<CR><LF>
	.ASCIZ \ Name   Addr    Size    Attributes     References (Files):\
$SSMR	=4		;ROOM REQUIREMENTS

GSMRY:	.ASCII <CR><LF>\Global Symbol Summary:\<CR><LF>
	.ASCIZ \ Name	Value    References (Files):\
GSYMS:	.ASCII <CR><LF>\Global Symbol Summary:\<CR><LF>
	.REPT 8
	.ASCII \ Name  Value    \
	.ENDR
	.BYTE 0
$GSMR	=4		;ROOM REQUIREMENTS

MONTBL:	.ASCIZ /JAN/
	.ASCIZ /FEB/
	.ASCIZ /MAR/
	.ASCIZ /APR/
	.ASCIZ /MAY/
	.ASCIZ /JUN/
	.ASCIZ /JUL/
	.ASCIZ /AUG/
	.ASCIZ /SEP/
	.ASCIZ /OCT/
	.ASCIZ /NOV/
	.ASCIZ /DEC/

UDFGLB:	.ASCII <CR><LF>\Undefined GLOBLs:\<CR><LF>
	.ASCIZ \Symbol(s):   References:\
$UDF	=4		;ROOM REQUIREMENTS

MDFSYM:	.ASCII <CR><LF>\Multiply defined GLOBLs:\<CR><LF>
	.ASCIZ \Symbol(S):   References:\
$MDF	=4		;ROOM REQUIREMENTS

	.PSECT IMPURE
LB:	.BLKB 132
	XITSEC
	.PAGE
	.SBTTL OPEN - FILE OPENER
	.ENABL LSB
OPEN:	SAVREG			;SAVE ALL REGISTERS
	CLR R5			;START AT CHAN 0
	MOV #CSISPC+30,R4	;POINT TO FILE SPEC

10$:	MOV #CSISPC,R3		;POIN TO TEMPORARY WORK SPACE
	MOV R3,R2
	MOV R4,R1		;SET UP FOR MOVE
	CALL XMIT4		;COPY FILE NAME
	MOV #DVCTBL+DVTSZE,R1	;POINT TO SEARCH TABLE
	CMP (R4),#^RDK 		;DEFAULT DEVICE?
	BNE 20$			;NOPE. JUST DO LOOKUP
	SUB #DVTSZE,R1		;BACKUP TO ENABLE SEARCH
	CLR (R4)		;ZAP DK: IN CASE OF FNF

20$:	.CLOSE R5		;CLAIM CHANNEL
	.FETCH BOTTOM,R3	;GET HANDLER
	BCC 30$			;OK
	TST (R1)		;SEARCHING?
	BNE 40$			;YEP, PROCEED
	MOV R3,R1
	JMP ILLDVC		;BAD

30$:	MOV R0,BOTTOM		;UPDATE POINTER
	ADD #128,R0
	MOV R0,STLLIM
	ADD #128,R0
	MOV R0,STGARD
	.SERR			;SOFT LANDINGS FOR THE .LOOKUP
	.LOOKUP R2,R5,R3	;TRY TO OPEN FILE FOR INPUT
	ROR -(SP)		;SAVE STATS
	.HERR			;BACK TO HARD LANDINGS
	ROL (SP)+		;STATS?
	BCC 50$			;SUCCESS

40$:	MOV (R1)+,(R3)		;TRY A DIFFERENT DEVICE?
	BNE 20$			;YEP.
	MSGF <File not found. >,128
	TFILE R4		;BAD

50$:	MOV #SYMBOL,R2		;COPY FILE NAME TO SYMBOL SPACE
	MOV R3,R1
	CALL XMIT4
	CLR (R2)		;ASSUME ITS NOT AN Option FILE
	CMP -(R1),#^ROPT	;TRUE?
	BNE 60$			;YEP
	INC (R2)		;ELSE MAKE IT AN OPTION FILE
60$:	APPEND FILROL		;PUT FILE NAME INTO FILE ROLL
	.CLOSE R5		;RE-CLAIM CHANNEL
	ADD #8,R4		;NEXT FILE SPEC
	CMP R4,#CSISPC+30+<6*8>  ;END?
	BHIS 70$		;YEP
	TST (R4)		;ANY FILE?
	BNE 10$			;YEP. LOOK AGAIN
	.PAGE
70$:	CLR CHAN		;ALWAYS START AT BEGINING
	CLR IBP
	RET
	.DSABL LSB

DVCTBL:
.IF EQ,VAX$
	.RAD50 /DK1/
	.RAD50 /DY1/
	.RAD50 /DY0/
.IFF
	.RAD50 /VX0/
	.RAD50 /VX1/
	.RAD50 /VX2/
	.RAD50 /VX3/
	.RAD50 /VX4/
	.RAD50 /VX5/
	.RAD50 /VX6/
	.RAD50 /VX7/
.ENDC
DVTSZE = .-DVCTBL
	.WORD 0
	.SBTTL READ ROUTINE
	.ENABL LSB

READ:	SAVREG			;SAVE ALL
	CLR R5			;GET A 0 FOR LATER
	TST CHAN		;ANYTHING OPEN?
	BNE 30$			;YEP. PROCEED

10$:	CLR DPAGE		;BE SURE TO RESET THE .DPAGE POINTER
	INC CHAN		;OPEN FILE FOR THE FIRST TIME
	MOV CHAN,R1
	CALL GETFSP		;GET FILE SPECS
	BLO 20$			;OK
	DEC CHAN		;BACK UP
	CLR R0			;SAY EOF
	RET			;EOF ON ALL FILES. DONE

20$:	CMP 8(R1),OPTFLG	;IS THIS FILE ONE OF THE ONES WE WANT?
	BNE 10$			;NOPE, SKIP IT
	MOV #FILEN,R2		;POINT TO FILE SPEC SPACE
	MOV R2,R3		;KEEP A POINTER TO FILE NAME
	CALL XMIT4		;KEEP A COPY OF FILE NAME IN CASE OF ERRORS
.IF NE,DEB$
	MOV R3,R0		;POINT TO FILENAME
	CALL CVFNLB
	MSG <Opening file: >,,128
	.PRINT #LB
.ENDC
	.CLOSE R5		;CLAIM CHANNEL 0
	.LOOKUP #WA,R5,R3	;RE-OPEN CHANNEL 0
	CLR IBLOCK		;START READING AT BLOCK 0

30$:	.READW #WA,R5,#IBUF,#256,IBLOCK	;READ A BLOCK INTO IBUF
	BCC 50$			;OK
	TSTB @#ERRBYT		;ERROR?
	BEQ 40$			;NOPE. EOF
	MSGF <Read error on file >,128
	TFILE

40$:	TST SAEOF		;SHOULD WE STOP AT EOF?
	BEQ 10$			;NOPE.
	MSGF <Pre-mature end of file >,128
	TFILE

50$:	INC IBLOCK		;UPDATE BLOCK POINTER
	MOV #1,IBP		;SAY BUFFER IS FULL
	RET			;R0 IS .NE. AT THIS EXIT
	.DSABL LSB


GETFSP:	DEC R1			;RELATIVE TO 0
	ADD SCHAN,R1		;SKIP .LNK FILE IF ANY
	IMULI RS.FIL*2,R1	; * ROLL SIZE IN BYTES
	ADD ROLBAS+FILROL,R1	; + BASE
	CMP R1,ROLTOP+FILROL	;SET CC'S AS TO LEGALITY
	RET			;AND EXIT
	.PAGE
	.SBTTL READR READ A FORMATTED RECORD
	.ENABL LSB

READR::
	SAVREG			;SAVE ALL REGS
	MOV #RBUFF,R5		;POINT TO RECORD BUFFER
	CLR SAEOF		;EOF IS OK WHILE LOOKING FOR SENTINEL
10$:	CALL GETBYT		;GET A BYTE FROM A FILE
	CMPB R0,#1		;LOOK FOR A 1,0 COMBINATION
	BNE 10$			;NOT YET
	MOV R0,R3		;INITIALISE CHECK SUM
	CALL GETBYT
	BNE 10$			;NOT 0
	INC SAEOF		;EOF NOT OK AFTER THIS
	CALL GETBYT
	MOV R0,R1		;BYTE COUNT LSB
	ADD R0,R3		;CHKSUM
	CALL GETBYT
	ADD R0,R3		;CHKSUM
	SWAB R0
	BISB R0,R1		;BYTE COUNT MSB
	SUB #4,R1		;-4 (1,0,BCL,BCH)
	CMP R1,#RBSIZE		;WILL RECORD FIT IN BUFFER?
	BLO 30$			;YEP
	MSGF <Bad object format. Record too long. >,128
20$:	TFILE

30$:	MOV R1,R2		;KEEP BYTE COUNT

40$:	CALL GETBYT
	MOVB R0,(R5)+		;COPY TO RECORD BUFFER
	ADD R0,R3		;CHKSUM
	SOB R2,40$

	CALL GETBYT		;GET CHECKSUM BYTE
	ADD R0,R3		;SHOULD TOTAL 0
	TSTB R3			;DID IT?
	BEQ 50$			;YEP
	MSGF <Check sum error in object record. >,128
	BR 20$

50$:	MOV R1,R0		;PASS BACK BYTE COUNT OF RECORD AND SET CC'S
	RET
	.DSABL LSB
	.PAGE
	.SBTTL GETBYT - GET A BYTE FROM A FILE

GETBYT:	MOV IBP,R0		;GET BUFFER POINTER
	BNE 20$			;NOT EMPTY
10$:	CALL READ		;FILL IT
	BNE GETBYT		;AGAIN
	TST (SP)+		;EOF. RETURN 1 LEVEL DEEPER
	RET

20$:	CMP R0,#512		;TOO BIG?
	BHI 10$			;YEP. GO FILL IT AGAIN

	INC IBP			;BUMP POINTER
	MOVB IBUF-1(R0),R0	;GET BYTE
	BIC #-256,R0		;ZAP UPPER BITS AND SET CC'S
	RET



	.SBTTL INIT - MEMORY INITIALISEER

INIT:	.SRESET			;KICK EVERYTHING OUT
	MOV @#RMON,R0		;POINT TO SYSTEM
	MOV ^O266(R0),R0	;GET LOAD ADDRESS OF USR
	TST -(R0)		;-2
	.SETTOP			;GRAB ALL UP TO USR
	MOV #IMPURE,R1		;POINT TO IMPURE REGION
10$:	CLR (R1)+		;ZAP IT
	CMP R1,#IMPEND
	BLO 10$

	MOV #DUMROL-2,R1	;POINT TO END OF ROLL TABLES
20$:	MOV R0,ROLBAS(R1)	;ZAP ROLL TABLES
	MOV R0,ROLTOP(R1)
	CLRB ROLSIZ+1(R1)
	DEC R1
	DEC R1			;BY 2'S
	BGE 20$

	MOV R0,SP		;SET STACK
	MOV LIM+2,BOTTOM	;SET LO LIMIT
	MOV BOTTOM,R0
	ADD #128,R0
	MOV R0,STLLIM
	ADD #128,R0
	MOV R0,STGARD
	MOVB #CR,TITLE
	MOV #1,XFERAD		;INIT THE USER'S START ADDRESS TO 1
	JMP (R4)		;RETURN.

	.PAGE
	.SBTTL RAD50 to ASCII conversions

TFILE:	TST R0			;Default file name?
	BNE 10$			;No
	MOV #FILEN,R0		;Point to default file spec
10$:	INC STENAB		;Disable stack overflow check
	CALL CVFNLB		;Convert file name to ASCII
	.PRINT #LB		;Send it to terminal
	BISB #ER.HER,@#ERRCOM
	JMP START

CVFNLB:	MOV #LB,R2		;POINT TO LINE BUFFER
CVFN:	SAVREG
	MOV R0,R5		;Point to RAD50 word
	MOV R2,-(SP)		;SAVE STRING START ADDRESS

	MOV (R5)+,R0		;DVC name
	BEQ 10$			;None. Skip it
	CALL R50TOA		;1 word to 3 bytes
	MOV R0,R2		;Save updated string pointer
	MOVB #':,(R2)+		;DVC seperator

10$:	MOV (R5)+,R0
	BEQ 20$			;NO NAME
	CALL R50TOA		;File name
	MOV R0,R2
	MOV (R5)+,R0
	CALL R50TOA
	MOV R0,R2
	CMP (R5),#^ROBJ		;Default .OBJ extension?
	BEQ 20$			;Yep, don't print it then
	MOVB #'.,(R2)+		;extension seperator
	MOV (R5),R0
	CALL R50TOA		;Extension
	MOV R0,R2
20$:	CLRB (R2)		;Terminate string
	MOV (SP)+,R2		;RE-POINT TO BEGINING
	MOV R2,R0

30$:	MOVB (R2)+,(R0)		;Copy data
	BEQ 40$			;End
	CMPB (R0),#' 		;Space?
	BEQ 30$			;Yep, ignore it
	INC R0
	BR 30$			;Continue

40$:	RET			;Done
	.PAGE
...RAD	=10			;Save current radix
	.RADIX 8		;Change it to 8
;
; Convert 1 RAD50 word (in R0) to 3 ASCII bytes starting at (R2).
;
;At entry:
; R0 = R50 word to convert
; (R2) = Position to put the 3 ASCII bytes
; At exit:
; (R0) = R2 + 3

R50TOA:	SAVREG
	MOV R0,R1		;Get symbol
	MOV #50*50,R3		;Set divisor to 50**2
	CALL 10$		;Unpack ASCII byte
	MOV #50,R3		;Set divisor to 50**1
	CALL 10$		;Unpack ASCII byte
	MOV R1,R0		;Set divisor to 50**0
	BR 20$			;Unpack ASCII byte and exit

10$:	CLR R0
	DIV R3,R0

20$:	TST R0			;Space?
	BEQ 50$			;Yes
	CMP R0,#33		;Middle
	BLT 40$			;Alpha
	BEQ 30$			;Dollar
	ADD #22-11,R0		;Dot or dollar
30$:	ADD #11-100,R0		;Dollar
40$:	ADD #100-40,R0		;Alpha
50$:	ADD #40,R0		;Space
	MOVB R0,(R2)+		;Pass byte
	MOV R2,R0		;Pass back address
	RET

	.RADIX ...RAD
	.PAGE
	.SBTTL PRINT routines

PRINT::	INCB 2(SP)		;MUST BE ROOM FOR AT LEAST 1 LINE
	CLRB 3(SP)		;BE SURE UPPER BYTE IS 0
	INC 4(SP)		;LINE COUNT MUST BE AT LEAST 1
	CLRB 5(SP)
	CMP 2(SP),LINCNT+2	;ROOM ON PAGE FOR TEXT?
	BLE 10$			;YEP. GO PRINT IT THEN
	MOV R0,-(SP)		;SAVE POINTER
	MOV #TITLE,R0		;POINT TO TITLE LINES
	MOV TTKEY,-(SP)		;SAVE THIS IN CASE OF TITLE
	CALL 20$			;PRINT THEM
	MOV (SP)+,TTKEY		;RESTORE
	MOV (SP)+,R0		;RESTORE POINTER
	MOV LINCNT,LINCNT+2	;RESET LINE COUNTER
	MOVB #FF,TITLE		;REPLACE BEGINING CHARACTER WITH FF

10$:	SUB 4(SP),LINCNT+2	;TAKE ACTUAL NUMBER OF LINES PASSED
	MOV (SP)+,(SP)		;PURGE PARAMETERS
	MOV (SP)+,(SP)
	TST TTKEY		;IS THIS TO GO TO TT: TOO?
	BEQ 20$			;NOPE.
	TST TTMAP		;IS OUTPUT DVC TT:?
	BNE 20$			;YEP. IT GOES THERE BY DEFAULT THEN
	.PRINT			;SEND IT TO CONSOLE TOO

20$:	TST MAP			;ANY OUTPUT REQUESTED?
	BEQ 60$			;DONE THEN
	MOV R1,-(SP)		;SAVE A REG
	MOV R0,R1		;POINT TO TEXT

30$:	MOVB (R1)+,R0		;GET BYTE
	BMI 50$			;STOP ON -'S
	BEQ 40$			;END
	CALL MOUTB		;PASS BYTE TO OUTPUT
	BR 30$			;CONTINUE

40$:	MOVB #CR,R0		;FOLLOW WITH CR,LF
	CALL MOUTB
	MOVB #LF,R0
	CALL MOUTB
50$:	MOV (SP)+,R1		;RESTORE REG

60$:	CLR TTKEY		;COVER OUR TRACKS
	RET

	.PAGE
	.ENABL LSB
MOUTB:	MOVB R0,@MBP		;PUT BYTE INTO BUFFER
	INC MBP			;BUMP POINTER
	CMP MBP,#MBUF+512	;BUFFER NOW FULL?
	BLO 30$			;NOPE, EXIT
10$:	.WRITW #WA,#1,#MBUF,#256,MBLOCK	;WRITE MAP OUTPUT
	BCC 20$			;OK
	MSGF <Error writing MAP file. >,128
	TFILE #MAP

20$:	INC MBLOCK		;BUMP BLOCK POINTER
	MOV #MBUF,MBP		;RESET POINTER
30$:	RET			;EXIT

MFLUSH:	MOV MBP,#MBUF		;BUFFER EMPTY?
	BEQ 30$			;YEP. NOTHING TO DO
	MOV MBP,R0
40$:	CLRB (R0)+
	CMP R0,#MBUF+512
	BLO 40$
	BR 10$
	.DSABL LSB
	.PAGE
	.SBTTL OUTNUM Unpack number to OCTAL/HEX

OUTNUM::
	MOV #4,DNCDIG		;ASSUME HEX AND MINIMUM # OF DIGITS
	MOV R1,-(SP)		;SAVE R1 AND R3 CUZ DNC ZAPS THEM
	MOV R3,-(SP)
	MOV OUTRDX,R3		;GET THE REQUESTED OUTPUT RADIX
	CMP R3,#16		;IS IT REALLY HEX?
	BEQ 10$			;YEP,
	MOV #6,DNCDIG		;ELSE SELECT OCTAL MINIMUM # OF DIGITS
10$:	MOV R0,R1		;THE NUMBER HAS TO BE IN R1
	CALL DNCF		;DISPLAY THE NUMBER IN REQUESTED RADIX
	MOV #' ,R1
	MOVB R1,(R2)+		;FOLLOW WITH SPACES
	MOVB R1,(R2)+
	MOVB R1,(R2)+
	CMP R3,#16		;HEX OUTPUT?
	BNE 20$			;NOPE, JUST 3 SPACES THEN
	MOVB R1,(R2)+		;ELSE GIVE IT 2 MORE
	MOVB R1,(R2)+
20$:	MOV (SP)+,R3		;RESTORE REGS
	MOV (SP)+,R1
	RET

.IF EQ,EIS$
	.PAGE
	.SBTTL MUL/DIV Routines

MUL:	CLR -(SP)		;MSB of product
	MOV R0,-(SP)		;Multiplier
	CLR R0			;MSB of product
	CLR R1			;LSB of product
	ROR (SP)		;Get bit of multiplier into carry (0 ext)
	BR 20$

10$:	ASR (SP)		;Shift multiplier
20$:	BCS 30$			;Accumulate
	BNE 40$			;Still bits left
	CMP (SP)+,(SP)+		;Purge stack
	RET			;R1=LSB, R0=MSB, R3=0

30$:	ADD R3,R1		;LSB
	ADC R0			;+carry to MSB
	ADD 2(SP),R0		;MSB

40$:	ASL R3			;double multiplicand
	ROL 2(SP)
	BR 10$

DIV:	MOV #16.,-(SP)		;Loop count
10$:	ASL R1			;Work registers *2 (LSB)
	ROL R0			;MSB
	CMP R0,R3		;Big enuf?
	BLO 20$			;NO
	SUB R3,R0		;Take some
	INC R1			;Bump result
20$:	DEC (SP)		;Count
	BNE 10$			;Continue
	MOV R1,(SP)
	MOV R0,R1		;R1 = remainder
	MOV (SP)+,R0		;R0 = quotient
	RET
.ENDC
	.PAGE
	.SBTTL UNPTIM Convert time code to ASCII

;AT ENTRY:
; (R0) = POINTS TO 2 WORD TIME CODE
; (R2) = PLACE TO PUT ASCII STRING
;AT EXIT:
; (R0) = END OF UNPACKED TEXT

UNPTIM:	SAVREG			;SAVE ALL REGS
	MOV 2(R0),R1		;GET LSB
	MOV (R0),R0		;GET MSB
	MOV #60,R3		;RADIX
	CALL DIV60		;GET RID OF TICKS
	CALL DIV60		;GET SECONDS IN R5
	CLR -(SP)		;STOPPER FOR DIGIT DUMPER
	MOV R5,-(SP)		;SAVE SECONDS
	CALL DIV60		;GET MINUTES IN R5
				;  AND HOURS IN R1
	MOV R5,-(SP)		;SAVE MINUTES
	MOV #24,R3		;ASSURE MIDNIGHT ROLLOVER
	CALL DIV60		;GET HOURS IN R5
10$:	MOVB R5,(R2)+		;HOURS/MINUTES/SECONDS
	SWAB R5
	MOVB R5,(R2)+
	MOVB #':,(R2)+		;SEPERATOR
	MOV (SP)+,R5		;NEXT PAIR
	BNE 10$			;CONTINUE
	MOVB #' ,-(R2)		;CLOBBER LAST :
	MOV R2,R0		;PASS BACK UPDATED POINTER
	RET			;DONE

DIV60:	CALL DDIV		;DO DOUBLE PRECISION DIVIDE
10$:	ADD #^O366,R5		;ADD MAGIC NUMBER TO
	TSTB R5			;  REMAINDER IN ASCII
	BPL 10$
	ADD #"00-^O366,R5	;CORRECT THEM
	SWAB R5			;L <=> M
	MOV #60,R3		;SET RADIX FOR NEXT TIME
	RET			;DONE

DDIV:	MOV #31,-(SP)		;BIT COUNTER
	CLR R5			;REMAINDER

10$:	ASL R1			;LSB 'S
	ROL R0			;MSB'S
	ROL R5			;REMAINDER
	CMP R5,R3		;ROOM?
	BLO 20$			;NOPE
	SUB R3,R5		;TAKE IT
	INC R1			;ACCUMULATE QUOTIENT
20$:	DEC (SP)		;COUNT
	BPL 10$			;CONTINUE
	TST (SP)+		;PURGE STACK
	RET			;DONE
	.PAGE
	.SBTTL UNPDAT Convert date code to ASCII

;AT ENTRY:
; (R0) = DATE CODE
; (R2) = POINTS TO PLACE TO PUT ASCII
;AT EXIT:
; (R0) = POINTS TO END OF TEXT

UNPDAT:	SAVREG			;SAVE ALL REGS
	MOV #2,DNCDIG		;OUTPUT AT LEAST 2 DECIMAL DIGITS
	MOV #9,R1		;PREPARE OUTPUT PLACE
	MOV R2,R3
10$:	MOVB #' ,(R3)+		;BLANK FILL AREA
	SOB R1,10$
	MOV R0,R1		;GET DATE
	BNE 20$			;ONE PRESENT. PROCEED
	MOV R3,R0		;PASS BACK POSITION
	RET			;AND EXIT

20$:	MOV R1,-(SP)		;SAVE CODE
	ASL R1			;MOVE DAY BITS AROUND
	ROL R1
	ROL R1
	SWAB R1
	BIC #-32,R1		;NUMBER TO CONVERT
	CALL DNC		;CONVERT TO DECIMAL
	MOVB #'-,(R2)+		;SEPERATOR
	MOV (SP),R1		;RETRIEVE DATE CODE
	SWAB R1			;GET MONTH BITS
	BIC #^O177703,R1
	ADD #MONTBL-4,R1	;POINT TO MONTH STRING
	CALL MOVBYT		;MOVE IN MONTH
	MOVB #'-,(R2)+		;SEPERATOR
	MOV (SP)+,R1		;RETRIEVE DATE CODE
	BIC #-32,R1		;ISOLATE YEAR CODE
	ADD #72,R1		;+ OFFSET
	CALL DNC		;YEAR
	MOV R2,R0		;POSITION
	RET			;DONE

DNCDIG: .WORD 2

DNC::	MOV #10,R3		;RADIX 10
	
DNCF::	MOV R2,-(SP)		;RECORD STARTING POSITION
	CALL 40$		;CONVERT NUMBER
	MOV (SP),R0
	NEG R0		
	ADD R2,R0		;COMPUTE LENGTH OF ANSWER
	MOV DNCDIG,-(SP)
	SUB R0,(SP)		;IS THERE ENOUGH?
	BLE 30$			;YEP
	MOV R2,R1		;RECORD CURRENT POSITION
	ADD (SP),R2		;POSITION TO S/B END
	MOV R2,(SP)		;KEEP A COPY OF THE END POINTER
10$:	MOVB -(R1),-(R2)	;MOVE THE STRING TO THE RIGHT N BYTES
	SOB R0,10$
20$:	MOVB #'0,-(R2)		;PREFIX 0'S
	CMP R2,2(SP)		;ARE WE AT THE BEGINNING?
	BHI 20$			;NOPE, KEEP FILLING
	MOV (SP)+,R2		;RESTORE R2
	TST (SP)+		;PURGE STACK
	RET			;AND EXIT
30$:	CMP (SP)+,(SP)+		;PURGE STACK
	RET			;AND EXIT

40$:	CLR R0			;OTHER RADICES ENTER HERE
	DIV R3,R0		;COMPUTE (R0,R1)/R3
	MOV R1,-(SP)		;SAVE REMAINDER
	MOV R0,R1		;PUT QUOTIENT INTO DIVIDEND
	BEQ 50$			;END
	CALL 40$		;RECURSE
50$:	MOV (SP)+,R1		;RETRIEVE NUMBER
	ADD #'0,R1
	CMP R1,#'9		;A-F?
	BLE 60$			;NOPE
	ADD #'A-<'9+1>,R1	;ADJUST IT
60$:	MOVB R1,(R2)+		;PASS CHAR
	RET			;EXIT
	.PAGE
	.SBTTL ROLL HANDLERS

SETROL::MOV R0,ROLNDX		;KEEP ROLL POINTER
SETROF:	MOV (SP)+,R0		;GET RETURN ADDRESS
	SAVREG			;SAVE ALL THE REGISTERS
	MOV ROLNDX,R5		;GET INDEX
	MOV ROLBAS(R5),R1	;CURRENT BASE
	MOV ROLTOP(R5),R2	;CURRENT TOP
	MOVB ROLSIZ(R5),R3	;ENTRY SIZE (IN BYTES)
	MOV #SYMBOL,R4		;POINT TO WORK REGION
	JMP (R0)		;GO TO PROPER ROUTINE

	ENTSEC IMPURE
ROLNDX:	.BLKW
ROLPNT:	.BLKW
ROLUPD:	.BLKW
ROLENT:	.BLKW
	XITSEC

ZAP::	CALL SETROL		;SET THE REGISTERS
	MOV R1,ROLTOP(R5)	;MAKE TOP = BOTTOM
	CLRB ROLSIZ+1(R5)	;CLEAR ENTRY COUNT
	RET

SEARCH::CALL SETROL		;SET THE REGISTERS
	MOV R3,-(SP)		;SAVE ENTRY SIZE
	SUB R3,R1		;POINT 1 SLOT LOW
	MOV R2,R3		;GET TOP
	SUB R1,R3		;COMPUTE SIZE OF ROLL IN BYTES
	CLR R0			;COMPUTE SEARCH OFFSET
	SEC			;   (R0 IS ALSO A T/F FLAG)

10$:	ROL R0			;SHIFT BIT
	BIC R0,R3		;CLEAR CORRESPONDING BIT
	BNE 10$			;NOT LAST ONE
	MOV (SP),R3		;GET ENTRY SIZE IN BYTES
	ASR R3			;/4
	ASR R3

20$:	ADD R0,R1		;COMPUTE POSITION OF TEST ENTRY

30$:	CLC
	ROR R0			;HALVE OFFSET
	BIC R3,R0		;END?
	BEQ 70$			;YEP. EXIT FALSE

40$:	CMP R2,R1		;RUN OFF THE END OF THE ROLL?
	BLOS 60$			;YES, GO BACK UP
	CMP (R4),(R1)		;FIRST WORD MATCH?
	BNE 50$			;NOPE
	CMP 2(R4),2(R1)		;SECOND WORD MATCH?
	BEQ 80$			;YES. EXIT TRUE

50$:	BHI 20$			;GO THE OTHER WAY

60$:	SUB R0,R1		;BACK DOWN
	BR 30$			;AND CONTINUE

70$:	ADD R3,R1		;FIX POINTER
	ADD R3,R1
80$:	MOV (SP)+,R3		;RESTORE ENTRY SIZE
	BR SCANX		;EXIT THROUGH SCAN ROUTINE
	.PAGE
NEXT::	CALL SETROL		;SET UP REGISTERS
	MOV ROLUPD,R0		;GET ENTRY #
	ADD R0,R1		;COMPUTE ACTUAL ADDRESS
	ADD R3,R0		;+1 ENTRY
	INC ROLENT		;COUNT ENTRY
	CMP R1,R2		;AT THE TOP?
	BLO SCANX		;NOPE. JUST EXIT
	BR SCANXF		;YEP. EXIT FALSE

SCANC::	CALL SETROL		;SAVE/SET-UP REGS
	MOV ROLUPD,R0		;GET POINTER TO NEXT ENTRY
	ADD R0,R1		;UPDATE CURRENT POSITION
	BR SCCE			;CONTINUE SCANNING

SCAN::	CALL SETROL		;LINEAR ROLL SEARCH. SET REGISTERS
	CLR R0			;ASSUME FALSE
	CLR ROLENT		;ENTRY NUMBER

SCCE:
10$:	CMP R2,R1		;AT THE TOP?
	BLOS SCANXF		;YEP
	ADD R3,R0
	INC ROLENT
	CMP (R4),(R1)		;MATCH?
	BNE 20$			;NOPE
	CMP 2(R4),2(R1)		;MATCH?
	BEQ SCANX		;YEP. EXIT TRUE

20$:	ADD R3,R1		;INCREMENT TO NEXT ENTRY
	BR 10$			;AND CONTINUE

	.ENABL LSB
SCANXF::CLR R0			;FALSE CODE
SCANX::	MOV R1,ROLPNT		;SAVE ENTRY POINTER
	MOV R0,ROLUPD		;SAVE ENTRY INDEX (0 IF FALSE)
	BEQ 10$			;NOT FOUND

SCANY:	MOV R4,R2		;POINTER TO 'SYMBOL'
	NEG R3			;NEGATE ENTRY SIZE
	JMP XMIT0(R3)		;COPY THE REST OF THE ENTRY

10$:	CMP (R4)+,(R4)+		;SKIP THE SYMBOL
	ASR R3			;COMPUTE WORD COUNT
	SUB #2,R3		;-2 FOR SYMBOL
	BLE 30$			;TINY ROLL ENTRY SIZE. JUST EXIT

20$:	CLR (R4)+		;CLEAR REMINDER OF ENTRY
	DEC R3
	BGT 20$

30$:	RET
	.DSABL LSB
	.PAGE
SCANWC:: CALL SETROL		;SAVE/SET-UP REGS
	MOV ROLUPD,R0		;GET POINTER TO NEXT ENTRY
	ADD R0,R1		;UPDATE CURRENT POSITION
	BR SCWCE		;CONTINUE SCANNING

SCANW::
	CALL SETROL		;SAVE/SET UP REGS
	CLR R0
SCWCE:
10$:	CMP R2,R1		;AT TOP?
	BLOS 20$			;YEP. EXIT FALSE
	ADD R3,R0		;COUNT FOR UPD
	CMP (R4),(R1)		;MATCH?
	BEQ 30$			;YEP. EXIT TRUE
	ADD R3,R1		;NEXT ITEM
	BR 10$			;CONTINUE

20$:	CLR R0
30$:	MOV R1,ROLPNT		;SAVE POINTER
	MOV R0,ROLUPD		;SAVE FLAG
	BNE SCANY		;TRUE. GO COPY REST OF DATA
	TST (R4)+		;SKIP FIRST WORD
	ASR R3			;COMPUTE WORD COUNT OF ENTRY
	DEC R3			;-1 FOR SYMBOL
	BLE 50$			;TINY ROLL. JUST EXIT

40$:	CLR (R4)+		;CLEAR REST OF AREA
	SOB R3,40$

50$:	RET

APPEND::
	SETROL			;SET ROLL REGISTERS
	MOV R2,ROLPNT		;POINT TO TOP
	CLR ROLUPD		;PRETEND WE DIDN'T MATCH
	BR INSERF		;GO DO AN INSERT


INSERT::
	CALL SETROF		;SET REGISTERS (EXCEPT ROLNDX)
INSERF:	MOV ROLPNT,R0		;POINTS TO PROPER SLOT
	TST ROLUPD		;WAS SEARCH TRUE?
	BNE 30$			;YEP. JUST COPY DATA IN
	INCB ROLSIZ+1(R5)	;UPDATE ENTRY COUNT
	ADD R3,ROLTOP(R5)	;UPDATE TOP POINTER
	CMP R2,ROLBAS+2(R5)	;GAP BETWEEN ROLLS?
	BLO 30$			;YEP. JUST STUFF IN DATA
	MOV SP,R1		;'FROM' ADDRESS
	SUB R3,SP		;'TO' ADDRESS
	MOV SP,R2
	SUB R1,R0		;COMPUTE BYTE COUNT
	CLC
	ROR R0			;COMPTE WORD COUNT

10$:	MOV (R1)+,(R2)+		;MOVE EVERYTHING DOWN 1 ENTRY
	SOB R0,10$

20$:	SUB R3,ROLBAS(R5)	;DECREMENT ALL THE OTHER POINTERS TOO
	SUB R3,ROLTOP(R5)
	SUB #2,R5		;MORE ROLLS?
	BGE 20$			;YEP. DO THEM ALL

	MOV R2,R0		;POINT TO INSERTION SLOT
30$:	ASR R3			;COMPUTE SIZE IN WORDS OF ENTRY
40$:	MOV (R4)+,(R0)+		;MOVE THE ENTRY IN
	SOB R3,40$
	RET
	.PAGE
DELETE::
	CALL SETROF		;SET REGS (EXCEPT ROLNDX)
	MOV ROLPNT,R0		;POINT TO SLOT
	TST ROLUPD		;MATCH?
	BEQ 20$			;NOPE. NOTHING TO DELETE
	DECB ROLSIZ+1(R5)	;TAKE 1 FROM ENTRY COUNT
	SUB R3,ROLTOP(R5)	;ADJUST UPPER LIMIT
	MOV R0,R1
	ADD R3,R1		;POINT TO NEXT ENTRY
10$:	CMP R1,ROLTOP(R5)	;AT END?
	BHIS 20$			;YEP. DONE
	MOV (R1)+,(R0)+		;MOVE EVERYTHING DOWN 1
	BR 10$

20$:	RET
	.PAGE
	.SBTTL REGISTER SAVE/RESTORE ROUTINE

	ENTSEC IMPURE
STENAB:	.BLKW
	XITSEC

SAVREG::			;CALL THIS ROUTINE WITH A 'JSR R5,SAVREG'
	MOV R4,-(SP)		;SAVE ALL EXCEPT R0 (R5 ALREADY ON STACK)
	MOV R3,-(SP)
	MOV R2,-(SP)
	MOV R1,-(SP)
	MOV R5,-(SP)		;SAVE RETURN ADDRESS
	TST STENAB		;STACK TEST ENABLED?
	BNE 10$			;NOPE
	CMP STLLIM,SP		;ROOM?
	BHIS STOVF		;NOPE
10$:	MOV 10(SP),R5		;RESTORE R5 IN CASE ROUTINE NEEDS IT
	CALL @(SP)+		;CALL BACK THE CALLER
	MOV (SP)+,R1		;RESTORE REGS
	MOV (SP)+,R2
	MOV (SP)+,R3
	MOV (SP)+,R4
	MOV (SP)+,R5
	TST R0			;SET CC'S
	RET			;EXIT

STOVF:	MSGF <Stack underflow while reading >,128
	TFILE			;PRINT THE FILE THAT PRODUCED THE ERROR.

	.SBTTL DATA XMITTER

	.REPT MAXXMT-7
	MOV (R1)+,(R2)+
	.ENDR
XMIT7:	MOV (R1)+,(R2)+
XMIT6:	MOV (R1)+,(R2)+
XMIT5:	MOV (R1)+,(R2)+
XMIT4:	MOV (R1)+,(R2)+
XMIT3:	MOV (R1)+,(R2)+
XMIT2:	MOV (R1)+,(R2)+
XMIT1:	MOV (R1)+,(R2)+
XMIT0:	RET

MOVBYT::
10$:	MOVB (R1)+,(R2)+
	BNE 10$
	TSTB -(R2)
	RET
	.PAGE
	.SBTTL OPTION FILE INPUT
;+
; BEWARE: The radix after this point is OCTAL
;-
	.RADIX 8
;+
; Symbolic character defines.
;-

CH.IOR=	'!
CH.QTM=	'"
CH.HSH=	'#
CH.DOL=	'$
CH.PCT=	'%
CH.AND=	'&
CH.XCL=	''
CH.LP=	'(
CH.RP=	')
CH.MUL=	'*
CH.ADD=	'+
CH.COM=	',
CH.SUB=	'-
CH.DOT=	'.
CH.DIV=	'/
CH.COL=	':
CH.SMC=	';
CH.LAB=	'<
CH.EQU=	'=
CH.RAB=	'>
CH.QM=	'?
CH.IND=	'@
CH.BSL=	'\
CH.UAR=	'^
CH.SPC= <' >

LET.A=	'A
LET.B=	'B
LET.C=	'C
LET.D=	'D
LET.E=	'E
LET.F=	'F
LET.G=	'G
LET.H=	'H
LET.O=	'O
LET.X=	'X
LET.Z=	'Z

DIG.0=	'0
DIG.9=	'9

TAB=	11
LF=	12
VT=	13
FF=	14
CR=	15
SPACE=	40

MODE   = SYMBOL + 4.
SECTOR = SYMBOL + 5.
VALUE  = SYMBOL + 6.
RELLVL = SYMBOL + 8.

.MACRO	ERROR ARG,FLAG
   .IF NB,<FLAG>
	MOV	#ERR.'ARG'+^O100000,R0
   .IFF
	MOV	#ERR.'ARG',R0
   .ENDC
	CALL	STMERR
	.ENDM

.MACRO	SR1234		;SAVE REGS 1,2,3 AND 4
	JSR R4,SR1234
	.ENDM

.MACRO	GCHTBL	CHAR,	ADDR	;GEN CHARACTER SCAN TABLE
	.WORD	ADDR,	CHAR
	.ENDM

	.sbttl OPTIONS Option file(s) handler

	ENTSEC	IMPURE
OPTFLG:	.BLKW
OPTLIN:	.BLKW
CRADIX:	.BLKW
OUTRDX:	.BLKW
CHRPNT:	.BLKW
DEFRAD:	.BLKW
SYMBEG:	.BLKW
WSFLAG:	.BLKW
	XITSEC

SR1234:	MOV R3,-(SP)		;SAVE ALL EXCEPT R0 AND R5 (R4 ALREADY ON STACK)
	MOV R2,-(SP)
	MOV R1,-(SP)
	MOV R4,-(SP)		;SAVE RETURN ADDRESS
	TST STENAB		;STACK TEST ENABLED?
	BNE 10$			;NOPE
	CMP STLLIM,SP		;ROOM?
	BLO 10$			;YEP
	JMP STOVF		;ELSE TAKE ERROR OUT
10$:	MOV 8.(SP),R4		;RESTORE R4 IN CASE ROUTINE NEEDS IT
	CALL @(SP)+		;CALL BACK THE CALLER
	MOV (SP)+,R1		;RESTORE REGS
	MOV (SP)+,R2
	MOV (SP)+,R3
	MOV (SP)+,R4
	TST R0			;SET CC'S
	RET			;EXIT

	.ENABL LSB
OPTION::
.IIF NE,DEB$,MSG <Options files interpreting>
	MOV	#1,OPTFLG	;SAY TO READ OPTION FILES
10$:	CALL	GETLIN		;GET A LINE OF OPTION STUFF
	BNE	20$		;GOT ONE
	CLR	OPTFLG		;DONE WITH OPTION FILES
	RET			;EOF ON ALL FILES

20$:	TST	OPTLIN		;THIS THE FIRST ONE?
	BNE	30$		;NOPE
	PRINT	#OPTLIN		;START WITH A BLANK LINE
	INC	OPTLIN		;AND SIGNAL WE GOT IT
30$:	CALL	STMNT		;PROCESS STATEMENT
	CALL	ENDLIN		;FINISH OFF THE LINE
.IIF NE,DEB$,MSG <Next option line>
	BR	10$		;AND CONTINUE
	.DSABL LSB
	.SBTTL OPTION LINE ERROR DISPLAY
STMERR:	SR1234			;SAVE ALL THE REGS
	MOV	SYMBEG,R1	;GET STARTING POSITION OF STRING IN ERROR
	MOV	R0,R5		;KEEP A COPY OF THE ERROR MESSAGE ADDRESS
	BPL	10$		;USE SYMBEG
	MOV	CHRPNT,R1	;ELSE USE CURRENT POSITION
10$:	BIC	#100000,R5	;ZAP THE FLAG BIT
	TST	LINERR		;ANY ERRORS THIS LINE ALREADY?
	BNE	20$		;YEP, NOT NECESSARY TO DUMP THE LINE AGAIN
	MOV	SP,TTKEY	;SIGNAL THIS GOES TO TT: TOO
	PRINT	#RBUFF,#2	;PRINT THE LINE IN ERROR
20$:	SUB	#LINBUF,R1	;COMPUTE PLACE OF ERROR
	ADD	#LEB,R1		;INDEX INTO ERROR BUFFER
	MOVB	#'^,(R1)+	;STUFF IN A "^" TO MARK THE SPOT
	CLRB	(R1)		;TERMINATE THE BUFFER
	MOV	SP,TTKEY	;SIGNAL THIS GOES TO TT: TOO
	PRINT	#LEB		;DISPLAY IT
	MOVB	#' ,(R1)	;FIX UP THE ERROR BUFFER FOR NEXT TIME
	MOVB	(R1),-(R1)	; (BOTH THE ^ AND 0)
	MOV	SP,TTKEY	;SIGNAL THIS GOES TO TT: TOO
	PRINT	R5		;DISPLAY THE ERROR MESSAGE
	INC	LINERR		;COUNT THE LINE IN ERROR
	RET			;AND EXIT

	ENTSEC	MSGS
ERR.A:	.ASCIZ \?LINKM-E-Address/expression error\
ERR.I:	.ASCIZ \?LINKM-E-Invalid character\
ERR.Q:	.ASCIZ \?LINKM-E-Questionable syntax\
ERR.T:	.ASCIZ \?LINKM-E-Value overflowed 65535 (truncation error)\
ERR.N:	.ASCIZ \?LINKM-E-Number inconsistant with current radix.\
ERR.U:	.ASCIZ \?LINKM-E-Undefined symbol\
ERR.W:	.ASCIZ \?LINKM-E-.WEAK/.STRONG directives mutually exclusive\
	XITSEC

	.SBTTL GETLIN Input processor

GETLIN:	SR1234			;GET AN INPUT LINE
	MOV	#IMPLIN,R0
	MOV	#IMPLEN-IMPLIN/2,R1
10$:	CLR	(R0)+
	SOB	R1,10$		;CLEAR LINE ORIENTED VARIABLES
	CALL	70$		;GET A RECORD
	TST	R0		;EOF?
	BEQ	60$		;EXIT IF .EQ. 0
	MOV	#LINBUF,R2	;LINE BUFFER
	MOV	#RBUFF,R1	;RECORD BUFFER
;.IIF NE,DEB$,.PRINT R1
	MOV	R2,CHRPNT	;START AT BEGINNING OF LINE
	BR	30$

20$:	MOVB	R5,(R2)+	;MOVE INTO LINBUF
30$:	MOVB	(R1)+,R5	;FETCH NEXT CHAR
	MOVB	CTTBL(R5),R0	;GET CHARACTERISTICS
	BEQ	40$		;QUESTIONABLE
	BIT	#CT.LC,R0	;LOWER CASE?
	BEQ	20$		;  NO
	BIS	#200,R5		;YES, END UP WITH "200 + LC"
	BR	20$		;STORE

40$:	MOVB	R5,(R2)		;QUESTIONABLE, ASCIZ NULL?
	BEQ	50$		;  YES, ALL SET
	MOVB	#CH.QM,-1(R1)	;SUBSTITUTE A "?" IN RBUFF
	MOV	#200,R5		;STORE ZERO WITH FLAG BIT
	BR	20$

50$:	CALL	SETNB
	MOV	SP,R0		;RETURN WITH NON-ZERO TO INDICATE DATA PRESENT
60$:	RETURN

70$:	MOV	#RBUFF,R2
	CLR	R1
	CLR	SAEOF		;EOF IS OK TIL WE FIND CHAR
80$:	CALL	GETBYT		;GET A BYTE FROM OPTIONS FILE
	BEQ	80$		;SKIP NULLS
	CMP	R0,#LF		;END OF LINE?
	BEQ	90$		;YEP
	CMP	R0,#CR		;CR?
	BEQ	80$		;YEP, IGNORE THEM
	CMP	R2,#RBUFF+131.	;ROOM FOR CHAR?
	BHIS	80$		;NOPE, IGNORE THE REST
	MOV	SP,SAEOF	;EOF NOW IS BAD
	MOVB	R0,(R2)+	;PUT CHAR IN BUFFER
	BR	80$		;CONTINUE

90$:	CLRB	(R2)		;RECORD TERMINATOR
	SUB	#RBUFF,R2	;COMPUTE LENGTH
	BEQ	70$		;BLANK LINE, KEEP LOOKING
	RETURN

	.SBTTL ENDLIN End of line processor

ENDLIN:				;END OF LINE PROCESSOR
	TSTB	CTTBL(R5)	;EOL OR SEMI-COLON?
	BLE	10$		;  YES
	ERROR	Q,1		;QUESTIONABLE SYNTAX
10$:	TST	LINERR		;ANY ERRORS ON THIS LINE?
	BNE	20$		;YEP, WE'VE ALREADY DUMPED THE LINE
	PRINT	#RBUFF		;ELSE PRINT THE RECORD TOO
20$:	RETURN

	ENTSEC	IMPLIN
LINBUF:	.BLKB	132.
LINEND:	.BLKW	1
LINERR: .BLKW	1
SECSIZ: .BLKW	1	
	XITSEC

	ENTSEC	PURE
LEB:	.REPT 132./4.
	.BYTE SPACE,SPACE,SPACE,SPACE
	.ENDR
	XITSEC

	.SBTTL	STATEMENT PROCESSOR

STMNT:	CALL	GETSYM
	BEQ	10$
	SCAN	PSTROL
	BEQ	20$
	CLR	R3
	JMP	@SYMBOL+4	;GO TO FUNCTION

10$:	CALL	SETSYM		;RESET CHAR POINTER AND FLAGS
	TSTB	CTTBL(R5)
	BLE	30$		;NULL IF END OF LINE

20$:	ERROR	U		;UNDEFINED STATMENT
30$:	RETURN

.MACRO PST NAME,ADDR
	.RAD50 \NAME\
	.WORD ADDR
	.ENDM

PSTBAS:
	PST <BOUNDS>,.BOUND	;THESE MUST BE IN ALPHABETICAL
	PST <GLOBL >,.GLOBL	;  ORDER
	PST <PSECT >,.PSECT
	PST <RADIX >,.RADIX
	PST <STRONG>,.STRON
	PST <SYMBOL>,.GLOBL
	PST <WEAK  >,.WEAK
	PST <.BOUND>,.BOUND
	PST <.GLOBL>,.GLOBL
	PST <.PSECT>,.PSECT
	PST <.RADIX>,.RADIX
	PST <.STRON>,.STRON
	PST <.SYMBO>,.GLOBL
	PST <.WEAK >,.WEAK
PSTTOP:
	.PAGE
	.SBTTL .GLOBL/.PSECT DIRECTIVES
.GLOBL:	INC	R3		;SIGNAL GLOBAL PROCESSING
.IIF NE,DEB$,MSG <Got to .GLOBL routine>
.PSECT:
.IIF NE,DEB$,MSG <Got to .PSECT routine>
10$:	CALL	TSTARG		;ANY ARGUMENTS?
	BNE	20$		;YEP
	RETURN			;NOPE, DONE

20$:	TST	R3		;MESSING WITH PSECTS?
	BNE	30$		;NOPE, SKIP THIS STUFF
	CLR	SECSIZ		;ASSUME NOT TO CHANGE PSECT SIZE
	CMPB	R5,#'^		;IS IT AND ^S?
	BNE	30$		;NOPE
	CALL	GETNB		;MAYBE, SKIP THE ^
	CMPB	R5,#'S		;S?
	BNE	40$		;NOPE, ERROR OUT
	INC	SECSIZ		;ELSE SAY WE'RE GONNA CHANGE THE SECTION SIZE
30$:	CALL	GETSYM		;TRY FOR A SYMBOL NAME
	BNE	50$		;GOT ONE
40$:	ERROR	U		;ELSE ERROR EXIT
	RET

50$:	CMPB	R5,#'=		;FOLLOWED BY EQUAL?
	BEQ	60$		;YEP
	CMPB	R5,#':		;OR COLON?
	BEQ	60$		;YEP
	ERROR	A		;ELSE GIVE 'EM AN ERROR
	RET

60$:	TST	R3		;.GLOBL?
	BNE	70$		;YEP
	SCAN	SECROL		;.PSECT, LOOK IN SECTION ROLL
	BR	80$	
70$:	SEARCH	SYMROL		;LOOK IN THE SYMBOL TABLE FOR SYMBOL
80$:	BEQ	40$		;NOT THERE, ERROR OUT
	CALL	GETNB		;SKIP THE = OR :
	MOV	#SYMBOL+2,R1	;POINT TO SYMBOL SPACE
	MOV	(R1),-(SP)	;SAVE THE SYMBOL
	MOV	-(R1),-(SP)
	CALL	EXPR		;EVALUATE EXPRESSION
	MOV	(SP)+,(R1)+	;RESTORE SYMBOL
	MOV	(SP),(R1)+
	MOV	VALUE,(SP)	;SAVE THE VALUE CALCULATED
	TST	R3		;.GLOBL?
	BNE	110$		;YEP
	SCAN	SECROL		;LOOK AGAIN FOR SECTION NAME
	TST	SECSIZ		;ARE WE TO CHANGE THE SECTION SIZE?
	BEQ	90$		;NOPE
	MOV	(SP)+,R0	;GET THE VALUE
	CMP	(R1)+,(R1)+	;ADVANCE TO SECTION SIZE
	CMP	R0,(R1)		;
	BLOS	10$		;CAN'T MAKE IT SMALLER THAN IT ALREADY IS
	MOV	R0,(R1)		;CAN MAKE IT BIGGER THOUGH
	BR	130$
90$:	BIS	#S.FORC,(R1)+	;SIGNAL FORCED OFFSET
	MOV	(SP)+,(R1)	;PASS VALUE
	INSERT			;PUT ENTRY IN SECROL
	MOV	ROLPNT,R2	;POINT TO CURRENT SECROL ENTRY
100$:	MOV	ROLPNT,R1	;POINT TO CURRENT SECROL ENTRY
	ADD	#RS.SEC*2,R2	;BUMP TO NEXT
	CMP	R2,ROLTOP+SECROL ;AT THE UPPER LIMIT?
	BHIS	10$		;YEP, DONE
	MOV	R2,R0
	CMP	(R1)+,(R0)+	;NAMES MATCH?
	BNE	10$		;NOPE, DONE
	CMP	(R1)+,(R0)+	;?
	BNE	10$		;NOPE
	BISB	#S.FORC,(R0)	;ELSE SET THE FORCED BIT IN THE TABLE TOO
	BR	100$

110$:	SEARCH	SYMROL		;GET THE SYMBOL
	BIC	#^C<S.SW>,(R1)	;SAVE STRONG/WEAK FLAG
	BIS	#256.+S.DEF,(R1)+ ;MAKE SURE ITS ABSOLUTE
120$:	MOV	(SP)+,(R1)	;COPY IN THE VALUE
130$:	INSERT			;UPDATE TABLE
	BR	10$		;AGAIN
	.sbttl .WEAK/.STRONG directives
	.enabl lsb
.strong: inc r3			;signal strong
.weak:	tstb wsflag+1		;already been through here?
	beq 10$			;nope
	cmpb r3,wsflag		;doing the same thing as last time?
	beq 10$			;yep
	error w			;opcode error
	ret

10$:	bisb #1,wsflag+1	;signal we've been through here
	movb r3,wsflag		;and this is what we're doin'
20$:	call tstarg		;got an argument?
	bne	30$		;yep
	ret			;nope, we're done then

30$:	clr r3			;wilcard flag
	mov #6,r4		;6 chars of significance
	mov #lb,r2		;point to free space
	mov r2,r1		;save the pointer
	mov chrpnt,symbeg	;save where we started in case of no wildcards
	dec chrpnt		;compensate for getchr's inc
40$:	call getwcc		;next char a wildcard char?
	beq 50$			;nope
	dec r4			;too many chars?
	blt 40$			;yep, ignore all beyond 6
	movb r5,(r2)+		;pass symbol
	br 40$			;until no more

50$:	tst r3			;any wildcards?
	beq 100$		;nope, it gets easy then
	movb #ch.spc,(r2)+	;follow the symbol with a space
	mov r2,r4		;point to start of temp space
	clr rolupd		;start at the beginning
	clr r3			;hit flag
60$:	next symrol		;get a symbol
	beq 70$			;done
	mov #symbol,r1		;point to symbol
	mov r4,r2		;point to free space
	call symtoa		;symbol to ascii
	mov r4,r2		;r2 = address of string from symbol table
	mov #lb,r1		;r1 = address of wildcarded string
	call match		;do they match?
	beq 60$			;nope, forget it then
	bisb #s.sw,symbol+flags	;set the weak/strong bit
	insert			;stuff it back
	inc r3			;signal we got at least 1 hit
	br 60$			;gotta look through the whole table

70$:	tst r3			;any matches?
	bne 90$			;yep
80$:	error u			;nope, give 'em an error code
90$:	call setchr		;do a fixup so we can continue
	br 20$			;try for another argument

100$:	mov symbeg,chrpnt	;backup
	call setchr		;reset the pointers
	call getsym		;get a symbol	
	search symrol		;look for it
	beq 80$			;its not there!
	bisb #s.sw,flags	;set the weak/strong bit
	insert			;update
	br 20$			;next
	.dsabl lsb

getwcc:	call	getchr		;get the next char
	cmpb	r5,#'*		;is it a wildfield char?
	beq	10$		;ok
	cmpb	r5,#'%		;is it a wildchar char?
	beq	10$		;ok
	BITB	#CT.ALP!CT.NUM,CTTBL(R5) ;ALPHA, NUMERIC, DOT or DOLLAR?
	BEQ	20$		;  NO, ret z = 1
	ret			;  ret z = 0
10$:	inc	r3		;count the wildcard (return z = 0)
20$:	ret
.SBTTL	MATCH	- Pattern match routine

;+
; MATCH
; This routine does a wildcard pattern match against an ASCII pattern string.
;    (Lifted from PIPEXE of RT-11 V4)
;
;	R1	-> ASCII input wildcarded symbol
;	R2	-> ASCII symbol from symbol table (terminated with a space)
;
;	CALL	MATCH
;
;	R0	=  0 => no match
;	R0	<> 0 => match
;-

MATCH::
	SAVREG			;Save R1 - R5
	CLR	R0		;Assume failure
	MOV	#ch.spc,R4	;An ASCII blank is often used
10$:	MOVB	(R1)+,R3	;Get the next pattern character
	CMPB	R3,#'*		;Is it a "*"?
	BNE	20$		;Branch if not
	CMPB	@R1,R4		;Are we at the end of the string?
	BEQ	30$		;Branch if so.  We have a match
20$:	CMPB	@R2,R4		;Is this the end of the test string?
	BNE	40$		;Branch if not
	CMPB	R3,R4		;At the end of the pattern string?
	BNE	60$		;Branch if not.  Return a level
30$:	INC	R0		;Else it matched!!!
	BR	60$		;Return a level
40$:	CMPB	R3,R4		;Is this the end of the pattern string?
	BEQ	60$		;Branch if so
	CMPB	R3,#'*		;Is the pattern character a "*"?
	BEQ	50$		;Branch if so
	CMPB	(R2)+,R3	;Does test char match pattern char?
	BEQ	10$		;Branch if yes
	CMPB	R3,#'%		;Is the pattern char a "%"?
	BEQ	10$		;Branch if so.  It matches.
	BR	60$		;Else return to caller
50$:	MOV	R1,-(SP)	;Save R1
	MOV	R2,-(SP)	; and R2
	JSR	PC,10$		;And call self!!!!
	MOV	(SP)+,R2	;Restore R2
	MOV	(SP)+,R1	; and R1
	TST	R0		;Did the strings match?
	BNE	60$		;Branch if so
	CMPB	(R2)+,R4	;At the end of the test string yet?
	BNE	50$		;Branch if not
60$:	RETURN			;Return a level
	.sbttl .BOUNDS bounds check
.BOUNDS:
	call tstarg		;check for argument
	bne 10$			;got one
	ret			;else ignore it

10$:	call getsym		;try for a symbol
	bne 20$			;got one
	error a			;what the hell?
	ret

20$:	mov	#symbol,r4	;point to temp space
	MOV	(r4)+,-(SP)	;SAVE THE SYMBOL
	MOV	(r4)+,-(SP)
	clr	-(sp)		;assume low limit of 0
	mov	#-1,-(sp)	;and high limit of -1
	tst	(r4)+		;point to value
	call tstarg		;limits?
	beq 30$			;nope, we're done
	CALL	EXPR		;EVALUATE EXPRESSION
	MOV	(r4),2(SP)	;SAVE THE low limit
	call tstarg		;hi limt?
	beq 30$			;nope
	call expr		;get it
	mov (r4),(sp)		;save high limit
30$:	mov (sp)+,(r4)		;restore prototype
	mov (sp)+,-(r4)
	mov (sp)+,-(r4)
	mov (sp)+,-(r4)
	append bndrol		;stuff it in the bounds roll
	ret			;and exit
	.SBTTL .RADIX directive

.RADIX:
.IIF NE,DEB$,MSG <Got to .RADIX routine>
	CALL	TSTARG		;CHECK FOR ARG
	BNE	20$		;GOT ONE
10$:	MOV	DEFRAD,CRADIX	;SET TO THE DEFAULT
	RET			;ELSE WE'RE DONE

20$:	MOV	#10.,CRADIX	;ASSUME DECIMAL WHILE DOING EXPR
	CALL	EXPR		;EVALUATE EXPRESSION
	MOV	VALUE,R0	;GET THE VALUE
	CMP	R0,#2		;CAN'T BE LESS THAN 2
	BHIS	40$		;OK
30$:	ERROR	A		;ELSE ZAP IT
	BR	10$		;AND CHANGE TO DEFAULT

40$:	CMP	R0,#16.		;CAN'T BE GREATER THAN 16
	BHI	30$		;BAD
	MOV	R0,CRADIX
	RET
	.PAGE
	.SBTTL	SYMBOL/CHARACTER HANDLERS

GETSYM:	SR1234
	MOV	CHRPNT,SYMBEG	;SAVE IN CASE OF RESCAN
	MOV	#SYMBOL+4,R1
	CLR	-(R1)
	CLR	-(R1)
	BITB	CTTBL(R5),#CT.ALP	;ALPHA?
	BEQ	50$		;  NO, EXIT FALSE
	MOV	#26455,R2	
	CALL	SETR50
10$:	CALL	MULR50
20$:	ASR	R2
	BCS	10$
	ADD	R0,(R1)
30$:	CALL	GETR50
	BLE	40$
	ASR	R2
	BCS	20$
	BEQ	30$
	TST	(R1)+
	BR	10$

40$:	CALL	SETNB
50$:	MOV	SYMBOL,R0
	RETURN


MULR50::			;MULTIPLY R0 * 50
	IMULI	50,R0
	RETURN
	.PAGE
GETR50:	CALL	GETCHR
SETR50:	MOV	R5,R0
TSTR50:	BITB	#CT.ALP!CT.NUM!CT.SP!CT.TAB,CTTBL(R0) ;ALPHA, NUMERIC, TAB, OR SPACE?
	BEQ	10$		;  NO, EXIT MINUS
	CMP	R0,#CH.DOL	;YES, TRY DOLLAR
	BLO	20$		;SPACE
	BEQ	30$		;DOLLAR
	CMP	R0,#LET.A
	BLO	40$		;DOT OR DIGIT
	BR	50$		;ALPHA

10$:	MOV	#100000+SPACE,R0	;INVALID, FORCE MINUS
20$:	SUB	#SPACE-11,R0	;SPACE
30$:	SUB	#11-22,R0	;DOLLAR
40$:	SUB	#22-100,R0	;DOT, DIGIT
50$:	SUB	#100,R0		;ALPHABETIC
	RETURN
CVTNUM:				;CONVERT TEXT TO NUMERIC

				; IN  -  R2    RADIX

				; OUT -  VALUE RESULT
				; R0 - HIGH BIT  - OVERFLOW
				;    - HIGH BYTE - CHARACTER COUNT
				;    - LOW  BYTE - OVERSIZE COUNT


	SR1234
	CLR	R0		;RESULT FLAG REGISTER
	CLR	R1		;NUMERIC ACCUMULATOR
10$:	MOV	CHRPNT,SYMBEG	;SAVE FOR RESCAN
20$:	MOV	R5,R3		;GET A COPY OF THE CURRENT CHAR
	SUB	#DIG.0,R3	;CONVERT TO ABSOLUTE
	CMP	R3,#9.		;NUMERIC?
	BLOS	30$		;ITS OK
	SUB	#7.,R3		;A-F
	CMP	R3,#10.		;TOO SMALL?
	BLO	80$		;YEP
	CMP	R3,#16.		;TOO BIG?
	BHIS	80$		;YEP
30$:	CMP	R3,R2		;YES, LESS THAN RADIX?
	BLO	40$		;  YES
	INC	R0		;NO, BUMP "N" ERROR COUNT
40$:	MOV	R2,R4		;COPY OF CURRENT RADIX
	CLR	-(SP)		;TEMP AC
50$:	ASR	R4		;SHIFT RADIX
	BCC	60$		;BRANCH IF NO ACCUMULATION
	ADD	R1,(SP)		;ADD IN
60$:	TST	R4		;ANY MORE BITS TO PROCESS?
	BEQ	70$		;  NO
	ASL	R1		;YES, SHIFT PATTERN
	BCC	50$		;BRANCH IF NO OVERFLOW
	BIS	#100000,R0	;OH, OH.  FLAG IT
	BR	50$

70$:	MOV	(SP)+,R1	;SET NEW NUMBER
	ADD	R3,R1		;ADD IN CURRENT NUMBER
	ADD	#000400,R0	;TALLY CHARACTER COUNT
	CALL	GETCHR		;GET ANOTHER CHARACTER
	BNE	20$		;CONTINUE IF NOT EOL

80$:	MOV	R1,VALUE	;RETURN  RESULT IN "VALUE"
	BISB	#S.DEF,FLAGS	;PASS DEFINED FLAG
	RETURN			;RETURN, TESTING R0


GSARG:
TSTARG:				;TEST ARGUMENT
10$:	CALL	SETNB		;GET THE NEXT NON-BLANK CHAR
	MOVB	CTTBL(R5),R0	;GET CHARACTERISTICS
	BLE	50$		;THROUGH IF EOL OR SEMI-COLON
	BIT	#CT.COM,R0	;NO, COMMA?
	BNE	30$		;  YES, BYPASS IT
	TST	ARGCNT		;IS THIS THE FIRST ARGUMENT?
	BEQ	40$		;  YES, GOOD AS IS
	CMP	CHRPNT,ARGPNT	;DID ANYBODY USE ANYTHING?
	BNE	40$		;  YES, OK
20$:	CALL	GETCHR		;NO, BYPASS TO AVOID LOOPS
	BITB	#CT.PC+CT.SP+CT.TAB-CT.COM-CT.SMC,CTTBL(R5)
	BNE	20$		;  YES, BYPASS
	BR	10$		;NOW TRY AGAIN

30$:	CALL	GETNB		;BYPASS COMMA
	MOVB	CTTBL(R5),R0	;GOT A NEW CHAR, GET NEW FLAGS
40$:	INC	ARGCNT		;INCREMENT ARGUMENT COUNT
50$:	CLR	EXPFLG
	MOV	CHRPNT,ARGPNT	;SAVE POINTER
	BIC	#177600,R0	;SET FLAGS
	RETURN


	ENTSEC	IMPLIN		;CLEAR EACH LINE
ARGCNT:	.BLKW			;ARGUMENT COUNT
ARGPNT:	.BLKW			;START OF LAST ARGUMENT
EXPFLG:	.BLKW			;SET WHEN COMMA REQUIRED
	XITSEC
	.PAGE
CT.EOL=	000		; EOL
CT.COM=	001		; COMMA
CT.TAB=	002		; TAB
CT.SP=	004		; SPACE
CT.PCX=	010		; PRINTING CHARACTER
CT.NUM=	020		; NUMERIC
CT.ALP=	040		; ALPHA, DOT, DOLLAR
CT.LC=	100		;  LOWER CASE ALPHA
CT.SMC=	200		;  SEMI-COLON  (MINUS BIT)

CT.PC=	CT.COM!CT.SMC!CT.PCX!CT.NUM!CT.ALP	;PRINTING CHARS

	.MACRO	GENCTT	ARG	;GENERATE CHARACTER TYPE TABLE
	.IRP	A,	<ARG>
	.BYTE	CT.'A
	.ENDM
	.ENDM


	ENTSEC	PURE
CTTBL:				;CHARACTER TYPE TABLE
GENCTT	<EOL, EOL, EOL, EOL, EOL, EOL, EOL, EOL> ;nul soh stx etx eot enq ack bel
GENCTT	<EOL, TAB, EOL, EOL, EOL, EOL, EOL, EOL> ;bs  ht  lf  vt  ff  cr  so  si
GENCTT	<EOL, EOL, EOL, EOL, EOL, EOL, EOL, EOL> ;dle dc1 dc2 dc3 dc4 nak syn etb
GENCTT	<EOL, EOL, EOL, EOL, EOL, EOL, EOL, EOL> ;can em  sub esc fs  gs  rs  us

GENCTT	<SP , PCX, PCX, PCX, ALP, PCX, PCX, PCX> ;    !   "   #   $   %   &   '
GENCTT	<PCX, PCX, PCX, PCX, COM, PCX, ALP, PCX> ;(   )   *   +   ,   -   .   /
GENCTT	<NUM, NUM, NUM, NUM, NUM, NUM, NUM, NUM> ;0   1   2   3   4   5   6   7
GENCTT	<NUM, NUM, PCX, SMC, PCX, PCX, PCX, PCX> ;8   9   :   ;   <   =   >   ?

GENCTT	<PCX, ALP, ALP, ALP, ALP, ALP, ALP, ALP> ;@   A   B   C   D   E   F   G
GENCTT	<ALP, ALP, ALP, ALP, ALP, ALP, ALP, ALP> ;H   I   J   K   L   M   N   O
GENCTT	<ALP, ALP, ALP, ALP, ALP, ALP, ALP, ALP> ;P   Q   R   S   T   U   V   W
GENCTT	<ALP, ALP, ALP, PCX, PCX, PCX, PCX, PCX> ;X   Y   Z   [   \   ]   ^   _

GENCTT	<EOL, LC , LC , LC , LC , LC , LC , LC > ;`   a   b   c   d   e   f   g
GENCTT	<LC , LC , LC , LC , LC , LC , LC , LC > ;h   i   j   k   l   m   n   o
GENCTT	<LC , LC , LC , LC , LC , LC , LC , LC > ;p   q   r   s   t   u   v   w
GENCTT	<LC , LC , LC , PCX, PCX, PCX, PCX, EOL> ;x   y   z   {   |   }   ~   del

	XITSEC
SETSYM:				;SET SYMBOL FOR RE-SCAN
	MOV	SYMBEG,CHRPNT	;SET THE POINTER
	BR	SETCHR		;SET CHARACTER AND FLAGS

GETNB:				;GET A NON-BLANK CHARACTER
	INC	CHRPNT		;BUMP POINTER
SETNB::	CALL	SETCHR		;SET REGISTER AND FLAGS
	BITB	#CT.SP!CT.TAB,CTTBL(R5)	;BLANK?
	BNE	GETNB		;  YES, BYPASS
	BR	SETCHR		;EXIT, SETTING FLAGS

GETCHR::			;GET THE NEXT CHARACTER
	INC	CHRPNT		;BUMP POINTER
SETCHR::MOVB	@CHRPNT,R5	;SET REGISTER AND FLAGS
	BPL	10$		;OK IF NO SIGN BIT
	SUB	#177600+40,R5	;TRY FOR LOWER CASE MAP
	BGE	10$		;OK IF NOT 0 OR MINUS
	ERROR	I,1		;ELSE FLAG INVALID CHAR
	BR	GETCHR		;LOOP ON INVALID CHARACTER
10$:	RETURN

CHSCAN:				;CHARACTER SCAN ROUTINE
10$:	TST	(R0)+		;END (ZERO)?
	BEQ	20$		;  YES
	CMP	(R0)+,R5	;THIS THE ONE?
	BNE	10$		;  NO
	TST	-(R0)		;YES, MOVE POINTER BACK
	MOV	CHRPNT,SYMBEG	;SAVE CURRENT POINTER
	CALL	GETNB		;GET NEXT NON-BLANK
20$:	MOV	-(R0),R0	;MOVE ADDR OR ZERO INTO R0
	RETURN

SETXPR:				;SET EXPRESSION REGISTERS
	MOV	#SYMBOL,R1
	MOV	#SECTOR,R2
	MOV	#MODE,R3
	MOV	#VALUE,R4
	RETURN
	.SBTTL EXPR - Expression evaluator
; **-EXPR-EXPRESSION EVALUATION

EXPR::	SR1234			;SAVE REGISTERS
EXPI:	CALL	TERMI		;++023 GET FIRST TERM
	TST	R0		;++023 TEST RESULT
	BEQ	50$		;EXIT IF NULL
10$:	CALL	SETXPR		;SET EXPRESSION REGISTERS
	CHSCAN	BOPTBL		;SCAN THE BINARY OPERATOR TABLE
	BEQ	20$		;  BRANCH IF NOT FOUND
	CALL	60$		;FOUND, CALL HANDLER
	BR	10$		;TEST FOR MORE

20$:
30$:	TST	RELLVL		;TEST RELOCATON LEVEL
	BEQ	40$		; OK IF 0
	ERROR	A		;NOT ALLOWED
40$:
	MOV	SP,R0		;SET TRUE
50$:	RETURN

60$:	MOV	R0,-(SP)	;++001 STACK OPERATOR ROUTINE ADDRESS
	MOV	(R1)+,-(SP)	;STACK SYMBOL
	MOV	(R1)+,-(SP)
	MOV	(R1)+,-(SP)	;  MODE,
	MOV	(R1)+,-(SP)	;  VALUE,
	MOV	(R1)+,-(SP)	;  AND REL LEVEL
	CALL	TERMI		;++024 GET NEXT TERM
	MOV	#EXPBAK+10.,R3	;++024 POINT TO EXPRESSION SCRATCH AREA
	MOV	(SP)+,-(R3)	;++024 UNSTACK PREVIOUS RELOCATION LEVEL
	MOV	(SP)+,-(R3)	;++024 		VALUE,
	MOV	R3,R2		;++024 LEAVE R2 POINTING TO PREVIOUS VALUE
	MOV	(SP)+,-(R3)	;++024 		MODE (FLAG & PSECT)
	MOV	(SP)+,-(R3)	;++024		AND SYMBOL.
	MOV	(SP)+,-(R3)	;++024
	CMPB	-(R2),-(R4)	;++019 ARE PSECT'S THE SAME?
	BEQ	70$		;++019 YES, PSECT TEST SUCCESS
	TSTB	(R2)		;++019 ELSE, IS FIRST VALUE A CONSTANT?
	BEQ	70$		;++019 YES, PSECT TEST SUCCESS
	TSTB	(R4)		;++019 ELSE, IS SECOND VALUE A CONSTANT?
	BEQ	70$		;++019 YES, PSECT TEST SUCCESS
	ERROR	A		;NOPE, ERROR U CAN'T DO COMPLEX IN COMPLEX

70$:	CMPB	(R2)+,(R4)+	;++019 RESTORE REGISTERS
	BIS	-(R2),-(R4)	;MERGE ATTRIBUTES AND PSECT NUMBERS
	CMP	(R2)+,(R4)+	;RESTORE REGISTERS
	JMP	@(SP)+		;DISPATCH TO BINARY OPERATOR FUNCTION

	ENTSEC	IMPLIN
EXPBAK:	.BLKW	5
ERRSTK:	.BLKW	1
EXPFGS::.BLKW	1
	XITSEC

	ENTSEC	PURE		;++017
BOPTBL:				;BINARY OP TABLE
	GCHTBL	CH.ADD,	BOPADD  ; "+" ADD
	GCHTBL	CH.SUB,	BOPSUB  ; "-" SUB
	GCHTBL	CH.MUL,	BOPMUL	; "*" MUL
	GCHTBL	CH.DIV,	BOPDIV	; "/" DIV
	GCHTBL	CH.AND,	BOPAND	; "&" AND
	GCHTBL	CH.IOR,	BOPIOR	; "!" OR
	GCHTBL	CH.QM,	BOPXOR	; "?" XOR
	.WORD	0
	XITSEC

BOPSUB:	NEG	(R4)		; -, NEGATE VALUE
	NEG	RELLVL		;  AND RELLVL
	BR	ADDX		;++001 BRANCH INTO COMMON CODE

BOPADD:
ADDX:	ADD	(R2)+,(R4)+	;++001 + ADD VALUES
	ADD	(R2),(R4)	;  AND RELOCATION LEVELS
	CMP	-(R2),-(R4)	;POINT BACK TO VALUES
	BIT	#177400,-(R2)	;++019 FIRST VALUE CONSTANT?
	BEQ	10$		;++019 YES, CONSIDER ADDITION DONE
	BIT	#177400,-(R4)	;++019 SECOND VALUE CONSTANT?
	BEQ	20$		;++019 YES, USE ATTRIBUTES OF FIRST VALUE
	BISB	(R2),(R4)	;++019 NO CONSTANTS--MERGE ATTRIBUTES
10$:	RETURN

20$:	MOV	(R3)+,(R1)+	;++024 TRANSFER PREVIOUS SYMBOL NAME
	MOV	(R3)+,(R1)+	;++024 
	BIS	(R3)+,(R1)+	;++024 AND MERGE PREVIOUS ATTRIBUTES
	RETURN

BOPAND:	COM	(R2)
	BIC	(R2),(R4)
	RETURN

BOPIOR:	BIS	(R2),(R4)
	RETURN

BOPXOR:	MOV	(R2),-(SP)
	BIC	(R4),(SP)
	BIC	(R2),(R4)
	BIS	(SP)+,(R4)
	RETURN

BOPMUL:	MOV	(R2),R0		;FETCH FIRST ARGUMENT
	MOV	(R4),R3		;SET SECOND ARG
	MUL	R3,R0		;MULTIPLY
	MOV	R1,(R4)		;PASS BACK ANSWER
	RETURN

BOPDIV:	MOV	(R4),R3		;GET DIVISOR
	MOV	(R2),R1		;GET DIVIDEND
	SXT	R0		;SIGN EXTENDED
	DIV	R3,R0		;DIVIDE
	MOV	R0,(R4)		;SET RESULT
	RETURN
	.SBTTL	TERM EVALUATOR

TERM:	SR1234			;SAVE REGISTERS
TERMI:				;++023 REF LABEL FOR INTERNAL ENTRY
	CALL	SETXPR		;  AND SET "EXPRESSION" TYPE
	CLR	(R3)		;CLEAR MODE
	CLR	(R4)		;  AND VALUE
	CALL	TERM10		;PROCESS TERM
	BIC	#^C<S.DEF>,(R3)	;CLEAR EXTRANEOUS
	CLR	RELLVL		;ASSUME ABSOLUTE
	BIT	#S.REL,(R3)	;TRUE?
	BEQ	10$
	INC	RELLVL		;  NO, RELOCATABLE
10$:	INC	EXPFLG		;MARK AS EXPRESSION
	JMP	SETNB		;EXIT WITH NON-BLANK AND R0 SET

TERM10:	CALL	GETSYM		;TRY FOR A SYMBOL
	BEQ	TERM20		;BRANCH IF NOT A SYMBOL
	SEARCH	SYMROL		;SEARCH THE SYMBOL TABLE
	BEQ	10$		;BRANCH IF NOT FOUND
	BIT	#S.DEF,(R3)	;DEFINED?
	BNE	20$		;  YES
10$:	ERROR	U		;NO, UNDEFINED ERROR
20$:	BIC	#^C<S.DEF>,(R3)	;CLEAR UNUSED STUFF
CRFTRM:	BR	TERM28
TERM20:
	MOV	CRADIX,R2	;ASSUME NUMBER, CURRENT RADIX
10$:	CALL	CVTNUM		;CONVERT
	BEQ	TERM30		;  NOPE, MISSED AGAIN
	BPL	20$		;NUMBER, ANY OVERFLOW?
	ERROR	T		;  YES, FLAG IT
20$:	CMP	R5,#CH.DOT	;NUMBER, DECIMAL?
	BEQ	30$		;  YES
	TSTB	R0		;NO, ANY NUMBERS OUT OF RANGE?
	BEQ	TERM28		;  NO
	ERROR	N		;YES, FLAG IT
	CMP	R2,#16.		;HEX?
	BEQ	60$		;YEP. CAN'T DO ANYMORE
	CMP	R2,#10.		;DECIMAL?
	BNE	40$		;TRY AGAIN WITH DECIMAL
	MOV	#16.,R2		;ELSE TRY WITH HEX
	BR	50$

30$:	CMP	R2,#10.		;"." OR "$", WERE WE DECIMAL?
	BEQ	60$		;  YES
40$:	MOV	#10.,R2		;  TRY AGAIN WITH DECIMAL RADIX
50$:	CALL	SETSYM		;RESET POINTERS
	BR	10$

60$:	CMP	R5,#CH.DOT	;DECIMAL?
	BEQ	TERM27		;  YES

TERM26:	ERROR	U		;  NO, FLAG AS UNDEFINED
TERM27:	CALL	GETCHR		;BYPASS DOT OR DOLLAR
TERM28:
ALT28:	CALL	SETNB		;++001 RETURN POINTING TO NON-BLANK
	MOV	SP,R0		;SET NON-ZERO
TERM29:	RETURN

TERM30:	CHSCAN	UOPTBL		;SCAN UNARY OPERATOR TABLE
	BEQ	TERM29		;  NOT THERE
	CLR	R2		;CLEAR FOR FUTURE USE
	CALL	(R0)		;FOUND, GO AND PROCESS
	BR	ALT28		;++001 EXIT TRUE VIA ALTERNATE EXIT

	ENTSEC	PURE		;++017
UOPTBL:
	GCHTBL	CH.ADD,	TERMI	; "+" ++024
	GCHTBL	CH.SUB,	TERM42	; "-"
	GCHTBL	CH.LAB,	TERM47	; "<"
	GCHTBL	CH.UAR,	TERM50	; "^"
	.WORD	0
	XITSEC

TERM42:	MOV	#1,-(SP)	;++001 INDICATE NEGATE BY 1 ON STACK
	BR	COMTRX		;++001 USE COMMON CODE TO PROCESS

TERM47:				;++023 "<"
	CALL	EXPI		;++023 EVALUATE EXPRESSION
	CMP	R5,#CH.RAB	;">"?
	BNE	TERM48		;++001 NO, REPORT ERROR
	CALL	GETCHR		;++001 YES, BYPASS IT
	BR	ALT28		;++001 EXIT

TERM48:	ERROR	A		;NFG
	CLR	R0		;SAY FAIL
	RETURN	
	.PAGE
TERM50:	CHSCAN	UARTBL		;"^"-SCAN ON NEXT CHARACTER
	BEQ	TERM48		;  INVALID, ERROR
	JMP	(R0)		;CALL ROUTINE

	ENTSEC	PURE		;++017
UARTBL:				;UP ARROW TABLE
	GCHTBL	LET.C,	TERM51	;  ^C = COMPLIMENT
	GCHTBL	LET.D,	TERM52	;  ^D = DECIMAL RADIX
	GCHTBL	LET.O,	TERM53	;  ^O = OCTAL RADIX
	GCHTBL	LET.B	TERM54	;  ^B = BINARY RADIX
	GCHTBL	LET.H,	TERM57	;  ^H = HEX RADIX
	GCHTBL	LET.X,	TERM57	;  ^X = HEX RADIX
	GCHTBL	'R,	TERM56	;  ^R = RAD50
	GCHTBL	'S,	TERM58	;  ^S = SECTION SIZE
	.WORD	0
	XITSEC

TERM51:	CLR	-(SP)		;++001 INDICATE COMPLEMENT BY 0 ON STACK
COMTRX:	CALL	TERMI		;++024 GET GLOBAL TERM
	COM	(R4)		;++001 COMPLEMENT VALUE
	ADD	(SP)+,(R4)	;++001 MAKE IT NEGATE IF 1 ON STACK
	NEG	RELLVL		;++001 NEGATE THE RELOCATION LEVEL
	JMP	TERM28

TERM57:	ADD	#6.,R2		;HEX
TERM52:	ADD	#2.,R2		;DECIMAL
TERM53:	ADD	#6.,R2		;OCTAL
TERM54:	ADD	#2.,R2		;BINARY
	MOV	CRADIX,-(SP)	;STACK CURRENT RADIX
	MOV	R2,CRADIX	;REPLACE WITH LOCAL
	CALL	TERMI		;++024 EVALUATE TERM
	MOV	(SP)+,CRADIX	;RESTORE RADIX
	JMP	TERM28

TERM56:				;++022 ^R
	CALL	SETSYM		;++022 BACK UP CHAR PTR TO THE "R"
	MOV	#64,R2		;++022 SET CONTROL MASK IN R2
10$:	CALL	GETR50		;++022 FETCH A RADIX-50 CHAR
	BMI	40$		;++ IF MI, NON-RAD50 CHAR ENCOUNTERED
	TST	R2		;++022 CHECK CONTROL MASK
	BEQ	10$		;++022 IF EQ SKIP CHARS PAST 3
20$:	ASR	R2		;++022 SHIFT CONTROL MASK
	BCS	30$		;++022 IF CS PROPER RAD50 POWER REACHED
	CALL	MULR50		;++022 ELSE, MULTIPLY BY 50
	BR	20$		;++022 REPEAT MULTIPLY LOOP
30$:	ADD	R0,(R4)		;++022 ADD RESULT TO ACCUMULATED VALUE
	BR	10$		;++022 REPEAT FOR 3 RADIX-50 CHARACTERS
40$:	JMP	TERM28

TERM58:	CALL	GETSYM		;TRY FOR A SYMBOL
	BNE	20$		;OK
10$:	ERROR	U		;NFG
	BR	50$

20$:	SCAN SECROL		;LOOK IN THE PSECT ROLL FOR THE NAME
	BEQ	10$		;TWAS'NT THERE
	MOV	SYMBOL+8.,R2	;ACCUMULATE SIZES
30$:	SCANC	SECROL		;GET THE NEXT ONE
	BEQ	40$		;DONE
	ADD	SYMBOL+8.,R2	;ACCUMULATE SIZES
	BR	30$		;UNTIL NO MORE

40$:	CLR	FLAGS		;MAKE SURE ITS SET ABS
	MOV	R2,(R4)		;PASS THE VALUE
50$:	JMP	TERM28		;EXIT TRUE

	ENTSEC ROLBAS
ROLEND:
	.PSECT	IMPURE
IMPEND:
	.PSECT	IMPLIN
IMPLEN:
	XITSEC
	.END START
